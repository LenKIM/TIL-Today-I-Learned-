문제.

1. **스케쥴링의 가장 이상적인 기준은?**  

프로세서 사용률과 처리율을 극대화하고, 반환시간, 대기시간, 응답시간을 최소화하는 것이 바람직하다.

2. **스케줄링의 성능 기준 요소?**  
   프로세서 이용률 증가, 처리률 증가, 반환 시간 감소, 대기시간 감소, 반응시간 감소

3. **CPU 스케줄링의 목적은?**  

   공정한 스케줄링, 
   처리량 극대화,
    응답시간 최소화,
    반환 시간 예측 가능,
    균형있는 자원 사용,
    응답 시간과 자원 이용간의 조화,
    실행의 무한 연기 배제등

4. **다단계 피드백 큐 스케줄링 알고리즘과 전면 작업에는 라운드 로빈(순환 할당) 스케줄링을 사용하고, 후면 작업에는 선점 우선순위 알고리즘을 사용하는 다단계(전면-후면) 프로세서 스케줄링 알고리즘의 차이를 설명해보자.**  

다단계 피드백 큐: 입출력 위주와 CPU위주인 프로세스의 특성에 따라 서로 다른 CPU의 타임 슬라이스를 부여한다, 새로운 프로세스가 들어오면 높은 우선순위를 할당해 주어 단계 1에서 즉시 수행해 주고 점차 낮은 우선순위를 부여한다. 임의의 단계 n이 된후에는 그 작업이 완료될 때까지 라운드 로빈으로 순환된다.

다단계 큐: 작업들을 여러 종류의 그룹으로 나누어 여러개의 큐를 이용하는 스케줄링 기법, 그룹화된 작업 들은 각각의 준비 큐에 넣어두고 각 큐의 독자적인 스케줄링 알고리즘에 따라서 CPU를 할당받는 방식

5. **논리적 주소와 물리적 주소 차이는 무엇일까요?**

논리적 주소는 메모리 위치를 참조하고, 메모리에 있는 프로세스 코드와 데이터의 현재 위치는 별개  
물리적 주소는 메모리에 저장하거나 인출, 데이터에 사용되는 절대 주소 또는 실제 주소.

6. **내부 단편화와 외부 단편화의 차이는?**  

내부 단편화는 프로그램의 사이즈가 정해진 단위의 블록으로 나뉘다가 정해진 단위의 사이즈보다 조금 커져 조금 큰 부분을 하나의 블록에 저장하게 되어 블록 안에 생기는 빈 공간을 말한다.

외부단편화는 세그먼트와 세그먼트 사이의 공간이 다른 세그먼트는 들어갈 수 없을 정도의 빈공간이 생기는 것

-----



7. **내부 단편화, 외부 단편화 중 어떤 것이 메모리 낭비가 더 큰가? 그리고 단편화를 해결하기 위한 방법은?**

 외부 단편화가 더 클것이라 생각된다. 왜냐하면 내부단편화는 쓰고 남은 부분을 가리키지만, 외부 단편화의 경우, 세그먼트또는 페이지의 한 단위자체를 쓰지 못하기 때문에 낭비가 더 클것이다. 이를 해결하기 위해 병합 또는 압축으로 해결함. 
**동적 재배치를 해야되는데, 프로그램의 시간이 많이 걸리기 때문에 비용이 많이 소모된다.**

8. **페이징 방식과 세그먼트 방식에서 발생하는 메모리 단편화의 종류는 각각 무엇인가? 또한, 세그먼트 방식의 장점은 무엇인가?**

    페이징 방식의 경우에는 내부 단편화가 빈번하게 발생하고, 세그먼트 방식에서는 외부 단편화가 빈번하게 발생한다.  또한 세그먼트의 장점이라 하면, 페이징 방식과 같이 크기가 일정하지 않지만 같은 성질을 같은 프로세스단위로 주소를 지정하기 때문에 공간의 낭비를 줄일 수 있습니다.

   **보호와 공유 기능도 포함 된다.** **=> 세그먼트의 base limit 벗어날경우 trap을 발생시킨다.**

9. **32비트 시스템에서 페이지 크기가 4KB일 때, 4GB 메모리에 접근하기 위해 필요한 페이지 테이블의 크기는? (페이지 엔트리의 크기는 4Byte 이다.)**

   1M 개가 필요하고, 2^32

   4 *2^10 /  4 ^ 2^30 => **2^20** = **1M** // 페이지의 개수이다. (엔트리의 개수와 동일)  
   4 * 1M => 4M

10. **다음과 같이 기억 장치가 분할 되어 있을 때, 최적 적합(Best-Fit) 알고리즘을 사용하여 234, 456, 123, 456 순으로 프로세스를 배치 할 경우 생기는 내부단편화 크기와 외부단편화의 크기는?** 

![](https://ws2.sinaimg.cn/large/006tNc79gy1fn5gq5r7u5j309q0icweu.jpg)

11. 다음의 페이지 테이블을 참고하여, 페이지 크기가 4096Byte일 때, 가상주소에 해당하는 **가상페이지 번호**(VPN) 및 **물리페이지 번호(PPN)**와 **물리주소 값**을 각각 계산하시오.

![](https://ws4.sinaimg.cn/large/006tNc79gy1fn5jsomh7uj30sk0ns0tx.jpg)



11. 다음 중 옳은 것을 모두 골라주세요.** 1, 3, 5.

**(1번) CPU 스케쥴링 시 프로세스를 선택하는 기준은 CPU 이용률, 처리량, 총 처리 시간, 대기 시간, 응답시간이며 이 기준들을 이용해 최적화를 시켜주려면, CPU 이용률과 처리량을 최대화 시켜주고, 총 처리시간과 대기 시간, 그리고 응답시간을 최소화 시켜줘야 한다.** 

(2번) 스케쥴링 알고리즘 중 FCFS 알고리즘에서 발생할 수 있는 문제점은 기아현상이다. 이는 CPU 이용률 저하의 요인이 된다.

**(3번) 스케쥴링 알고리즘 중 우선순위 알고리즘에서 발생할 수 있는 문제점은 기아현상이다. 이는 낮은 우선순위의 프로세스가 전혀 실행되지 않는 문제점을 일으키는 데, 이를 해결하기 위해 시간이 지나면서 우선순위를 높여주는 방식으로 해결할 수 있다.**

****(4번) 스케쥴링 알고리즘 중 라운드-로빈 방식의 특징은 타임 퀀텀의 존재이다. 일반적으로 타임 퀀텀은 10 ~ 100 ms로 잡아주는 것이 일반적이다. 만약 크게 잡는다면 FCFS와 같은 방식으로 진행될 수 있고, 낮게 잡으면 문맥 교환이 자주 일어나 많은 오버헤드가 발생할 수 있다.

**(5번) 여러 스케쥴링 알고리즘 중에서 최소 대기 시간을 만족하는 알고리즘은 SJF 알고리즘이다.**



12. **다음 표를 보고 FCFS, SJF, SRTF, RR 알고리즘을 이용한 CPU의 간트차트를 그리고, 각각의 알고리즘에 대한 각각의 프로세스의 대기사간 및 처리시간과 평균 대기시간 및 처리시간을 구하시오. (RR 알고리즘에서의 타임 퀀텀은 3이라 가정한다.)**

| 프로세스 | 도착시간 | 1st CPU | 1st I/O | 2nd CPU | 2nd I/O | 3rd CPU |
| ---- | ---- | ------- | ------- | ------- | ------- | ------- |
| A    | 0    | 4       | 4       | 4       | 4       | 4       |
| B    | 2    | 8       | 1       | 8       | -       | -       |
| C    | 3    | 2       | 1       | 2       | -       | -       |
| D    | 7    | 1       | 1       | 1       | 1       | 1       |

FCFS:  

SJF:  

SRTF:  

RR:  



13. **다음 설명 중 틀린 것을 모두 고르시오.** 2, 3, 5

    (1번) 메모리 관리 전략을 구분 짓자면, 페치 전략, 배치 전략, 교체 전략이 있다. 페치 전략은 보조 기억 장치에 있는 프로그램이나 데이터를 메인 메모리로 옮기는 시점을 결정하는 것이고, 배치 전략은 새로 load하는 프로그램이나 데이터의 부분을 놓을 메인 메모리 위치를 결정하는 것이고, 교체 전략은 메모리가 새로운 프로그램을 수용하기에 부족한 경우 어떤 부분의 교체를 결정하는 것이다.

    **(2번) 메인 메모리를 고정된 크기의 파티션으로 나눌 때 생기는 단점은 외부 단편화로 인한 메모리 낭비와 시스템 활용도 저하이다.**

    **(3번) 외부단편화의 문제를 가변 크기의 파티션을 나눈다면 새로이 생기는 문제점을 사용하지 않는 인접한 공간들을 병합하여 하나로 만드는 방법과 비어 있는 공간을 하나로 압축하는 방법이 있다.**

    ****(4번) 메모리 배치를 하는 방법으론 first-fit, best-fit, worst-fit이 있다. First-fit은 처음 발견된 넉넉한 공간에 배치함으로써 빠른 배치가 가능하고, best-fit은 가장 잘 맞는 부분에 배치하여 사용하지 않는 부분을 최소화 시켜준다. Worst-fit은 가장 큰 공간에 배치하는 전략이다.

    **(5번) 다중 멀티프로그래밍 정도에 따라 CPU 이용률은 상승한다. => 쓰레싱의 때문에 CPU이용률이 절정부분에서** 

    *Cf)  활발하게 사용되는 페이지 집합을 지원해 줄 만큼 프레임이 충분히 할당 받지 못한 프로세스는*  
    *페이지 부재가 발생하게 된다.*

14. **페이지 교체 알고리즘 중 LRU 알고리즘을 사용했을 때 페이지 부재는 몇 번 일어나는가?**

    프레임 크기: 4 / 페이지 순서: 2,0,3,1,2,0,3,1,2,0,3,1,6,4,5,7


15. **라운드 로빈 스케줄링에서 할당 시간 양을 점차 늘리거나 감소시켰을 때 각각 어떤 효과가 있는가?**
    ​
    라운드 로빈 스켸줄링에서 할당시간을 짫게 할 경우 잦은 빈도의 문맥교환이 이루어 질 테고, 만약 할당 시간을 길게 할경우 FCFS 와 같이 동작하게 될 것이다.
    ​

    모범답안)

    할당시간 quantum time을 줄이는 경우 fairness가 보장되지만, context switching에 소요되는 overhead가 증가하기 때문에 CPU효율이 떨어진다. 할당시간이 늘어나는 경우 Context switching 횟수가 줄어서 오버헤드는 감소하고, 그만큼 CPU활용도는 높아지지만 fairness가 보장되지 않으며 시분할방식의 효과가 줄어든다. 또한 FCFS방식과 동일해진다. 입출력 위주의 작업이나 긴급을 요하는 작업에 신속히 반응하지 못한다.
    ​

16. **페이지 부재를 처리하는 과정을 순서대로 나타내라.**
    ㄱ. 가용 페이지가 주 기억 장치에 적재되고 상황에 따라 다른 페이지가 해제된다.

    ㄴ. 프로세스가 페이지를 참조한다. 페이지 부재를 발생시킨 프로세스는 중단된다.

    ㄷ. 기억 장치 관리자의 페이지 테이블은 갱신된다.

    ㄹ. 기억 장치 관리자는 보조 기억 장치에서 가용 페이지를 찾는다.

    ㅁ. 페이지 보호 비트를 확인한다.

    ㅂ. 프로세스는 중단 되었던 시점에서 다시 시작된다.

    **ㄴ-ㅁ-ㄹ-ㄱ-ㄷ-ㅂ**

    ​

    ㄴ. 프로세스가 페이지를 참조한다. 페이지 부재를 발생시킨 프로세스는 중단된다.
    ㅁ. 페이지 보호 비트를 확인한다.
    ㄹ. 기억장치 관리자는 보조 기억장치에서 가용페이지를 찾는다.
    ㄱ. 가용페이지가 주기억장치에 적재되고 상황에 따라 다른 페이지가 해제된다.
    ㄷ. 기억장치관리자의 페이지 테이블은 갱신된다.
    ㅂ. 프로세스는 중단되었던 시점에서 다시 시작된다.
    ​

    ​

17. **TLBs 검색에 50nsec, Main Memory 접근에 750 nsec가 소요된다고 할 때 적중률이 80%인 경우의 유효 기억장치 접근 시간을 구하여라**.

    // 0.8 * 50 + 0.2 *(800)  왜 950?

    **0.8(50+750) + 0.2 (50 + 750 + 750) = 950** 

    [http://itdexter.tistory.com/405](http://itdexter.tistory.com/405)

18. **OX퀴즈**  

    1. HRN(Highest Response-ratio Next) 스케줄링 방식은 대기 시간이 긴 프로세스일 경우 우선순위가 낮아진다.(X)
    2. Paging 기법에서 TLBs를 사용하면 Main Memory만을 사용했을 때 보다 메모리에 접근 하는 횟수가 같거나 더많다. (X)  
       => 캐쉬 메모리
    3. Paging Segment 기법을 사용하면 내부 외부 단편화 문제를 모두 해결할 수 있다.(X)

19. **페이지 테이블을 메모리에 저장한 페이징 시스템**

    1. 메모리 참조가 200ns 소요된다면, 페이지로 된 기억장치의 참조의 소요시간은? 400ns
    2. 연관 레지스터를 추가하여 모든 페이지 테이블 참조의 75%를 연관 레지스터에서 찾는다면, 실제 메모리 접근시간은?(단, 연관 레지스터에서 어떤 페이지 테이블 항목을 찾을 때 해당 항목이 그곳에 있다면 시간은 걸리지 않는다고 가정한다. 250ns  
       **0.75 * 200 + 0.25(400) = 250ns**

20. **페이지 크기가 4KB이고 메모리 크기가 256KB인 메모리 페이징 시스템이 있을 때.**

    1) 페이지 프레임 수는?  64개

    2) 이 메모리 주소를 해결하는 데 필요한 비트 수는?  256KB => 2^18

    3) 페이지 번호에 사용하는 비트와 페이지 오프셋에 사용하는 비트는? 6, 12

21. **로더(Loader)의 역할**

     운영체제의 일부분으로, SSD나 외부메모리르 적재하거나 실행하게 하는 역할. 그래서 적재자라고도 한다.

     메모리의 공간을 확보, 연결, 링커안에 로러다가 존재한다. 상대주소를 절대주소(MMU), 적재

22. **각 스케줄러의 역할**

    1. 장기 스케줄러 - 
       프로세스의 준비큐를 담당하는 역할로, 초, 분단위의 긴 시간이 걸리는  I/O와의 관계에서 장기 스케줄러를 활용한다.  
    2. 단기 스케줄러 - CPU내부에서 인터럽스서비스루틴이나, CPU 큐에서 나노타임에 해결해야되는 프로세스를 담당한다. 디스패처, 실행준비완료된 것을 빼내는 것!
    3. 중기 스케줄러 - Block 또는 Suspend된 프로세스가 만약 메모리의 차지가 크다면 스와핑을 통해 보조기억장치에 적재 또는 로드해주는 역할을 담당한다.
       ​

23. **SJF 방법의 단점을 보완하려고 대기시간을 고려한 프로세스의 응답률로, 프로세스의 우선순위를 결정하는 프로세스 스케줄링 방법은?** HRN 스케줄링

    ​

24. **HRN방법으로 스케줄링 할 때 입력된 작업이 다음과 같다면 가장 먼저 실행될 작업은?** D - C - B - A

    | 작업   | 대기시간 | 서비스 시간 |
    | ---- | ---- | ------ |
    | A    | 8    | 2      |
    | B    | 10   | 6      |
    | C    | 15   | 7      |
    | D    | 20   | 2      |

25. 다음 작업들을 Round-Robin 스케줄링을 사용하여 실행 할 경우, 작업의 평균 반환시간(Turn around time)과 평균 대기시간(Waiting time)을 구하세요(Time Quantum = 4ms)

| process | A    | B    | C    | D    |
| ------- | ---- | ---- | ---- | ---- |
| 도착시간    | 0    | 1    | 2    | 3    |
| 실행시간    | 10   | 2    | 9    | 5    |

26. 4096(2^12)워드를 가진 페이지들이 8개 모여 구성된 논리주소 공간이 있다. 이들이 32개의 페이지 프레임(실제 기억 공간) d로 사상 된다고 하자.

1) 논리주소에 몇 개가? 또, 그 산출 근거를 밝히세요.15 bit
논리 주소이므로, 2^12의 워드라서 12개의 비트와 3개의 비트(8개의 페이지)가 합쳐저 15bit

2) 물리주소에 몇 개의 비트(bit)가 있는가? 또, 그 산출 근거를 밝히세요. 17 bit

물리주소이므로,  32개의 페이지 프레임이 물리주소 ! 그러므로 2^5 여기서 12bit가 오프셋이기 때문에 12+ 5 = 17.

27. 페이지 기억 장치 할당 기법에서, 한페이지의 크기가 512Byte이고 페이지 번호는 0번부터 시각한다면, 논리적인 주소 1224번지는 어디로 변환되는가? 3
    1. 페이지 1, 변위 200
    2. 페이지 200, 변위 1
    3. 페이지 2, 변위 200
    4. 페이지 200, 변위 2