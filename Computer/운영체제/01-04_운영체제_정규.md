1. **메모리에 있는 프로세스 주소 공간의 구성 요소와 역할**

   스택 코드 데이터 힙
   ​

2. **스레드를 이용할 때 이점은?**

   프로세스의 활용을 극대화 시켜, 자원낭비를 없앨 수 있다.  
   Context switch할 때 효율적이다. 스택영역만 독립적으로 가지고 있고 그 외 다른 것은 서로 공유하고 있다.

3. ​
   1) 한 작업을 여러 프로세서가 나눠 처리하는 것  
   2) 한 프로세서가 여러 작업을 나눠 처리하는 것   
   3) 한 프로세스의 병렬처리가 가능한 것    

   ​

4. **디스크 입력은 커널 레벨 쓰레드 / 유저 레벨 쓰레드 중 어떤 것이 유리한가? 그 이유는?**

   보조기억장치에서 저장 및로드를 실행할 때 프로세스에서 상호배제를 통제하기 위해?
   ​

   병행처리가 가능 / 불가능 Why? 커널에서 유저 레벨 쓰레드의 상태를 모르기 때문에.  
   커널 레벨 Thread -> IO요청하는 쓰레드가 포함되어있는 다른 쓰레드가 정지되어있기 때문에  
   ​

5. **다음 대사를 읽고 문제를 풀어보세요**

   **A: 메모리 접근 오류나 오버플로우와 같은 사용자 프로그램 오류를 증인은 뭘 보고 어떻게 판단하였습니까? 판단 근거가 뭡니까?**

   **B: 내가 판단하는 게 아니라 C가 판단합니다.**

   **A: C? 증인이 말하는 C란 대체 뭡니까?**

   **B: 프로그래머라는 사람이 C가 뭔지 몰라?**

   **A: 압니다, 너무 잘 알죠, (                             ㄱ                                  ), C란 ( ㄴ )입니다. 근데 증인이야 말로!! C를 단지 그냥 컴퓨터 키면 켜지는 프로그램으로만 치부하고 있지 않소!!**

   **1번) C는 무엇인가?** 운영체제

   **2번) ㄱ, ㄴ 에 들어갈 말은? (ㄱ: C의 정의와 기능 / ㄴ: C를 표현하기 위한 적합한 한 단어)**

   - ㄱ: 운영체제란 컴퓨터 하드웨어 관리하는 프로그램, 자원을 관리하고 스케쥴링하는 자원 할당기, 프로그램의 실행을 제어하는 프로그램, 항상 메모리에 상주하는 커널 프로그램이다. 운영체제가 제공하는 기능은 사용자 인터페이스, 프로그램 수행, 입출력 연산, 파일 시스템 조작, 통신, 오류 검출이 있다.  


   - ㄴ : 중제자  

   **3번) 이 대사에서 B가 착각하고 있는 사실은?**	

   “C를 단지 그냥 컴퓨터 키면 켜지는 프로그램으로만 치부하고 있지 않소!!”: 컴퓨터 키면 켜지는 프로그램은 엄밀히 말하자면 운영체제는 아니고 부트스트랩 프로그램이다. 시스템의 모든 사항을 초기화하고 운영체제의 커널을 찾아 메모리에 적재하고 실행을 시작한다.

   **[부팅과정]**

   1. 컴퓨터에 전원을 인가하면 ROM에 저장된 BIOS가 실행된다.

   2. BIOS는 CPU, 메인 메모리, 하드 디스크와 같은 각종 하드웨어의 상태를 검사한 후 이상이 있으면 오류를 통지하고 동작을 멈춘다.

   3. BIOS는 부팅 메체인 하드디스크에 저장된 부트스트랩 로더를 메인메모리로 옮긴다. 2개 이상의 부팅 매체를 지정하여 BIOS로 하여금 운영체제를 선택하도록 할 수도 있는데, 이를 멀티 부팅이라고 한다.

   4. 부팅로더는 BIOS를 종료하고 하드디스크에 저장된 운영체제를 메인 메모리에 적재한 후 운영체제에 제어권을 넘긴다.

   5. 운영체제는 응용 소프트웨어의 실행 환경을 조성한다.

   6. 부트로더가 하드디스크에 있는 운영체제 커널을 찾아 RAM에 적제한다.

   7. 부트로더는 제어권을 운영체제에게 전달한다.

      ​

8. **프로세스와 스레드는?**
   스레드는 프로세스안에서 동일한 작업단위를 나눠서 수행합니다. 프로세스는 메모리안에 상주하여 CPU의 작업을 수행하는 하나의 단위입니다.
   스레드는 자원을 공유할 수 없지만, 프로세스는 자원의 공유가 가능합니다. 또한 프로세스는 IPC를 통해 내용 전달이 가능합니다?

   [모범답안]

   Process는 각 Process 별로 독립된 memory 공간을 갖는다. (thread 와 가장 큰 차이점) 그렇기 때문에 어떤 Process 가 다른 Process 의 memory 에 직접 access 할 수 없다. 다양한 IPC (inter-process communication) 를 통해 process 간 통신이 가능하다.

   Thread 는 stack영역을 뺀 memory를 공유한다. 하나의 thread 가 memory 를 쓰고, 다른 thread 가 memory 를 읽는 것이 가능하다. 따라서 thread 간의 통신은 상대적으로 쉽고 간단하게 실현 될 수 있다. 대신 memory 를 공유하기 때문에 synchronization, deadlock 등의 문제가 발생 할 수 있어, 설계 및 제어를 잘 해야 한다. 또한 multi-thread programming 의 경우, 미묘한 시간차이 등에 의한 문제가 발생하기에 상대적으로 debugging 이 어렵다.

9. **이 슈도코드에서 발생할 수 있는 문제점은?** <= 좀비프로세스를 만들기 위한 코드

![](https://ws3.sinaimg.cn/large/006tKfTcgy1fmxdoyf12vj30f00aowfd.jpg)



**좀비프로세스를 만들려면 if( pid == 0) 이고 else는 wait()가 들어가있어야 좀비 프로세스를 만들수 있다.**

pid가 양수일때 아래의 동작이 실행되므로 fork를 통해 자식 프로세스를 생성할 지라도 자식프로세스는 동작하지 않는다. 

부모프로세스는 while안에서 동작한다. 그 뿐 만아니라, exec를 통해 초기화를 해야 사용 가능하다.

8. **프로세서의 상태 변경은 언제 일어나는가?**
   ​

   1) 인터럽트  
   현재 명령을 실행 중에 있을 때, 외부적인 명령이 들어옴.

   예시) Time-out : (Runnig상태 -> Ready상태)

   2) Trap  
   예외 조건이거나 심각한 오류상황에서 발생

   예시) 0으로 나누는 것과 같은 과정이거나, 이상한 Memory를 참조 할 때 발생하게 된다.

   3) System call  
   운영체제 함수를 부를 때 발생하게 된다. (운영체제 API를 씀) 

   예시) I/O Request -> (Running상태->Block상태)

   ​

9. 다음 그림은 1개의 프로세스에 대한 메모리 영역이다. 각 설명에 대해 빈칸에 들어갈 값으로 알맞은 것은?

   ![](https://ws2.sinaimg.cn/large/006tKfTcgy1fmxdvjjs4aj30xu0g0gno.jpg)

   **위에서부터,  스택, 힙, BSS(Block started of symbol),  데이터, 코드**

10. **다음은 Linux 환경에서 C 코드의 일부이다. 1번과 2번의 출력 결과는 어떻게 다를 것인가? ( 1번 코드와 2번 코드는 else 부분만 다르고 나머지는 다 똑같음.)**

![](https://ws3.sinaimg.cn/large/006tKfTcgy1fmxdyzb1hmj30uk0fwdk2.jpg)

wait의 여부를 통해 자식프로세스가 먼저 죽은뒤 부모프로세스가 죽는다. 

**첫번째는 부모프로세스 2번째 프로세스.**
**복제 프로세스 실행 시작 후, 0,1,2,3,4 실행되고, wait의 영향을 받아 그 뒤에 프로세스 실행 종료가 나타남.**
**그러나 두번째는, 실행 시작 후, 0,1,2,3,4 출력되면서 그 사이에 프로세스 실행 종료 printf가 호출될 것이다.**

11. 다음은 스레드 관련 (C++)코드이다. 1번 코드와 2번 코드의 출력 결과는 어떻게 다를 것인가? 또한, 그 이유는 무엇일까? (1번 코드와 2번 코드는 main 함수 부분만 다르고 나머지는 다 똑같음) ( thrd(&MyThread)는 MyThread 함수를 실행시키는 새로운 스레드를 호출하는 메소드임)

    join()이라는 명령어는 wait()와 유사하다.

    ![](https://ws3.sinaimg.cn/large/006tKfTcgy1fmxe3xjkqnj310415cdr4.jpg)

    프로세스 PCB안에서 코드만 공유하고 나머지는 독립 그러나, Thread는 스택만을 제외하고 공유
    프로세스와 Thread의 차이점을 말하고 있는 것.

12. **다음 코드를 실행하면 프로세스가 총 몃 개 생성 될 것인가?**
    ![](https://ws4.sinaimg.cn/large/006tKfTcgy1fmxea8hqbmj30ce072dgl.jpg)



2^3 = 8 개가 생성됨. 부모0 => 자식1 =>  
​						자식2 =>  자식2의 i= 2 => i = 3 / i = 3  
​						자식3 =>  자식2의 i = 3  


13. **다음 2개의 코드 중 1번 코드는 Linux 환경의 C 코드이며, 2번 코드는 Windows 환경의 C++ 코드이다. 1번 코드와 2번 코드 각각의 출력 결과는 무엇인가?**

(1번 코드에서는 pid 값도 구해야 하며, 초기 프로세스의 **pid **값은**8888**로 가정한다.)

![](https://ws3.sinaimg.cn/large/006tKfTcgy1fmxegfir2ij30yc0p0tdu.jpg)



1)   8888, 8889, 0 / 

![](https://ws2.sinaimg.cn/large/006tKfTcgy1fmxeg99k88j30es0ian0h.jpg)



스레드에서 스택은 지역변수를 공유하지 못한다. 11 / 10

14. **컴퓨터 부팅과정을 순서대로 나열하세요.**  
    a. 하드디스크의 부트 섹터에 저장된 운영체제(커널)를 RAM에 적재  
    ​

    b. ROM에 저장된 부트로더 실행  
    ​

    c. 초기화 및 특정 응용프로그램 시작  
    b  a c

15. 다음은 Linux에서 실행할 어떤 C언어 코드 중 일부이다. 아래의 test1() 함수가 실행되는 과정에서 자식 프로세스가 생성된다. OS에서 할당한 부모 프로세스의 pid는30이고, 자식 프로세스의 pid는 31이라고 가정하자.

    ```c
    extern int global_var;

    void test1() {
    	pid_t pid1, pid2, pid3;
    	pid1 = getpid();
    	global_var = 0;
    	pid2 = fork();
    	if (pid2 > 0) {
    		global_var = 1;
    	}

    	pid3 = getpid();
    }

    ```

    ​

    자식 프로세스에서, test1() 함수가 리턴할 때, 아래 값들을 각각 숫자로 입력하시오. 숫자만 입력 가능!!

    1. pid1
    2. pid2
    3. pid3
    4. Global_var

    ​

16. **다중처리, 다중 프로그래밍, 다중 작업, 다중 스레드의 차이점을 설명하세요.**
    ​

17. **다중 프로그래밍 시스템(Multi-programming System)과 다중 처리 시스템(Multi-processing System)의 차이를 설명하시오.**

    ​

    **다중 프로그래밍 시스템(Multi-programming System)**

     메모리에 여러개의 프로그램을 상주시켜 하나의  CPU로 동시에 여러 프로그램을 실행하는 것처럼 처리하는 시스템
    하나의 작업이 CPU를 사용하다가 입출력 처리 등으로 CPU를 사용하지 앟는 동안, 다른 작업에 CPU를 할당하여 CPU의 효율을 극대화

    메모리 관리 기법이나 CPU 스케줄링 기법이 필요

    - 장점 : 동시에 여러 프로그램을 실행할 수 있어 처리 능력이 좋음
    - 단점 : 여러 프로그램을 관리하기 때문에 운영체제의 구조가 복잡

    ​

    **다중 처리 시스템(Multi-processing System)**  

    복수의 CPU를 사용하여 다중 작업을 처리하는 시스템  복수의 CPU가 메모리를 공유하여 동시에 작업을 처리하는 것이 가능  CPU에 장애가 발생해도 여분의 CPU를 통해 작업 진행

    - 장점 : 작업 처리 속도가 빠름, 시스템의 안정성이 높음- 
    - 단점 : CPU 추가로 인해 비용이 상승

    ​

18. **Thread 생성시 어떤 자원이 사용되는가? 이들 자원은 프로세스가 생성시 사용되는 자원과 어떻게 다른가?** 

19. **메모리 영역 중 사용자영역과 커널 영역은 어떻게 다른가?**
    사용자가 프로세스를 하나 만들어서 돌릴때만 사용자영역이고 나머지는 커널 영역에 해당한다.

20. 참고 <http://sharin.tistory.com/12>

    사용자 영역은 여러개 존재 그러나 커널 영역은 오직 하나만 존재한다.

    ​

21. **시스템 호출(System Call)이란 무엇인가? 어떠한 종류의 기능들이 있는가?** 

    ​

    시스템콜이란, 메모리안에 커널이라는 것이 있고 이는 운영체제의 일부를 메모리에 상주시킨 부분입니다.
    그리고 이 커널안에는 시스템 함수가 존재하는데, 사용자가 시스템 함수를 호출 할때 시스템 호출이라고 말할 수 있습니다.
    시스템 호출의 유형으로

    프로세스를 제어하거나,  
    파일을 조작하거나  
    장치를 관리하거나  
    정보를 유지하거나  
    통신을 할경우가 있습니다.

    ​

22. **사용자 스레드와 커널스레드를 구분하는 기준은 무엇인가?**

    생성의 주체에 따라 프로그래머가 생성하고 커널에서 스케쥴링하면 커널스레드.

    단일스레드만 지원하는 경우, 커널에 의존적이지 않은 형태로 스레드 라이브러리.

    ​

23. **사용자 스레드의 context switching overhead가 적은 이유?**

    Mode bit가 전환될 때 시스템에 부담을 줍니다.
    커널 스레드의 경우에는 모드 비트가 1로 변하고 사용자 스레드의 접근을 막습니다. 여기서 갑자기 유저모드로 변화될 경우 그러니까 Mode bit가 0으로 변환되는데, 이러한 변화가 빈번하게 일어나는 것은 시스템에 부담을 줍니다.

    ​

24. 운영체제는 어떻게 분류 할 수 있는가(분류 기준)?  
    ​
    **\- 동시작업을 지원하는지의 여부에 따라 단일 작업용 운영체제와 다중 작업용 운영체제로**

    **\- 다중 사용자의 동시 지원 여부에 따라 단일 사용자용 운영체제와 다중 사용자용 운영체제로** 

    **\- 작업을 처리하는 방식에 따라 일괄처리방식과 시분할 방식, 실시간 운영체제로 나뉜다.**
    ​

25.  **해당 소프트웨어를 다른 기종의 기계로 옮기는 데 소용 되는 노력이 어떤가를 나타내는 지표를 소프트웨어의 OOO이라고 한다. 이따 빈칸의 들어갈 말과 이것이 높은 최초의 운영체제는 무엇인가?**

    이식성, 유닉스

26. **라운드 로빈 기법에 대하여 간단히 설명하시오.**

    CPU를 한 번 할당 받아 사용할 수 있는 시간을 일정한 고정된 시간으로 제한하는 기법이다.

    그래서 긴 작업을 요하는 프로세스가 CPU를 할당 받더라도 정해진 시간이 지나면CPU를 내어놓고 CPU의 서비스를 기다리는 줄의 제일 뒤에 가서 기다려야 한다. 그러므로 라운드 로빈 스케줄링에서는 적어도 긴 작업을 수행하는 프로세스 때문에 짧은 작업을 가진 프로세스들이 무작정 오래 기다려야 하는 상황은 막을 수 있다.

27. **OOOO은 일종의 소프트웨어적인 인터럽트로서 사용자 프로그램이 이를 할 경우, 트랩이 발생해 CPU에 대한 제어권이 운영체제로 넘어가게 된다. 그러면 운영체제는 해당 OOOO을 처리하기 위한 루틴으로 가서 정의 된 명령을 수행하게 된다.**
    ​

    **시스템콜**

    ​

28. 다음 중 프로세스에 대한 것으로 옳지 않은 것은? **2**
    1) 프로세스는 각자 자신만의 독립적인 주소공간을 가지고 수행된다.  
    2) 프로세스가 다른 프로세스의 주소공간을 참조하는 것이 허용된다.  
    3) 원칙적으로 하나의 프로세스는 다른 프로세스의 수행에 영향을 미칠 수 없다.  
    4) 프로세스가 다른 프로세스와 정보를 주고받을 수 있는 방법은 없다.

    ​

29. 운영체제란 무엇인가?

    ​

30. 운영체제의 기능 또는 목적을 생각나는 대로 써보기
    ​
    자원관리 / 시스템 관리
    ​

    ​




33. 시스템 호출의 개념과 시스템 호출 방법을 설명하시오.



34. 프로세스 중단(서스펜드)와 재시작은 언제 발생하는가??


재시작되는 경우는 시스템에 장애가 발생하면 실행 중인 프로세스는 잠시 중단헀다가, 시스템이 기능을 회복할 때 다시 재시작할 수 있다.  
프로세스의 어느 부분이 의심스러울 때 사용자는 실행 중인 프로세스를 중단하여 확인한 후 재시작하거나 정지할 수 있다.


35. 바쁜 대기의 개념과 이를 피할 수 있는 방법을 간단히 설명.​

36. 임계 영역의 의미와 문제점



37. 임계 영역이 만족해야 하는 세 가지 조건은?