# 컴퓨터 구조와 프로그램 실행

하드웨어 및 동작에 대한 이해



![](https://ws4.sinaimg.cn/large/006tNc79gy1fmbjj90fmtj314y0uge3t.jpg)

![](https://ws4.sinaimg.cn/large/006tNc79gy1fmbjsq8gdvj31100uqqbp.jpg)

![](https://ws1.sinaimg.cn/large/006tNc79gy1fmbjxc5m8vj30zi0t24bb.jpg)



메모리라는 것은 CPU의 작업 공간.

CPU는 매 클럭 순간,

**Mode bit** -> 사용자 모드 ? 운영체제 모드? 임을 선택하게 해준다.

100만배 차이, CPU가 디스크에 비해 100만 느리다?



CPU는 항상 메모리와 일한다!  
CPU는 계속 메모리에 접근해서 IO에 대한 데이터 구조를 참고한다.  
**CPU는 IO controller에게 일을 시키고 계속 메모리에 접근하면서 인터럽트를 한다.**  
**인터럽트란 컨트롤러들이 CPU의 서비스가 필요할 때 이를 통보하는 방법을 말한다.**  
만약 무한 루프를 실행했을 때, CPU가 하나의 Memory만 계속 참조한다면, 이때 timer가 동작한다.  
timer가 한 메모리에 독점하지 않도록 해준다.  
운영체제가 CPU를 얻게 되면 어떻게 되겠는가?  
사용자는 직접 IO를 접근할 수 없다.



#### Mode Bit

사용자 프로그램의 잘못된 수행으로 다른 프로그램 및 운영체제에 피해가 가지 않도록 하기 위한 보호 장치 필요

- 하드웨어적으로 두 가지 모드의 operation지원

  - 1 사용자 모드 - 사용자 프로그램 수행
  - 0 모니터 모드 - OS 코드 수행
    - 보안을 해칠 수 있는 중요한 명령어는 모니터 모드에서만 수행 가능한 **특권명령**으로 규정
    - Interrupt나 Execption 발생시 하드웨어가 mode bit을 0으로 바뀜
    - 사용자 프로그램에서 CPU를 넘기기 전에 mode bit을 1로 셋팅
  - 모니터 모드(= 커널 모드, 시스템 모드)

  ![](https://ws4.sinaimg.cn/large/006tNc79gy1fmbv4k0b1jj30uu0n8gyv.jpg)

#### Timer

- 정해진 시간이 흐른 뒤 운영체제에서 제어권이 넘어가도록 인터럽트를 발생함
  - 타이머는 매 클럭 틱 때마다 1씩 감소
  - 타이머 값이 0이 되면 타이머 인터럽트 발생
  - CPU를 특정 프로그램이 독점하는 것으로부터 보호
- 타이머는 time sharing 을 구현하기 위해 널리 이용됨
- 타이머는 현재 시간을 계산하기 위해서도 사용
- Timer는 Interrupt line을 바라보고 있다. 체크하고 넘기고 체크하고 넘기고!

#### Device Controller

- I/O device controller
  - 해당 I/O 장치유형을 관리하는 일종의 작은 CPU
  - 제어 정보를 위해 control register, status register를 가짐
  - Local buffer를 가짐(일종의 data register)
- I/O는 실제 device와 local buffer 사이에서 일어남
- Device controller는 I/O가 끝났을 경우 interrupt로 CPU에 그 사실을 알림



**Device driver(장치 구동기)**

 : OS 코드 중 각 장치별 처리 루틴 - software

**Device controller(장치 제어기)**

 : 각 장치를 통제하는 일종의 작은 CPU - hardware



#### DMA Controller

직접 메모리 접근가능자. Memory controller의 경우 CPU와 DMA controller가 동시에 접근할 경우 중재해준다.  

CPU의 보조 역할을 담당? 그런 느낌인데.



#### 입출력(I/O)의 수행

- 모든 입출력 명령은 특권명령
- 사용자 프로그램은 어떻게 I/O를 하는가?
  - 시스템 콜(System call)
    - 사용자 프로그램은 운영체제에게 I/O 요청
    - 사용자 프로그램이 운영체제의 서비스를 받기 위해 커널 함수를 호출하는 것
  - trap을 사용하여 인터럽트 벡터가 가리키는 인터럽트 서비스 루틴으로 이동
  - 올바른 I/O 요청인지 확인 후 I/O 수행
  - I/O 완료 시 제어권을 시스템콜 다음 명령으로 옮김



#### 인터럽트(Interrupt)

- 인터럽트 당한 시점의 레지스터와 program counter를 save한 후 CPU의 제어를 인터럽트 처리 루틴에 넘긴다.
- Interrupt(넓은 의미)
  - 하드웨어 인터럽트를 의미한다. 하드웨어가 발생시킨 인터럽트
  - Trap(소프트웨어 인터럽트)
    - Exception - 프로그램이 오류를 범한 경우
    - System call - 프로그램이 커널 함수를 호출하는 경우
- 인터럽트 관련 용어
  - 인터럽트 벡터
    - 해당 인터럽트의 처리 루틴 주소를 가지고 있음
  - 인터럽트 처리 루틴
    - 해당 인터럽트를 처리하는 커널 함수.
- Interrupt line의 중요성!!!!!



모드빗이 0일때만 IO에 접근 가능하다.

프로그램카운터?

시스템 콜?

사용자 프로그램이 OS를 점프 할 때, 인터럽트 라인을 확인하고 넘어간다!

**메모리에 어디있는 메모리 레지스터를 가리키는 프로그램 카운터.**

**그것이 가리키는 것이 메모리.**

#### 동기식 입출력(Synchronous I/O)(시간적으로 맞추는 것)

- I/O 요청 후 입출력 작업이 완료된 후에야 제어가 사용자 프로그램에 넘어감
- 구현방법 1
  - I/O가 끝날 때까지 CPU를 낭비시킴
  - 매 시점 하나의 I/O만 일어날 수 있음
- 구현방법2
  - I/O가 완료될 때까지 해당 프로그램에게서 CPU를 빼앗음
  - I/O처리를 기다리는 줄에 그 프로그램을 줄 세움
  - 그 동안 입출력 작업을 수행하는 입출력장치는 봉쇄상태로 전환시킨다고 말한다. 봉쇄상태의 프로그램에게는 CPU를 할당하지 않고, CPU를 할당하면 곧바로 작업을 수행할 수 있는 프로그램에게만 CPU를 할당한다.
  - 그러나 이렇게되면 순서를 보장할 수 없어, 큐에 담아 요청한 순서대로 처리할 수 있도록 한다.
  - 다른 프로그램에게 CPU를 줌

#### 비동기식 입출력(asynchronous I/O)

- I/O가 시작된 후 입출력 작업이 끝나기를 기다리지 않고 제어가 사용자 프로그램에 즉시 넘어감
- 그 후 입출력 연산이 완료되는 것과 무관하게 처리 가능한 작업부터 처리한다. 


=> 두 경우 모두 I/O의 완료를 인터럽트로 알려줌.



#### DMA(Direct Memory Access)

원래는 메모리에 접근할수 있는 건 CPU밖에 없지만, 키보드를 예로 타자 칠때마다 CPU의 인터럽션이 발생하는 것이 효율적으로 동작하지 못하기 때문에, DMA Controller가 Memory에 직접접근할 수 있도록 한다.
I/O에 로컬 버퍼에 있는 데이터 바이트 단위가 아닌 block단위로 DMA에 의해 메모리에 올라가게 되는데, 해당 I/O 데이터 전송이 끝나면 DMA는 CPU에게 끝났다라는 인스터럽션을 보낸다.



#### 서로 다른 입출력 명령어

- I/O를 수행하는 special instruction에 의해
- Memory Mapped I/O에 의해

![](https://ws3.sinaimg.cn/large/006tNc79gy1fmcvr67l31j30ui0pcwon.jpg)



#### 저장장치 계층 구조

![](https://ws4.sinaimg.cn/large/006tNc79gy1fmcvw1f1tfj313g0u2duk.jpg)



연두색 부분은 휘발성
주황색은 비휘발성



CPU가 메모리에 접근하려면 바이트단위여야 한다.

그 자리에서 CPU가 바로 접근 가능

하드 디스크는 섹터 단위로 접근 가능한다는 의미는 Executable하지 않다고 한다.



빠른 매체로 정보를 읽어들여 활용하는 것을 캐슁이라고 한다.
Main Memory => Cache Memory 이동 할 때.



#### 프로그램의 실행

어떻게 프로그램이 시작되는가????

![](https://ws1.sinaimg.cn/large/006tNc79gy1fmcw25bo9ij30wq0p6k0l.jpg)



File System안에 실행파일A, B(일반적으로 Bin). 
실행시키게 되면 메모리안에서 프로세스로 올라가게 된다.  

그러나 정확하게는 중간에 한층을 더 거치게 되는데,  

![](https://ws1.sinaimg.cn/large/006tNc79gy1fmcw3wb8daj313a0u2h3p.jpg)

**가상메모리** 를 거치게 됩니다. 프로세스 B, 프로세스 A ,메모리 주소 공간을 담습니다.  
Stack / data / code 로 구성되어 있는 메모리 주소 공간에 담습니다.   
**가상메모리는 각 실행파일마다 가지고있는 고유의 메모리 주소 공간이라고 부른다.**



파일 시스템과 Swap Area는 다른 거다. Swap area는 전원이 나가면 의미가 없다.  
Why? 물리메모리에 있는 데이터가 없어지면서 Swap area  



![](https://ws1.sinaimg.cn/large/006tNc79gy1fmcwavy27yj312q0u4tpq.jpg)



운영 체제 커널도 어떻게 보면 하나의 프로그램이기 때문에 다음과 같은 구조를 가진다.

![](https://ws2.sinaimg.cn/large/006tNc79gy1fmcwbxibv4j31380tqdvk.jpg)



스택에 따로 프로세스 커널 스택을 담아두는 이유는 각각의 프로세스가 스택에 함수를 푸쉬하기 때문에.

![](https://ws3.sinaimg.cn/large/006tNc79gy1fmcwkq2xvnj312s0ss170.jpg)



![](https://ws1.sinaimg.cn/large/006tNc79gy1fmcwnm126lj310y0sc7du.jpg)



유저모드 커널모드가 변환되는 부분부분을 주의깊게 생각한다.  
이 둘을 죽을 때까지 변환하는,   
[http://egloos.zum.com/blrun/v/11114211#type=comment&page=3](http://egloos.zum.com/blrun/v/11114211#type=comment&page=3)