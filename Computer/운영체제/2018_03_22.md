

1.    **메모리에 있는 프로세스 주소 공간의 구성 요소와 역할**

      스택 : 소멸가능한 성질을가진 데이터들

      코드 : 기계어들

      데이터 : 초기화된 전역변수들

      BSS : 정적 데이터로 아직 초기화 되지 않은 변수들

      힙 : 동적 할당된 변수


2.    해당하는 용어
      ​
      1) 한 작업을 여러 프로세서가 나눠 처리하는 것 => 멀티프로세싱

      2)한 프로세서가 여러 작업을 나눠 처리하는 것 => 멀티프로그래밍

      3)한 프로세스의 병렬처리가 가능한 것 => 멀티 쓰레딩

[보기 멀티쓰레딩 / 멀티프로그래밍/ 멀티프로세싱]

 

3.    (Blocking IO) 디스크 입력은 커널 레벨 쓰레드/ 유저 레벨 쓰레드 중 어떤 것이 유리한가? 그 이유는?

커널레벨쓰레드
유저레벨쓰레드를 하나의 프로세스로 간주
IO요청하는 쓰레드가 포함되어 있는 다른 쓰레드가 정지되어 있기 떄문에

 또한 디스크 입력은 프로세서의 상태를 전환시켜야 한다. 때문에 유저레벨쓰레드에서는 그만큼의 비용이 들어가기 때문에 유리하지 않다.

4.    프로세스의 상태 변경은 언제 일어나는가?
      \- 인터럽트

      현재 명령을 실행 중에 있을 때, 외부적인 명령
      Running -> Ready

      \- Trap

      예외 조건이거나 심각한 오류상황에서 발생

      \- System call

      운영체제 함수를 호출할 때
      Running -> Block

      \- Swap

      Suspend로 상태로 머뭄.

5.    사용자스레드의 context switching overhead가 적은 이유?

      사용자 쓰레드 방식이 커널 쓰레드보다 오버헤드가 적은(없지는 않음) 이유는
      쓰레드간을 전환할 때마다 커널 스케줄러를 호출할 필요가 없기 때문입니다.
      커널 스케줄러로 진입하려면 프로세서 모드를 사용자 모드에서 커널 모드로
      전환해야 하는데, 이때 사용자쪽 하드웨어 레지스터를 전부 저장시키고, 커널
      레지스터를 복구하고, 기타 등등...의 수많은 작업이 밑에서 일어납니다.
      따라서 사용자 모드와 커널 모드를 많이 왔다갔다 할수록 성능은 급격하게
      떨어지는 것이죠. 사용자 쓰레드는 쓰레드 스케줄러가 사용자 모드에만 있기
      때문에 그런 오버헤드는 발생하지 않습니다.

 

6.    다음은 Linux에서 실행할어떤 C언어 코드 중 일부이다. 아래의 test1() 함수가 실행되는 과정에서 자식 프로세스가 생성된다. OS에서 할당한 부모 프로세스의 pid는30이고, 자식 프로세스의 pid는 31이라고 가정하자

      ```c
      extern intglobal_var;

       

      voidtest1() {

                    pid_t pid1, pid2, pid3;

                    pid1 = getpid();

                    global_var = 0;

                    pid2 = fork();

                    if(pid2 > 0) {

                            global_var = 1;
                    }
                    pid3 = getpid();
      }

      자식 프로세스에서, test1() 함수가 리턴할 때, 아래 값들을 각각 숫자로 입력하시오.

      1)    Pid1 30 // 부모 프로세스

      2)    Pid2 0 // 자식 프로세스

      3)    Pid3 31

      4)    Global var 0

       
      ```

 

11.  페이지 크기가 4KB이고 메모리 크기가 256KB인 메모리페이징 시스템이 있을 때 (32비트)

1)     페이지 프레임 수는? 64개

2)     이 메모리 주소를 해결하는 데 필요한 비트 수는? 18 => 2^10 + 2^8

3)     페이지 번호에 사용하는 비트와 페이지 오프셋에 사용하는 비트는? 6 12

 

12. HRN방법으로 스케줄링 할 때 입력된 작업이 다음과 같다면 가장 먼저 실행될 작업은?

( 다시 보기 )

| 작업 | 대기시간 | 서비스 시간 |
| ---- | -------- | ----------- |
| A    | 8        | 2           |
| B    | 10       | 6           |
| C    | 15       | 7           |
| D    | 20       | 2           |

13.  페이지 부재를 처리하는 과정을 순서대로 나타내라.

ㄱ)   가용 페이지가 주 기억 장치에 적재되고 상황에 따라 다른 페이지가 해제된다.

ㄴ)   프로세스가 페이지를 참조한다. 페이지 부재를 발생시킨 프로세스는 중단된다.

ㄷ)   기억 장치 관리자의 페이지 테이블은 갱신된다.

ㄹ)   기억 장치 관리자는 보조 기억 장치에서 가용 페이지를 찾는다.

ㅁ)   페이지 보호 비트를 확인한다.

ㅂ)   프로세스는 중단 되었던 시점에서 다시 시작된다.


ㄴ ㅁ ㄹ ㄱ ㄷ ㅂ


14. 다음 작업들을 Round-Robin 스케줄링을 사용하여 실행 할 경우, 작업의 ]()[평균 반환시간(Turnaround time)과 평균 대기시간(Waiting time)을 구하세요(TimeQuantum = 4ms)

| process  | A    | B    | C    | D    |
| -------- | ---- | ---- | ---- | ---- |
| 도착시간 | 0    | 1    | 2    | 3    |
| 실행시간 | 10   | 2    | 9    | 5    |

반환시간 / 대기시간

​            http://myplan.tistory.com/entry/RR스케줄링

15. 4096(2^12) 워드를 가진 페이지들이8개 모여 구성된 논리주소 공간이 있다. 이들이 32개의 페이지 프레임(실제 기억 공간) d로 사상 된다고 하자.

    1) 논리주소에 몇 개의 비트(bit)가 있는가? 또,
    그 산출 근거를 밝히세요.
    3비트 / 12개가 오프셋

    2) 물리주소에 몇 개의 비트(bit)가 있는가? 또,
    그 산출 근거를 밝히세요.
    5개 / 12개가 오프셋

16.  페이지 기억 장치 할당 기법에서, 한페이지의 크기가 512Byte이고 페이지 번호는 0번부터 시작한다면, 논리적인 주소1224번지는 어디로 변환되는가? 3

     1.페이지1, 변위200

     2.페이지200, 변위 1

     3.페이지2, 변위200  

     4.페이지200, 변위 2

      

17.  내부 단편화, 외부 단편화 중 어떤 것이 메모리 낭비가 더 큰가? 그리고 단편화를 해결하기 위한 방법은?

     외부 단편화가 메모리 낭비가 크다. 왜냐하면 내부 단편화의 경우 프로세스를 한 페이지내에 쓰고 남은 단편화인 반면, 외부단편화의 경우 그 단위 자체를 쓸 수 없기 때문이다.
     단편화를 해결하기 위한 방법은 다단계의 페이지 레벨을 만들어 해결할 수 있다. 또는
     압축을 통해서 쓰이지 않는 공간만 따로 빼는 방법, 그리고 null로
     표현해 사용하지 않은 공간을 분리해 준다.

 

18. 32비트 시스템에서 페이지 크기가 4KB일 때, 4GB 메모리에접근하기 위해 필요한 페이지 테이블의 크기는? (페이지 엔트리의 크기는 4Byte 이다.

    1M 개
    4M 2^22의 Page Table 필요
    ![](https://ws2.sinaimg.cn/large/006tKfTcgy1fn3kg7j9x5j311y0mmaqr.jpg)

19.  다음과 같이 기억 장치가 분할 되어 있을 때, 최적 적합(Best-Fit) 알고리즘을 사용하여 234, 456, 123, 456 순으로 프로세스를 배치 할 경우 생기는

     내부단편화 크기와 외부단편화의 크기는? 
     234의 경우 300에 들어가, 66의 내부 단편화가 발생한다.
     456의 경우 500에 들어가, 44의 내부
     단편화가 발생한다.
     123의 경우 200에 들어가 77의 내부
     단편화가 발생한다.
     456의 경우 600에 들어가 144의 내부단편화가
     그리고 100의 외부 단편화 발생.

      

 

20.  다음의 페이지 테이블을 참고하여, 페이지 크기가 4096Byte일 때, 가상주소에 해당하는 가상 페이지 번호(VPN) 및 물리 페이지 번호(PPN)와 물리주소 값을 각각 계산하시오.

1-1)        
16080 (11 111011010000): 
12984 <= 테이블의 위에서 오프셋까지의 값을 구한다.
3번째 페이지 / 2번프레임(0번쨰),
offset 3792

1-2)        
1840 (..011100110000): 
0번째 페이지 / 4번프레임(3번째),
offset 1840

1-3)        
7650 (1 110111100010): 
1번째 페이지 / 0번프레임(2번째),
offset 3554

---

// 중요.
우선 getpid()함수와 fork()함수에 대해 설명하자면 

getpid()함수는 현재 프로세스의 id(pid)값을 가져오는 함수입니다. 

fork()함수는 프로세스가 자식프로세스를 생성하는 함수입니다. 

fork()함수 이후부터는 부모 프로세스와 자식 프로세스가 함께 수행됩니다. fork()함수의 특징은 부모 프로세스가 자식프로세스를 생성하면 자식 프로세스의 pid는 부모에게 리턴 되고 자식에게는 0이 리턴 된다는 특징이 있습니다.

 

따라서 pid2는 부모 프로세스 입장에서는 자식프로세스의pid인 31이 되고 자식프로세스 입장에서는 0이 됩니다. 

 

코드로 돌아가보면 

```c
extern intglobal_var;

void test1() {
       pid_tpid1, pid2, pid3;
       pid1= getpid(); // pid1은 아직 부모 프로세스의 pid가 인가됩니다.(pid1= 30)
       global_var= 0;
       pid2= fork(); //pid2는 부모 프로세스라면31, 자식프로세스라면 0이 인가될 것입니다.
       if (pid2 > 0) {       
// 해당문제는 자식 프로세스에서의 test1()함수의 리턴값을 묻는 문제로 pid2는 0이라고 볼 수 있습니다.
              global_var= 1;       // 따라서 global변수인 global_var는 0이 됩니다.
       }
       pid3= getpid();      //자식 프로세스의pid3값은 본인의 pid값인 31이 됩니다.       
}

 

답
pid1 : 30
pid2 : 0
pid3 : 31
global_var : 0
```