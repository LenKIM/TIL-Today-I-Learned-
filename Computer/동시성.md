## 멀티스레드 개념 잡기

멀티 스레드 프래그래밍을 활용할 일이 많지 않지만, 연습을 통해 직접 그 경험을 하고자한다.



멀티스레드 환경을 알기 위해서는 일단 스레드 개념부터 이해하자.

스레드는 애플리케이션의 실행에 있어서 가장 기본적인 단위이다. 각 스레드마다 별도의 스택이 있으며, 각 스레드는 같은 애플리케이션에 있는 다른 스레드와 독립적으로 돌아간다. 기본적으로 스레드끼리는 파일 핸들이나 메모리 같은 자원을 공유한다. 따라서 공유 자원에 대한 접근을 제대로 이해하지 못하면 못제가 발생한다. 예를 들어,  두 스레드에서 같은 메모리 블록을 동시에 쓰기 작업을 할 떄 흔히 데이터 손상같은 부작용이 생길 수 있다.

스레드는 여러 방식으로 구현 가능한다. 대부분 시스템에서 스레드는 운영체제에서 생성하고 관리한다. 이런 스레드는 네이티브 스레드 또는 커널 수준 스레드라고 부른다. 스레드를 가상 머신 같이 운영체제 위의 소프트웨어 계층에서 구현할 수도 있는데, 이를 녹색 스레드라고부른다. 이 두 유형의 스레드는 모두 똑같은 식으로 돌아간다. 스레드 작업 중에 녹색 스레드에서 더 빠른 것도 있지만, 녹색 스레드는 보통 멀티코어를 활용할 수는 없으며 동기 입출력을 구현하기가 어렵다.

동시에 돌릴 수 있는 스레드 수는 컴퓨터에 있는 코어 개수로 제한되기 때문에 운영체제에서는 각 스레드에 조금씩 시간을 나눠주면서 여러 스레드를 돌아가면서 실행시킨다. 운영체제에서 아무 때나 스레드 실행을 멈추고 다른 스레드를 실행시킬 수 있기 때문에 이런 방법을 선점형 스레딩(Preemptive threading)이라고 부른다. (이와 반대로 협력형 모델 에서는 어떤 스레드가 멈추고 다른 스레드가 돌아가려면 원래 실행중인 스레드에서 명시적으로 어떤 행동을 취해야만 한다.)



### 시스템 스레드와 사용자 스레드

시스템 스레드는 시스템에서 생성하고 관리한다. 어플의 첫번째 스레드는 시스템 스레드이며, 보통 그 첫번째 스레드가 종료될 때 어플이 끝남.  
사용자 스레드는 메인 스레드에서 할 수 없는, 혹은 하면 안되는 작업을 해야 할 때 어플에서 명시적으로 생성하는 스레드이다.  


### 모니터와 세마포어

스레드와 공유자원 사이의 상호작용을 제어할 때는 스레드 동기화 메커니즘을 써야 한다. **스레드 동기화는 모니터와 세마포어로 구성된다.** 어느 쪽을 쓰는지는 시스템이나 언어에서 어느 쪽을 지원하는지에 따라 달라진다.

상호 배제 자물쇠로 보호되는 루틴의 집합을 모니터라고 부른다. 스레드는 자물쇠를 획득하기 전까지는 모니터에 속하는 루틴을 하나도 실행할 수 없다. 즉, 한 모니터 내에서는 한 스레드씩 실행된다. 다른 스레드는 전부 지금 실행중인 스레드에서 그 자물쇠를 놓아줄 때까지 기다려야만 한다. 모니터에 속하는 어떤 스레드가 다른 어떤 이벤트가 발생할 때까지 기다리기 위해 스스로 멈추면 다른 스레드가 모니터로 진입할 수 있다. 그렇게 대기 중이던 스레드에 이벤트가 발생했다는 연락을 받으면 그 스레드는 다시 깨어나고 최대한 빨리 자물쇠를 재획득.

세마포어는 더 간단하다. 공유 자원을 보호하기 위한 자물쇠만 있을 뿐이다. 스레드에서 공유자원을  사용하려면 자물쇠를 획득해야 한다. 자물쇠를 쥐고있는 스레드에서 놓아주기 전까지는 그 자원을 획득하려는 다른 스레드는 막히게 되고, 좌물쇠를 놓아주는 순간 그 자물쇠를 획득하려고 대기하던 스레드가 그 자물쇠를 획득하게 된다. 이것이 세마포어라고도 부르며 동시에 뮤텍스라고도 부른다.

**모니터는 자물쇠로 보호되는 루틴의 집합을 말하면 세마포어는 오직 자물쇠만 있을 뿐이다.**

스레드 동기화를 위해서는 대가를 치러야만 한다. 공유자원에 접근하기 위해 자물쇠를 획득하고 해제하는 데 시간이 걸리기 떄문이다. 이런 이유로 라이브러리에서 스레드용 과 비스레드용 클래스를 별도로 제공하기도 하는데, 자바의 StringBuffer와 StringBuilder 가 대표적인 예

### 데드락

두 스레드가 서로 상대방이 쥐고있는 자물쇠가 풀리기만을 기다리면서 서로 가로막고 있는 상황이 벌어질 수 있다. 이를 데드락이라고 부른다. 데드락이란 두 개의 서로 다른 스레드에서 서로 상대방이 필요로 하는 자원에 대한 락을 가지고 있을 경우에 일어난다. 이런 상황에서는 두 스레드 모두 더 이상 실행이 될 수 없기 때문에 꼼짝할 수 없는 상태가 되기 때문에 데드락이라는 이름이 붙었다. 보통 한 스레드를 강제로 종료시키는 방법 외에는 딱히 데드락을 풀 수 있는 방법이 없는데, 별로 좋지 않은 방법이다. 가장 좋은 해결책은 데드락을 피하는 것이다. 데드락이 충족되는 4가지 조건은

1. 무한 대기
2. 상호배제
3. Hold and wait
4. 비선점



## 동시성 문제

```
'바쁜 대기(Busy waiting)'란 용어를 설명해 보고 어떻게 하면 바쁜 대기를 피할 수 있는지 말하라
```

작업을 완료하기 위해 다른 스레드를 파생시켜야만 하는 스레드가 있다고 해 보자. 첫 번째 스레드에서는 두 번째 스레드가 작업을 마칠 때까지 기다려야 하고, 두 번째 스레드는 자기가 할 일을 마치고 나면 바로 종료된다고 하자. 가장 간단한 접근법은 첫 번째 스레드에서 두 번째 스레드가 죽을 때까지 기다리도록 하는 방법이다.

```java
Thread task = new TheTask();
task.start();
while(task.isAlive()){
    //아무 일도 하지 않음
}
```

이렇게 대기 중인 스레드가 여전히 활성 상태긴 하지만 실제로는 아무 일도 하지 않는 것을 바쁜 대기라고 부른다. 스레드에서 두 번째 스레드가 끝날 때까지 대기하는 것 외에는 아무 일도 하지 않음에도 불구하고 프로세서에서는 여전히 이 스레드를 실행시키기 때문에 "바쁜" 대기라고 부르는 것이다. 바쁜 대기를 사용하게 되면 두 번째 스레드에서 진짜로 일을 처리하는 데 쓸 수 있는 소중한 프로세서 사이클을 뺏어가게 된다.

다른 스레드에서 작업이 끝났음을 알려줄 때까지 대기하는 스레드를 휴지(sleep)상태로 전환해주면 된다. 자바에서는 공유하는 객체만 있으면 작업이 끝났음을 알려줄 수 있다.

```java
	Object theLock = new Object();
        synchronized (theLock) {
            Thread task = new Thread((Runnable) theLock);
            task.start();
            try {
                {
                    theLock().wait();
                }
            } catch (InterruptedException e) {
                
            }
        }
        
        class TheTask extends Thread {
            private Object theLock;

            public TheTask(Object theLock) {
                this.theLock = theLock;
            }

            @Override
            public void run() {
                synchronized (theLock){
                    // ... 작업차리
                    theLock.notify();
                }
                super.run();
            }
        }	
```



바쁜 대기는 모니터나 세마포어를 써서 피할 수 있으며, 어느 쪽을 사용하는지는 프로그래머가 처한 상황에 따라 달라질 수 있다.

스핀락? 이 교착상태를 뜻하기도 함.

### 생산자/소비자

```java
크기가 고정된 버퍼와 그 버퍼에 접근하기 위한 인덱스를 공유하는 생산자(Producer)스레드와 소비자 (Comsumer)스레드를 작성하라. 생산자는 버퍼에 집어넣고 소비자는 숫자를 제거해야 한다. 숫자가 추가되거나 제거되는 순서는 중요하지 않다.
```



우선 동시성 제어를 전혀 쓰지않고 문제에 답을 한 다음 어떤 문제가 있는 지 언급한다. 동시성이 문제가 되지 않는 경우에는 알고리즘이 별로 어렵지 않다. 데이터 버퍼는 다음과 같다.

```Java
import java.util.Random;

public class IntBuffer {

    private int index;
    private int[] buffer = new int[8];
    public void add(int num){
        while (true){
            if(index < buffer.length){
                buffer[index++] = num;
                return;
            }
        }
    }

    public int remove(){
        while (true){
            if(index > 0){
                return buffer[--index];
            }
        }
    }

    public static void main(String[] args) {
        IntBuffer b = new IntBuffer();
        Producer p = new Producer(b);
        Consumer c = new Consumer(b);
        p.start();
        c.start();
    }
}

class Producer extends Thread {
    private IntBuffer buffer;

    public Producer(IntBuffer buffer) {
        this.buffer = buffer;
    }

    @Override
    public void run() {
        Random r = new Random();
        while (true){
            int num = r.nextInt();
            buffer.add(num);
            System.out.println("Produced " + num);
        }
    }
}
class Consumer extends Thread {
    private IntBuffer buffer;

    public Consumer(IntBuffer buffer) {
        this.buffer = buffer;
    }

    public void run(){
        while (true){
            int num = buffer.remove();
            System.out.println("Consumed " + num);
        }
    }
}
```



이런 접근법에는 두 가지 문제가 도사리고 있다. 첫 번째는 바쁜 대기를 사용하기 때문에 CPU 시간의 낭비가 심하다는 점이고, 두 번째는 공유 자원인 버스에 대한 접근 제어가 전혀 안된다는 점이. 인덱스를 갱신하는 도중에 스레드가 전환되면 다음 스레드에서 버퍼의 엉뚱한 원소에 대해 읽기 또는 쓰기 작업을 할 수 있다.

얼핏보면 add와 remove메소드를 동기화 메소드로 만들면 문제가 해결될 것 같은 느낌이 든다.

```java
 public synchronized void add(int num){
        while (true){
            if(index < buffer.length){
                buffer[index++] = num;
                return;
            }
        }
    }

    public synchronized int remove(){
        while (true){
            if(index > 0){
                return buffer[--index];
            }
        }
    }
```

오히려 add 또는 remove를 먼저 호출하는 스레드 때문에  다른스레드가 다른 메소드를 실행시키지 못하는 문제만 생긴다. 즉, 아무일도 일어나지 않는다. 

두 스레드 중 하나는 바쁜 대기 상태에서 마냥 기다리기만 하고, 나머지 스레드는 락을 얻지 못하기 때문에 영원히 기다리기만 해야 한다. 버퍼가 꽉 찼을 때 생산자가 빈 공간이 생길 때까지 기다릴 수 있도록 하고, 버퍼가 완전히 비었을 때는 새로운 값이 들어올 때까지 소비자가 기다릴 수 있도록 하려면 메소드 안에 있는 코드를 바꿔야만 한다.



```java
import java.util.Random;

public class IntBuffer {

    private int index;
    private int[] buffer = new int[8];

    public synchronized void add(int num) {
        while (index == buffer.length - 1) {
            try {
                wait();

            } catch (InterruptedException e) {

            }
        }
//            if(index < buffer.length){
        buffer[index++] = num;
        notifyAll();
    }

//    }

    public synchronized int remove() {
        while (index == 0) {
            try {
                wait();
            } catch (InterruptedException e) {

            }
        }
//            if (index > 0) {
        int ret = buffer[--index];
        notifyAll();
        return ret;
    }


    public static void main(String[] args) {
        IntBuffer b = new IntBuffer();
        Producer p = new Producer(b);
        Consumer c = new Consumer(b);
        p.start();
        c.start();
    }
}

class Producer extends Thread {
    private IntBuffer buffer;

    public Producer(IntBuffer buffer) {
        this.buffer = buffer;
    }

    @Override
    public void run() {
        Random r = new Random();
        while (true) {
            int num = r.nextInt();
            buffer.add(num);
            System.out.println("Produced " + num);
        }
    }
}

class Consumer extends Thread {
    private IntBuffer buffer;

    public Consumer(IntBuffer buffer) {
        this.buffer = buffer;
    }

    public void run() {
        while (true) {
            int num = buffer.remove();
            System.out.println("Consumed " + num);
        }
    }
}
```

이렇게 하면 여러 생산자와 소비자가 같은 버퍼를 동시에 사용할 수 있기 떄문에 두 스레드만 사용할 수 있는 풀이에 비해 더 범용으로 쓸수 있는 답이 된다.



### 철학자들의 저녘 식사

```
다섯 명의 소심한 철학자들이 원탁에 앉아 있다. 각 철학자 앞에는 음식이 담긴 접시가 있다. 각 철학자들 사이에 포크(또는 젓가락)가 놓여 있는데, 하나는 철학자의 왼쪽에, 다른 하나는 오른쪽에 있다. 양손에 포크를 들기 전에는 먹을 수가 없다. 포크는 한 번에 하나씩 들게 되어 있다. 포크가 없으면 포크를 쓸 수 있게 될 때까지 기다려야 한다. 포크를 양손에 하나씩 쥐고 있으면 음식을 조금 집어먹고는 두 포크를 모두 테이블에 내려놓는다. 오랫동안 두 포크를 모두 잡지 못하면 그 철학자는 쫄쫄 굻어야만 한다. 어떤 철학자도 쫄쫄 굻지 않을 수 있도록 해주는 알고리즘이 존재하는가?
```

공유자원이 여러 개 있는 경우에 실제로 일어날 수 있는 동시성 문제를 정확하게 반영하고 있다. 이 문제에서 가장 중요한 점은 지원자가 데드락의 개념을 제대로 이해하고 있는지, 데드락을 피하는 방법을 알고 있는지를 알아보는 것이다.

우선 가장 간단한 방법부터 해보자.  
왼쪽 포크를 쓸 수 있을 때까지 기다렸다가 포크를 집어들고 오른쪽 포크를 쓸 수 있을 때까지 기다렸다가 오른쪽 포크까지 집어들고 나면 음식을 먹고 포크를 둘 다 내려놓는 식이다. 각 철학자 별로 스레드를 하나씩 쓰면 다음과 같은 코드로 구현가능



```java
public class DiningPhilosophers {

    //'각 포크'는 그냥 Object 객체로 정의하고 포크에 대해 동기화시킨다.
    private Object[] forks;
    private Philosopher[] philosophers;
    //포크와 철학자들을 준비한다


    public DiningPhilosophers(int num) {
        forks = new Object[num];
        philosophers = new Philosopher[num];
        for (int i = 0; i < num; i++) {
            forks[i] = new Object();
            philosophers[i] = new Philosopher(i, i, (i+1) % num);
        }
    }
    //먹기 시작
    public void startEating() throws  InterruptedException {
        for (int i = 0; i < philosophers.length; ++i) {
            philosophers[i].start();
        }

        //첫 번째 철학자가 먹는 것을 중단할 때까지 주 스레드를 중단시킨다.
        //하지만 첫 번째 철학자가 먹는 것을 중단하는 일이 일어나지 않으므로 시뮬레이션이 무한정 돌아간다.
        philosophers[0].join();
    }

    //각 철학자는 서로 다른 스레드에서 돌아감
    private class Philosopher extends Thread {
        private int id;
        private int fork1;
        private int fork2;

        public Philosopher(int id, int fork1, int fork2) {
            this.id = id;
            this.fork1 = fork1;
            this.fork2 = fork2;
        }

        public void run() {
            status("Ready to eat using forks " + fork1 + " and" + fork2);
            while (true){
                status("Picking up fork " + fork1);
                synchronized (forks[fork1]){
                    status("Picking up fork " + fork2);
                    synchronized (forks[fork2]){
                        status("Eating");
                    }
                }
            }
        }
        private void status( String msg) {
            System.out.println("Philosopher " + id + ": " + msg);
        }
    }
    //시물레이션 시작
    public static void main(String[] args) {
        try{
            DiningPhilosophers d= new DiningPhilosophers(5);
            d.startEating();
        } catch (InterruptedException e){

        }
    }
}

```

이 코드를 실행시키면 어떻게 될까? 스케줄러에서 각 스레드를 정확하게 언제 돌릴지 모르기 때문에 완전히 정해진 순서대로 돌아가는 건 아니다. (이게 바로 멀티스레드 코드를 디버깅하기가 어려운 이유 중 하나) 하지만 모든 철학자가 일단 왼쪽 포크를 집어들려고 하는데다가, 한 번 집어들면 오른쪽 포크를 들고 먹을 때까지는 그걸 내려놓지 않을 것임은 분명하다. 왼쪽 포크를 들고 있는 철학자 오른쪽에 있는 철학자가 왼손으로 그 포크를 집게 될지 경정해야 하는 경합 조건(Race condition)이 만들어진다. 후자의 경우에는 왼손에 포크를 들고 있는 철학자 두 명이 나란히 앉아있게 되고, 그 둘 중 왼쪽에 있는 철학자는 오른쪽에 있는 철학자가 오른손에 포크를 들고 뭔가를 집어먹은 다음 포크를 내려놓을 떄까지 기다려야만 한다. 이러다 보면 수많은 철학자들이 왼손에 포크를 들고 배고파하며 기다리기만 하는 상황이 벌어지고 말 것이다.

언젠가는 철학자 네 명이 왼손에 포크를 들고 있고, 식탁 위에는 포크가 하나만 올려져 있는 상황이 생긴다. ( 사실 금방 이 상황으로 간다) 이 마지막 포크를 누군가가 오른손에 집어들고, 음식을 먹고, 포크 두 개를 내려 놓으면 그래도 살 만한다. 하지만 누군가가 왼손으로 그 포크를 집었다면, 모든 철학자가 자기 오른쪽에 포크가 내려놓일 때까지 기다리게 되는데, 포크가 1인당 하나뿐이므로 그런 일은 일어나지 않는다. 결국 이 어플은 데드락에 빠지고, 모든 철학자들이 굶어 죽고 말 것.



이 데드락은 어떻게 해결?  

한 가지 해결책으로 기다리는 부분에 시간 초과 기능을 추가하는 방법을 생각할 수 있다. 첫 번째 포크를 집어든 후 정해진 시간안에 먹지 못하면 그 포크를 내려놓고 다시 시도하는 것이다. 하지만 이런다고 문제가 해결되는 것은 아니다. 어떤 사람은 먹을 수 있겠지만 데드락이 전혀 발생하지 않는 것은 아니다. 더 큰 문제는, 어떤 철학자가 식사를 할 수 있을지 정확하게 알 수가 없다는 점이다. 시간 초과와 스켸줄러 작동 방식이 절묘하게 맞물리면 어떤 철학자는 양쪽 포크를 다 집어들 수 없기 때문에 쫄쫄 굶을 수도 있다. 이런 것을 라이브락이라고 부른다.

또는 애초에 데드락이 발생하지 않도록, 모든 철학자들이 왼쪽 포크를 먼저 집어들게 하는 대신 철학자 중 한 명은 오른쪽 포크를 먼저 집어들도록 하면 어떻까? 그러면 그 철학자는 (오른쪽 포크를 먼저 들 테니)왼손에만 포크를 집어드는 일은 없을 것이고, 모든 철학자들이 왼손에 포크를 집어드는 순서를 기준으로 생각해볼 수도 있다. 락(여기서는 포크)을 획득하는 순서 떄문에 데드락이 발생하곤한다.

 모든 철학자와 포크에 식탁을 따라 반시계방향으로 번호를 붙인 다음, 왼쪽 포크를 먼저 집어드는 방식을 따라 모든 철학자가 우선 숫자가 더 작은 포크를 집어든 다음 숫자가 더 높은 포크를 집어들도록 해 보자. 이러면 마지막 철학자를 제외한 다른 철학자는 모두 왼쪽 포크를 먼저 들지만 마지막 철학자는 왼쪽에 n-1번 포크가, 오른쪽에 0번 포크가 있기 때문에 오른쪽 포크를 먼저 들어야 한다. 이렇게 하면 모든 철학자들이 번호가 낮은 포크를 먼저 든다는 똑같은 규칙을 따르도록 만들 수 있다.



```java
public DiningPhilosophers(int num) {
        forks = new Object[num];
        philosophers = new Philosopher[num];
        for (int i = 0; i < num; i++) {
            forks[i] = new Object();
            int fork1 = i;
            int fork2 = (i+1) % num;
            if( i== 0){
                philosophers[i] = new Philosopher(i , fork2, fork1);
            } else {
                philosophers[i] = new Philosopher(i , fork1, fork2);
            }
//            philosophers[i] = new Philosopher(i, i, (i+1) % num);
        }
    }		
```



그러나 이 문제는 자리 위치에 따라 공평하게 먹을 수 없다.

어떻게 하면 골고룸 거을 수 있을까? 데드락을 피하려면 포크를 집는 순서는 그대로 두는 게 낫다. 모든 포크 순서를 다 맞춰야 할까? 한 철학자가 동시에 들 수 있는 포크는 두 개뿐이므로 각 철학자가 최대 두개의 포크를 집어드는 순서에 대한 규칙만 있으면 된다.  각 철학자가 홀수번 포크를 짝수번 포크보다 먼저 ㅈ비어야 한다는 규칙만 있어도 된다.  (철학자 수가 홀수라면 N번째 철학자는 0과 N-1, 이렇게 두 짝수번 포크 앉는다. 따라서 이 철학자는 아무 포크나 들어도 된다.)

```java
public DiningPhilosophers(int num) {
        forks = new Object[num];
        philosophers = new Philosopher[num];
        for (int i = 0; i < num; i++) {
            forks[i] = new Object();
            int fork1 = i;
            int fork2 = (i+1) % num;
            if( (i % 2) == 0){
                philosophers[i] = new Philosopher(i , fork2, fork1);
            } else {
                philosophers[i] = new Philosopher(i , fork1, fork2);
            }
//            philosophers[i] = new Philosopher(i, i, (i+1) % num);
        }
    }
```