## 잠금 타임아웃과 교착 상태를 시험하자.



데이터베이스를 이용할 때 '잠금 타임아웃'이나 '교착 상태'가 자주 일어납니다. 이 둘의 동작을 이해해 봅시다.



## 잠금 타임아웃과 교착 상태가 발생하는 이유

잠금 타임아웃과 교착상태

MVCC에 따른 MySQl의 특성에서 MVCC의 5가지 특성을 소개했습니다. 여기서는 항목 4에 나왔던 ' 잠금 타임아읏과 잠금 타임아웃에 따라 부가적으로 발생하는 '교착 상태'에 대해 좀 더 봅시다.



## 잠금 타임아웃이란?

'갱신'과 '참조'는 서로를 블록하지 않지만, '갱신'과 '갱신'이 부딪치는 경우에는 나중에 온 갱신이 잠금 대기 상태가 됩니다. 잠금을 건 쪽이 언제 잠금을 풀지 알 수 없어서 잠금 해제를 기다리고 있는 쪽에서는 잠금을 기다리거나 기다리지 않거나, 기다린다면 어느 정도 기다릴지를(초수 지정이나 무한으로 기다린다)설정할 수 있습니다. MySQL의 경우 'innodb_lock_wait_timeout'이란 시스템 변수로 다음과 같이 설정할 수 있습니다. 다만 기다리지 않는 설정은 없어서 유효값은 '1'(초) 이상이어야 합니다.



이때 잠금 대기로 타임아웃이 발생하는 경우 DBMS로부터 롤백되는 단위가 다를 때가 있는데, 해당 트랜잭션 전체를 롤백하는 경우와 쿼리만 롤백하는 것입니다. MySQL에서는 잠금 대기로 타임아웃이 발생하면 롤백되는 것은 기본으로 오류가 발생한 쿼리입니다. 트랜잭션 전체를 롤백하고 싶다면 다음 방법으로 할 수 있습니다.

- 타임아웃 오류 후 명시적으로 ROLLBACK을 실행한다.
- Innodb_rollback_on_timeout 시스템 변수를 설정한다.



## 교착 상태란?

A, B가 있는덴, A가 테이블 a를 잠금고 B가 테이블 b를 잠갔을 때.



이 상황에서 B가 테이블 a에 쓰기를 하고 싶다면 막힘.  
반대로 A가 테이블 b에 쓰기를 하고 싶은데, 잠금으로 잠겨있어서 막힘!



#### 교착 상태의 빈도를 낮추는 대책은?

잠금 타임아웃은 일정 시간 기다리면 상황이 개선될(잠금을 건 곳에서 잠금을 푼다) 가능성이 있지만, 교착 상태는 상황이개선될 가능성이 없습니다. 이 때문에 일반적인 DBMS에서는 교착 상태를 독자적으로 검출해 교착 상태를 보고합니다. MySQL도 교착상태가 일어나면 이를 즉시 인식해 시스템에 영향이 작은 쪽의 트랜잭션을 트랜잭션 개시 시점까지 롤백합니다.

교착 상태는 일반적인 데이터베이스에서 발생할 가능성이 있으며 모든 것을 없앨 수는 없습니다. 따라서 애플리케이션 쪽에서는 항상 트랜잭션이 교착 상태를 일으켜 롤백되는 경우에 트랜잭션을 재실행할 수 있는 구조를 만들어야 합니다.



교착상태의 발생 빈대를 낮추려면~~!!!

1. 트랜잭션을 자주 커밋한다. 이에 따라 트랜잭션은 더 작은 단위가 되어 교착상태의 가능성을 낮춘다.
2. 정해진 순서로 테이블(그리고 행)에 액세스하게 한다. 예를 들어, 앞의 교착 상태의 예에서는 트랜잭션 A가 a-> b순으로 액세스했고 트랜잭션 B가 b->a순으로 액세스하고 있는데, 이를 어느 트랜잭션이라도 a->b처럼 동일한 순서로 액세스 하게 한다.
3. 필요없는 경우에는 읽기 잠금 획득의 사용을 피한다.
4. 쿼리에 의한 잠금 범위를 더 좁히거나 잠금 정도를 더 작은 것으로 한다. 예를 들어, 행의 잠금을 사용할 수 있는 경우에는 사용한다. MySQL은 트랜잭션의 격리 수준을 되도록 '커밋된 읽기'로 한다(InnoDB의 기본 격리 수준은 반복 읽기)
5. 한 테이블의 복수 행을 복수의 연결에서 순서없이 갱신하면 교착 상태가 발생하기 쉽다. 동시에 많은 연결에서 갱신 때문에 교착 상태가 자주 발생한다면 테이블 단위의 잠금을 획득해 갱신을 직렬화하면 동시성은 떨어지지만 교착 상태는 회피할 수 있어서 전체 처리로 보면 좋은 예도 있다.

반대로 MySQL에서는

6. 테이블에 적절한 인덱스를 추가해 쿼리가 이를 이용하게 한다. 인덱스가 사용되지 않는 경우에는 필요한 행의 잠금이 아닌 스캔한 행 전체에 대해 잠금이 걸리게 된다.





## 해서는 안되는 트랜잭션 처리

하지 말아야 하는 트랜젹션 종류

1. 오토커밋

   MySQL에서는 새로운 연결은 모두 기본값으로 오토커밋이 실행됩니다. '오토커밋'이란 쿼리 단위로 커밋하는 설정인데, 이 설정은 MySQL커맨드라인 클라이언트 같은 대화형 도구를 사용해 간단한 쿼리의 실행과 테스트를 하는 경우에는 편리하지만, 애플리케이션의 잠금을 실행하는 데는 커밋의 부하가 너무 높습니다. 일정 수 이상의 갱신을 수행하는 처리나 트랜잭션의 기능등은 적절한 단위와 트랜잭션 격리 수준에서 트랜잭션을 이용해 오토커밋을 사용하지 않도록 합니다.

2. 긴 트랜잭션

   긴 트랜잭션은 데이터베이스 트랜잭션의 동시성이나 자원의 유효성을 저하합니다. 갱신을 포함한 트랜잭션은 같은 테이블과 행을 갱신하려는 다른 트랜잭션을 블록하고 이것이 장시간 이어지면 블록된 트랜잭션을 타임아웃시킵니다. 또한, 이 잠금과 블록 사이에 교차가 발생하면 교착상태의 빈도를 낮추는 대책에서 소개한 내용을 실행해야 합니다. 그 외에도 다음과같은 사항을 주의하면 좋습니다.

   - 대량 처리를 한 개의 트랜잭션이 실행한다.  
     : 대량의 갱신 처리를 한 개의 트랜잭션으로 실행하면 트랜잭션으로 이 대량 갱신 처리를 롤백하기 위해 대량의 UNDO로그를 트랜잭션 종료까지 유지해야 합니다. UNDO로그가 불필요해진 시점에 해당 영역은 해제되어 재사용되지만, OS의 파일 시스템에서의 크기는 줄어들지 않습니다. 이 때문에 겉으로 보기에 쓸데없이 UNDO 로그의 크기가 큰 경우가 있습니다. 이를 막기 위해 대량 처리는 적당한 크기의 트랜잭션으로 나눠서 실행하는 것을 추천합니다. 예를 들면, 신규 테이블에 데이터를 로드할 때는 1만 건당 커밋합니다.

   - 아무것도 하지 않는 트랜잭션을 유의한다.  
     : 정말로 아무것도 하지 않는 트랜잭션이 있다면 문제없습니다. 하지만 한 번 테이블을 SELECT하고 나서 아무것도 하지 않고 트랜잭션을 열린 채로 두면 어떻게 될까? MVCC를 설명할 때 언급했는데, 같은 테이블에 갱신을 실행할 때 이 테이블의 반복 읽기를 유지하기 위해 UNDO 로그가 계속 유지된 상태가 되고 맙니다. 이런 일은 되도록 피해야 합니다.

   - 트랜잭션 중에 대화 처리를 넣는다.  
     : 일반적인 DBMS의 트랜잭션은 매우 빡빡한 처리를 동시에 실행할 수 있는 구조를 갖추고 있습니다. 이것을 효율적으로 다루려면 트랜잭션은 되도록 작게하고 트랜잭션을 구성하는 내용에는 언제 끝날지를 알 수 없는 불명확한 처리를 포함해서는 안됩니다. 불명확한 처리 중 으뜸은 사용자와의 대화처리입니다. 사용자와의 대화 처리는 일반적인 트랜잭션에서 액션과 비교하면 매우 커서 타임아웃을 설정하지 않는 한은 끝없이 사용자의 처리르 기다리게 되고, 결국 시스템 전체의 효율을 떨어뜨리게 됩니다. 이러한 처리는 트랜잭션 내에 넣지 않아야 하고, 어쩔 수없이 넣는 경우에도 반드시 상한을 정해서 무한으로 기다리는 일이 없도록 해야 합니다.

   - 처리 능력 이상의 트랜잭션 수  
     : 트랜잭션에서는 어떠한 잠금이 있는 처리를 수행할 때 이 잠금이 다른 트랜잭션의 처리를 막지 않는다면 좋겠지만, 트랜잭션이 실행이 다른 트랜잭션의 잠금 때문에 막힌다면 잠금 타임아웃이나 교착상태의 확률이 증가하고 이는 성능 저하로 이어집니다.  
     커넥션이 잘 작동하는 수나 동시 실행할 수 있는 수의 상한을 어느정도로 설정해야 할지는 시스템의 요건이나 하드웨어 성능에도 좌우되므로 최적의 트랜잭션 수는 부하 실험을 수행해 측정하는 수밖에 없습니다. MySQL에서는 데이터베이스 서버의 커넥션 수 상한을 설정하는 'max_connections'이라는 시스템 변수가 있어서 이것으로 조절할 수 있습니다.

     ​

     ​

     ​