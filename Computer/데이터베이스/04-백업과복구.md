## 지속성과 성능이 양립하는 구조

### DBMS의 3가지 구조

'ACID' 특성 중 'D'는 지속성(Durability)으로, 일련의 데이터 동작(트랜잭션 동작)을 완료(Commit)하고 완료 통지를 사용자가 받은 시점에서는 그 동작이 '영속화'되어 결과를 읽어버리지 않는 것을 나타냅니다. 이는 시스템이 정상일 때뿐만 아니라 데이터베이스 서버나 OS의 비정상적 종료 등의 시스템 장애에 견딜 수 있다는 걸 의미합니다.

DBMS에서 데이터를 보존하는 기억장치는 대부분 하드디스크입니다. 하드디스크에서 지속성을 실현하려면 쓰기를 전부 '동기화 쓰기'로 하면 좋겠지만, 데이터베이스의 쓰기는 기억장치의 임의 장소에 무작위로 액세스해서 쓰기를 수행하기 때문에 동기화 쓰기는 느려서 성능 면에서 실용적이지 않습니다. 그래서 지속성과 성능이 양립하도록 일반적으로 DBMS에서는 다음과 같은 구조를 쓴다.

**\- 로그 선행 쓰기**

로그 선행 쓰기(WAL - Write Ahead Log)의 기본 개념은 데이터베이스의 데이터 파일 변경을 직접 수행하지 않고, 우선 로그로 변경 내용을 기술한 로그 레코드를 써서 동기화하는 구조. MySQL에서는 이 로그를 'InnoDB 로그'로 부릅니다. WAL에는 다음과 같은 이점이 있습니다.

1. 디스크에 연속해서 쓰기 때문에 무작위로 쓰는 것보다 성능이 좋다.
2. 디스크에 쓰는 용량과 횟수를 줄일 수 있다.
3. 데이터베이스 버퍼를 이용해 데이터베이스의 데이터 파일로의 변경을 효율성 높게 수행한다.



**- 데이터베이스 버퍼**

커밋 시에는 WAL에 변경 내용을 쓰기 때문에 데이터 파일의 변경 내용은 트랜잭션이 커밋되면서 동시에 동기화할 필요가 없습니다. 그렇다고 트랜잭션마다 버퍼를 취해 비동기적인 쓰기를 하면 로그와 데이터 파일 간 일관성을 유지하기 어렵습니다.

그래서 일반적인 DBMS에서는 '데이터베이스 버퍼'를 준비해 데이터 파일로의 입력을 데이터베이스 버퍼 경유로 일원화해서 단순화하고 있습니다. 이 때문에 효율적으로 데이터의 일관성을 유지할 수 있게 됩니다. MySQL의 경우 갱신의 흐름은 다음과 같습니다.

1. 갱신 대상의 데이터를 포함한 페이지가 버퍼 풀에 있는지를 확인하고 없다면 데이터 파일로부터 읽어 들인다.
2. 버퍼 풀의 해당 페이지에서 갱신을 수행한다.
3. 2의 갱신 내용이 커밋과 함께 로그에 기록된다. 버퍼 풀에 갱신되었지만, 아직 데이터 파일에 써지지 않은 페이지는 버퍼 풀 내에서 더티 페이지로 다룬다.
4. 데이터페이지는 나중에 적당한 타이밍에 정리되어 데이터 파일로 써진다(체크포인트)
5. 4의 체크포인트 이전 로그 파일은 불필요해진다. 또한 갱신과 더불어 1부터 순서가 반복된다.



**\- 크래시 복구**

WAL과 데이터베이스 버퍼, 데이터베이스 파일 3가지가 연계 플레이로 지속성을 담보하면서 현실적인 성능으로 DBMS가 동작하고 있습니다. 그럼 일단 크래시(Cras)가 발생한 경우에는 어떻게 복구(Recovery)하는지 살펴봅시다.

1. **WAL** - 마지막으로 커밋된 트랜잭션의 갱신 정보를 가진다.
2. **데이터베이스 버퍼** - 크래시로 내용이 전부 소실된다.
3. **데이터베이스 파일** - 최후 체크포인트까지의 갱신 정보를 가진다.

크래시 이후 MySQL 서버를 재시작하면 3과1 의 체크포인트 이후 갱신 정보를 사용해 데이터베이스 파일을 크래시 때까지 커밋된 최신 상태로 수정합니다. 이 동작을 '롤 포워드(Roll-Forward)'라고 한다.

MySQL 서버를 재시작하는 것으로 복구할 수 있는 구조가 놀랍기도 하지만, 이와 같은 구조도 논리적인 파괴(DDL문에 따른 테이블의 파기 등)나 물리적인 파손(디스크 장치의 공장 등)에는 대응할 수 없습니다. 이와 같은 파손이나 파괴에 대응하려면 정상적으로 동작하고 있을 때 주기적으로 백업하고 이를 이용해 복원이나 복구하는 것이 좋습니다.



## 백업과 복구

**PITR이란?**

데이터베이스의 데이터를 다양한 장애에서 지키려면 데이터베이스가 정상적으로 동작할 때 백업하고, 장애가 발생하면 백업으로 복원합니다. 이렇게 하면 데이터베이스를 백업 시점의 상태로 되돌릴 수 있습니다. 하지만 단순히 백업 시점으로 되돌릴 뿐 백업 후에 데이터베이스에서 수행한 갱신은 반영되지 않습니다.

일반적인 DBMS에서는 데이터베이스에 실행된 갱신을 기록한 로그를 보존해서(Archive) 그것을 복원한 데이터베이스에 순차 반영해 백업 이후의 임의의 시점으로 복원할 수 있습니다. 이처럼 임의의 시점에서의 데이터 변경을 포함한 복원을 'PITR(Point-in-time-Revocery)'라고 부릅니다. PITR에 이용되는 로그의 이름과 특성은 DBMS마다 다릅니다.

**PITR에 이용되는 로그**

| DBMS                | Oracle       | MySQL         | PostgreSQL   | DB2           | SQL server     |
| ------------------- | ------------ | ------------- | ------------ | ------------- | -------------- |
| 로그 이름           | REDO 로그    | 바이너리 로그 | WAL 로그     | 트랜잭션 로그 | 트랜잭션 로그  |
| 아카이브 지정       | O            | X             | O            | O             | O              |
| 아카이브 시 이름    | ARCHIVELOG   | X             | WAL 아카이브 | 아카이브 로킹 | 완전 복구 모델 |
| 비 아카이브 시 이름 | NOARCHIVELOG | X             | 없음         | 순환로그      | 완전 복구 모델 |

'아카이브 지정'이란 무엇일까?

PITRT에 이용하는 로그는 대부분 앞에 설명한 WAL을 이용한 것, 이 때문에 WAL을 크래시 복구에만 이용한다면 체크포인트 이전의 로그는 불필요하게 되어 해당 디스크 영역은 삭제하거나 재이용할 수 있습니다.(다시 이용되는 경우가 대부분입니다.) 하지만 이렇게 되면 PITR을 수행하고 싶을 때에 필요한 로그가 없는 사태가 발생하게 됩니다. 따라서 크래시 복구용으로는 불필요한 로그도 PITR용으로 보존이 필요할 수 있으며 이를 위한 모드가 '아카이브 지정'입니다.

**바이너리 로그란?**

MySQL에서 PITR에는 '바이너리 로그'를 이용하는데, 앞의 로그 선행 쓰기에 나왔던 InnDB 로그는 이용하지 않는지 궁금할 수 있다. 사실 InnoDB로그는 InnoDB 전용 크래시 복구에만 이용되고, PITR에는 MySQL 전체에서 이용하는 바이너리 로그를 채용한다. 예를 들어 Oracle에서는 'REDO 로그', DB2나 SQL server에서는 트랜잭션 로그를 PITR과 크래시 복구 둘다 이용하지만, MySQL에서는 PITR에 '바이너리 로그', 크래시 복구에 'InnoDB 로그'를 이용합니다.

**백업의 3가지 관점**

1. 핫백업과 콜드 백업  
   **핫 백업**은 온라인 백업이라고도 하며 백업 대상의 데이터베이스를 정지하지 않고 가동한 채로 백업 데이터를 얻는다.  
   **콜드 백업**은 '오프라인 백업'으로 불리며 백업 대상의 데이터베이스를 정지한 후 백업 데이터를 얻는다.

2. 논리 백업과 물리 백업  
   **논리 백업**은 SQL기반의 텍스트 형식으로 백업 데이터가 기록되고,
   **물리 백업**은 데이터 영역을 그래도 덤프(데이터 파일이나 화면에 출력)하는 이미지로 바이너리 형식으로 기록굅니다.

   오픈소스 데이터베이스는 논리백업을 다루는 도구가 많아 이를 자주 사용하고,  
   클로이즈 소스 데이터베이스에서는 물리백업을 이용하는 경우가 많다.  

3. 풀 백업과 부분(증분/차등) 백업  
   백업 시 대상과 이에 따른 데이터의 양을 중심으로 본다면 '풀 백업'과 '부분(증분/차등)백업' 으로 구분할 수 있습니다. 풀 백업은 '전체 백업'이라고도 하며 데이터베이스 전체 데이터를 매일 백업하는 방식.  
   부분 백업은 우선 풀 백업을 한 이후 갱신된 데이터를 백업합니다.



#### 부분 백업의 2가지 방법

부분 백업에는 최근에 풀 백업한 이후에 갱신된 데이터를 백업하는 '차등 백업'과 최근 백업한 이후에 갱신된 데이터를 백업하는 '증분 백업'이 있다.

증분 백업은 데이터의 양이 차등 백업보다 작지만, 복윈 시 모든 증분 백업을 차례로 적용해야 해서 절차가 복잡합니다.



**롤 포워드 리커버리**

기본적으로 풀 백업만으로 복원하는 것은 '백업 시점'입니다. 하지만 MySQL은 앞에서도 언급했듯이 바이너리 로그(WAL)을 출력할 수 있습니다. 그래서 바이너리 로그를 증분 백업으로 보존하고 이를 사용해 풀 백업 시점 이후 임의 시점까지 복원하는 것이 가능합니다. 이것을 '롤 포워드 리커버리'라고 합니다. 기본적으로 앞에서 소개한 롤 포워드와 같은 처리로, 바이너리 로그를 사용하는 것만 다를 뿐입니다. 즉, 현재의 데이터베이스는 다음과 같이 표현할 수 있고, 이는 풀 백업괒 으분 백업으로 현재 데이터베이스를 복구할 수 있다는 의미입니다.

​	`현재의 데이터베이스 = 풀 백업한 데이터 + 풀 백업 후 얻은 모든 증분 백업`