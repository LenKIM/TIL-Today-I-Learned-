## 07 트랜잭션과 동시성 제어 

(복수의 쿼리 통합)

일반적인 DBMS로 애플리케이션의 로직을 구성할 때 이용하는 '트랜잭션'과 '잠금'구조에 관해 설명하겠습니다. 



DB를 사용하는 실제 시스템이나 애플리케이션에서는 단일 쿼리만으로 조작하는 일은 거의없고 복수의 쿼리를 연속적으로 사용해 일관성 있는 형태의 한 단위로 취급해야 합니다. 이런 한 덩어리의 쿼리처리 단위를 '트랜잭션'이라고 합니다. 여기서는 트랜잭션을 다룰 수 있는 테이블을 작성해 보겠습니다.



```sql
mysql> create table t1(i1 int not null primary key, v2 varchar(20)) engine = innodb;
Query OK, 0 rows affected (0.02 sec)


mysql> show create table t1
    -> ;
+-------+-----------------------------------------------------------------------------------------------------------------------------------------+
| Table | Create Table                                                                                                                            |
+-------+-----------------------------------------------------------------------------------------------------------------------------------------+
| t1    | CREATE TABLE `t1` (
  `i1` int(11) NOT NULL,
  `v2` varchar(20) DEFAULT NULL,
  PRIMARY KEY (`i1`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8 |
+-------+-----------------------------------------------------------------------------------------------------------------------------------------+
1 row in set (0.00 sec)
```



트랜잭션에 대해 조금더 면밀히 알아보자.

애플리케이션 로직을 구성할 때 사용하는 트랜잭션이나 잠금 구조를 공부합니다. 앞 장에서는 테이블 갱신을 수행하기 위해 'INSERT/DELETE/UPDATE'를 사용했는데, 갱신은 단일 쿼리만으로 구성된 것이 아니고 복수 쿼리를 연속적으로 수행하는 경우가 대부분입니다. 또한 갱신 전의 데이터로 SELECT를 사용할 때 이를 포함해 복수 쿼리를 일관된 형태의 한덩어리로 다뤄야 합니다. 트랜잭션이란 이런 복수 쿼리를 한 단위로 묶은 것입니다.

MySQL에서는 트랜잭션을 사용할 수 없는 단순한 구조의 'MyISAM형'과 일반적인 DBMS와 똑같은 트랜잭션 구조를 사용할 수 있는 'InnoDB형' 2종류의 테이블을 이용할 수 있습니다.

트랙잭션은 4가지 특성 

### ACID

1. Atomicity(원자성)
2. Consistency(일관성)
3. Isolation(고립성 또는 격리성)
4. Durability(지속성)



### - 원자성(Atomicity)

데이터의 변경을 수반하는 일련의 데이터 조작이 전부 성공할지 전부 실패할지를 보증하는 구조입니다. 예를 들어, 서울에서 KTX로 부산까지 가서 일바하고 다음날 서울로 돌아오는 경우를 생각해 봅시다. 아마 다음과 같은 과정을 거칠텐데.

1. 서울 =>부산행 좌석을 예매 
2. 부산에서의 숙박을 예약 
3. 부산 => 서울 좌석을 예매 
4. 1~3의 대금을 결제



이런 절차가 모두 잘 진행되면 트랜잭션에서는 1~4를 처리한 후에 'COMMIT'을 실행해 처리를 확정합니다. 이 경우 각 데이터의 조작은 영구적으로 저장되어 결과가 손실되지 않습니다. 그러면 처리 도중에서 오류가 발생하는 경우는 어떨까요? 예를 들어 3) 에서 좌석을 예매할 수 없다든지 4)에서 보유한 돈이 부족한 경우입니다. 이런 경우에는 'ROLLBACK'을 실행해 1-4의 처리 과정 중 1의 직전 상태까지 되돌아 갈 수 있습니다. 또한, 이렇게 시스템이 정상 동작하는 상황에서의 오류뿐만아니라 클라이언트에서 서버로의 통신이 끊긴다거나 서버가 다운된 경우에도 COMMIT 된 것 이외는 ROLLBACK을 해야 합니다.

### - 일관성(Consistency)

데이터베이스에는 데이터베이스 오브젝트에 대해 각종 정합성 제약을 추가할 수 있습니다. 이는 일련의 데이터 조작 전후에 그 상태를 유지하는 것을 보증하는, '일관성'을 유지하기 우한 구조입니다. 예를 들면, 시스템에 사용자를 등록할 때 사용자를 임의로 식별하기 위해 일련번호를 사용자에게 발급합니다. 이때 이번호에 유니크 제약을 설정하면 중복된 사용자 번호를 저장할 수 없습니다. 이것은 복수의 사용자가 동시에 사용자 번호를 취득하려는 경우에도 마찬가지입니다.

### - 고립성(Isolation)

일련의 데이터 조작을 복수 사용자가 동시에 실행해도 '각각의 처리가 모순없이 실행되는 것을 보증한다'는 것입니다. 예를 들면, 부산의 지정 호텔에 남은 싱글룸 수가 10개였을 때 실제로 숙박한 흐름을 프로그래밍 하듯이 표현하면 다음과 같다.

1) 현재 빈 싱글룸의 수를 확인한다(SELECT)

2) 빈 싱글룸 수에서 1을 빼고 결과를 빈 싱글룸 수로 되돌려 쓴다 (UPDATE)

이것을 사용자 A와 사용자 B가 동시에 수행하면 어떻게 될까요? 2명이 방을 확보한다면 원래 빈 싱글룸 수는 2개가 줄어야 하지만, 같은 방을 동시에 확보하게 되면 빈 싱글룸 수는 1개만 줄어들게 됩니다.



(... 중간 생략)



데이터베이스에서는 데이터베이스 오브젝트인 테이블에 대해 '잠금'을 걸어서 후속 처리를 블록하는 방법이 있습니다. 잠금단위에는 테이블 전체, 블록, 행 등이 있는데, MySQL에서는 트랜잭션 처리를 할 때 주로 행 단위의 잠금 기능을 이용합니다. 예들어, 앞의 두 가지 중 '1) 현재 빈 싱글룸 수를 확인한다'를 처리할 때 'SELECT ~ FOR UPDATE'를 실행하면 SELECT한 행에 잠금이 걸립니다. 이렇게 되면 후속 처리는 해당 잠금이 해제될 때 (COMMIT 또는 ROLLBACK, 여기서는 COMMIT)까지 대기학 되며 올바른 처리를 계속할 수 있게 됩니다.



또한, InnoDB형의 테이블은 'MVCC'라는 구조로 동작하기 때문에 이번 예에서 사용자 B가 단순히 값을 참조하는 경우에는 SELECT에 FOR UPDATE는 불필요하며 이 경우 읽기는 블록되지 않습니다. 테이블을 갱싱하는 사용자가 소수고 참조하는 사용자가 많은 경우에는 사용자의 동시성, 병렬성이 높아집니다.

그럼 '각각의 처리가 모순없이 실행되는 것을 보증한다'라고 헀는데, 어떻게? 어떤 상태를 ' 모순 없다 '라고 할 수 있을까요? 이에 대한 답은 '복수의 트랜잭션이 순서대로 실행되는 경우와 같은 결과를 얻을 수 있는 상태'입니다. 이건 병렬로 실행되는 처리를 생각하면 복잡하므로 좀 더 간단한 병렬로 실행되지 않는(직렬)상태를 말하며, 이와 같으면 모순 없음을 보장할 수 있습니다.

이것을 DBMS에서 격리 수준(Transaction Isolation Level 4)으로 구현하고 제공하는 것이 '직렬화 가능'이라는 사양입니다. 하지만 직렬화 가능의 고립성에서는 항상 동시에 동작하는 트랜잭션이 1개의 이미지가 되어 성능면에서 실용적이지 않습니다. 이 때문에 직렬화 가능으로부터 격리 수준을 완화해 직렬화 가능 이외에 자신이 아닌 다른 트랜잭션의  영향받는 것을 허용하는 4개의 단계를 'ANSI'라는 규격 단체에서 정의했습니다. ANSI가 정의하는 격리 수준은 다음과 같습니다.

1. 커밋되지 않은 읽기(Read Uncommitted, 리드 언커밋티드)
2. 커밋된 읽기(Read Committed, 리드 커밋티드)
3. 반복읽기(Repeatable Read, 리피터블 리드)
4. 직렬화 가능(Serializable, 시리얼라이저블)



### - 지속성(Durability)

일련의 데이터 조작(트랜잭션 조작)을 완료(COMMIT)하고 완료 통지를 사용자가 받는 시점에서 그 조작이 영구적이 되어 그 결과를 잃지 않는 것을 나타냅니다. 이것은 시스템이 정상일 때만이 아니라 데이터베이스나 OS의 이상 종료, 즉 시스템 장애도 견딜 수 있다는 뜻입니다. MySQL을 포함해 많은 데이터베이스의 구현에서는 트랜잭션 조작을 하드 디스크에 '로그'로 기록하고 시스템에 이상이 발생하면 그 로그를 사용해 이상 발생 전의 상태까지 복원하는 것으로 지속성을 실현하고 있습니다.



## 이제 복수의 커넥션에서 읽기와 쓰기를 테스트 해보자.



TransAction A>

```Mysql
Transaction A>insert into t1 value(3, 'PostgreSQL'); commit; start transaction;
Query OK, 1 row affected (0.00 sec)

Query OK, 0 rows affected (0.00 sec)

Query OK, 0 rows affected (0.00 sec)

Transaction A>select * from t1;
+----+------------+
| i1 | v2         |
+----+------------+
|  1 | Firebird   |
|  2 | MySQL      |
|  3 | PostgreSQL |
+----+------------+
3 rows in set (0.00 sec)

Transaction A>rollback;
Query OK, 0 rows affected (0.00 sec)

Transaction A>select * from t1;
+----+------------+
| i1 | v2         |
+----+------------+
|  1 | Firebird   |
|  2 | MySQL      |
|  3 | PostgreSQL |
+----+------------+
3 rows in set (0.00 sec)

Transaction A>select * from t1;
+----+------------+
| i1 | v2         |
+----+------------+
|  1 | Firebird   |
|  2 | MySQL      |
|  3 | PostgreSQL |
+----+------------+
3 rows in set (0.00 sec)

Transaction A>select * from t1;
+----+------------+
| i1 | v2         |
+----+------------+
|  1 | Firebird   |
|  2 | MySQL      |
|  3 | PostgreSQL |
|  4 | Oracle     |
+----+------------+
4 rows in set (0.00 sec)

Transaction A>select * from t1;
+----+------------+
| i1 | v2         |
+----+------------+
|  1 | Firebird   |
|  2 | MySQL      |
|  3 | PostgreSQL |
|  4 | Oracle     |
|  5 | Test       |
+----+------------+
5 rows in set (0.00 sec)

Transaction A>start transaction;
Query OK, 0 rows affected (0.00 sec)

Transaction A>insert into t1 values(6, 'JavaDB');
ERROR 1205 (HY000): Lock wait timeout exceeded; try restarting transaction
Transaction A>rollback;
Query OK, 0 rows affected (0.00 sec)

Transaction A>select * from test;
ERROR 1146 (42S02): Table 'test.test' doesn't exist
Transaction A>select * from t1;
+----+------------+
| i1 | v2         |
+----+------------+
|  1 | Firebird   |
|  2 | MySQL      |
|  3 | PostgreSQL |
|  4 | Oracle     |
|  5 | Test       |
+----+------------+
5 rows in set (0.00 sec)

Transaction A>set transaction isolation level repeatable read; start transaction;
Query OK, 0 rows affected (0.00 sec)

Query OK, 0 rows affected (0.00 sec)

Transaction A>select * from t1 where i1 = 1;
+----+-------+
| i1 | v2    |
+----+-------+
|  1 | MySQL |
+----+-------+
1 row in set (0.00 sec)

Transaction A>select * from t1 where i1 = 1;
+----+-------+
| i1 | v2    |
+----+-------+
|  1 | MySQL |
+----+-------+
1 row in set (0.00 sec)

Transaction A>select * from t1 where i1 = 1;
+----+-------+
| i1 | v2    |
+----+-------+
|  1 | MySQL |
+----+-------+
1 row in set (0.00 sec)

Transaction A>rollback;
Query OK, 0 rows affected (0.00 sec)

Transaction A>select * from t1 where i1 = 1;
+----+------------+
| i1 | v2         |
+----+------------+
|  1 | PostgreSQL |
+----+------------+
1 row in set (0.00 sec)

Transaction A>;2D;2D
```



TransAction B>

```Mysql
Transaction B>select * from t1;
+----+------------+
| i1 | v2         |
+----+------------+
|  1 | Firebird   |
|  2 | MySQL      |
|  3 | PostgreSQL |
|  4 | Oracle     |
+----+------------+
4 rows in set (0.00 sec)

Transaction B>select * from t1;
+----+------------+
| i1 | v2         |
+----+------------+
|  1 | Firebird   |
|  2 | MySQL      |
|  3 | PostgreSQL |
|  4 | Oracle     |
+----+------------+
4 rows in set (0.00 sec)

Transaction B>insert into t1 values(5, 'Test');
Query OK, 1 row affected (0.01 sec)

Transaction B>select * from t1;
+----+------------+
| i1 | v2         |
+----+------------+
|  1 | Firebird   |
|  2 | MySQL      |
|  3 | PostgreSQL |
|  4 | Oracle     |
|  5 | Test       |
+----+------------+
5 rows in set (0.00 sec)

Transaction B>rollback;
Query OK, 0 rows affected (0.00 sec)

Transaction B>select * from t1;
+----+------------+
| i1 | v2         |
+----+------------+
|  1 | Firebird   |
|  2 | MySQL      |
|  3 | PostgreSQL |
|  4 | Oracle     |
|  5 | Test       |
+----+------------+
5 rows in set (0.00 sec)

Transaction B>start transaction;
Query OK, 0 rows affected (0.00 sec)

Transaction B>select * from t1;
+----+------------+
| i1 | v2         |
+----+------------+
|  1 | Firebird   |
|  2 | MySQL      |
|  3 | PostgreSQL |
|  4 | Oracle     |
|  5 | Test       |
+----+------------+
5 rows in set (0.00 sec)

Transaction B>start transaction;
Query OK, 0 rows affected (0.00 sec)

Transaction B>insert into t1 values(6, 'Oracle');
Query OK, 1 row affected (0.00 sec)

Transaction B>insert into t1 values(4, 'Oracle');
ERROR 1062 (23000): Duplicate entry '4' for key 'PRIMARY'
Transaction B>rollback;
Query OK, 0 rows affected (0.00 sec)

Transaction B>select * from t1;
+----+------------+
| i1 | v2         |
+----+------------+
|  1 | Firebird   |
|  2 | MySQL      |
|  3 | PostgreSQL |
|  4 | Oracle     |
|  5 | Test       |
+----+------------+
5 rows in set (0.00 sec)

Transaction B>set transaction isolation level read committed; start transaction;
Query OK, 0 rows affected (0.00 sec)

Query OK, 0 rows affected (0.00 sec)

Transaction B>select * from t1 where i1 = 1;
+----+-------+
| i1 | v2    |
+----+-------+
|  1 | MySQL |
+----+-------+
1 row in set (0.00 sec)

Transaction B>select * from t1 where i1 = 1;
+----+------------+
| i1 | v2         |
+----+------------+
|  1 | PostgreSQL |
+----+------------+
1 row in set (0.00 sec)

Transaction B>select * from t1 where i1 = 1;
+----+------------+
| i1 | v2         |
+----+------------+
|  1 | PostgreSQL |
+----+------------+
1 row in set (0.00 sec)

Transaction B>rollback;
Query OK, 0 rows affected (0.00 sec)

Transaction B>select * from t1 where i1 = 1;
+----+------------+
| i1 | v2         |
+----+------------+
|  1 | PostgreSQL |
+----+------------+
1 row in set (0.00 sec)

Transaction B>
```

Transaction C>

```Mysql
atabase changed
mysql> PROMPT Transaction C>
PROMPT set to 'Transaction C>'
Transaction C>select * from t1;
+----+------------+
| i1 | v2         |
+----+------------+
|  1 | Firebird   |
|  2 | MySQL      |
|  3 | PostgreSQL |
|  4 | Oracle     |
|  5 | Test       |
+----+------------+
5 rows in set (0.00 sec)

Transaction C>use test;
Database changed
Transaction C>start transaction;
Query OK, 0 rows affected (0.00 sec)

Transaction C>update t1 set v2 = 'MySQL' where i1 = 1;commit; start transaction;
Query OK, 1 row affected (0.00 sec)
Rows matched: 1  Changed: 1  Warnings: 0

Query OK, 0 rows affected (0.00 sec)

Query OK, 0 rows affected (0.00 sec)

Transaction C>update t1 set v2= 'PostgreSQL' where i1 = 1; commit; start transaction;
Query OK, 1 row affected (0.00 sec)
Rows matched: 1  Changed: 1  Warnings: 0

Query OK, 0 rows affected (0.00 sec)

Query OK, 0 rows affected (0.00 sec)

Transaction C>update t1 set v2 = 'Oracle' where i1 = 1;
Query OK, 1 row affected (0.00 sec)
Rows matched: 1  Changed: 1  Warnings: 0

Transaction C>select * from t1 where i1 = 1;
+----+--------+
| i1 | v2     |
+----+--------+
|  1 | Oracle |
+----+--------+
1 row in set (0.00 sec)

Transaction C>rollback;
Query OK, 0 rows affected (0.01 sec)

Transaction C>select * from t1 where i1 = 1;
+----+------------+
| i1 | v2         |
+----+------------+
|  1 | PostgreSQL |
+----+------------+
1 row in set (0.00 sec)

Transaction C>;
```





## 왜 격리 수준에 따른 외관상 차이가 날까?

MVCC에 따른 MySQL의 특성

MySQL은 현재 DBMS의 주류가 된 'MVCC(Multi Versioning Concurrency Control)'라는 기술을 사용하고 있습니다. MVCC를 사용하기 때문에 MySQL은 다음 특성을 가집니다. 



1) 읽기를 수행할 경우 갱신 중이라도 블록되지 않는다.(읽기와 읽기도 서로 블록되지 않는다.)

2) 읽기 내용은 격리 수준에 따라 내용이 바뀌는 경우도 있다.

3) 갱신 시 배타적 잠금을 얻는다. 잠금은 기본적으로 행 단위로 얻으며 트랜잭션이 종료할 때까지 유지한다. 격리수준이나 InnoDB의 설정에 따라 실제로 잠금 하는 행의 범위가 다른 경우가 있다.

4) 갱신과 갱신은 나중에 온 트랜잭션이 잠금을 획득하려고 할 떄 블록된다. 일정시간을 기다리며 그 사이에 잠금을 획득할 수 없는 경우에도 '잠금 타임아웃(Lock Timeout)'이 된다.

5) 갱신하는 경우 갱신 전의 데이터를 UNDO로그로 '롤백 세그먼트'라는 영역에 유지한다. 이 'UNDO로그'는 용도가 2가진데, 첫번째는 갱신하는 트랜잭션의 롤백 시 갱신 전으로 되돌리는 것이고, 두 번쨰는 복수의 트랜잭션으로부터 격리 수준에 따라 대응하는 갱신 데이터를 참조하는 데 이용한다.(같은 행을 갱신할 때마다 UNDO 로그가 작성되어 같은 행에 대한 복수 버전이 존재하며 이에 ㄷ의 1,2를 실현하고 있다.)



### 트랜잭션 격리 수준별 외관

MVCC에 따른 MySQL의 특성에서 '2) 읽기 내용은 격리 수준에 따라 내용이 바뀌는 경우가 있다'고 했는데, 여기서는 격리 수준에 따라 보이는 방식을 설명하겠습니다.

MySQL 트랜잭션 격리 수준의 기본값은 '반복 읽기(RR)'입니다. 11강 STEP3에서는 Transaction A의 격리 수준을 반복 읽기, Transaction B의 격리 수준을 '커밋된 읽기'로 변경하였고, Transaction C에서의 변경에 따라 각각에서 보이는 방식을 확인했습니다.



#### 반복 읽기(Repeatable Read)

최초 쿼리를 실행한 시점에 커밋된 데이터를 읽어 들입니다. 이 시점에서는 커밋된 읽기와 같습니다. 같은 쿼리를 복수 회 실행하면 최초 읽은 내용의 결과 세트가 반환됩니다. 복수 회의 쿼리 실행 사이에 다른 트랜잭션이 커밋했어도 그 내용은 반영되지 않습니다.

그래서 Transactions A>는 처음 읽었던 MySQL에서 변하지 않았다. 



#### 커밋된 읽기(Read Committed)

커밋된 읽기는 쿼리를 실행한 시점에서 커밋된 데이터를 읽어 들입니다. 같은 쿼리를 복수 회 실행하면 그 사이에 다른 트랜잭션에서 커밋할 때가 있는데, 이 경우 최신 쿼리의 실행 개시 시점에서 커밋된 데이터를 읽습니다.(Transaction B).

그래서 Transactions B>는 처음에는 MySQL 커밋된 이후에는 PostgreSQL



#### 갱신을 수행하는 트랜잭션 자신

갱신을 수행하는 트랜잭션(Transaction C)자신은 트랜잭션 격리 수준이나 COMMIT/ROLLBACK에 상관없이 자신이 수행했던 갱신을 즉시 볼 수가 있습니다.

```mysql
Transaction C>update t1 set v2 = 'Oracle' where i1 = 1;
Query OK, 1 row affected (0.00 sec)
Rows matched: 1  Changed: 1  Warnings: 0

Transaction C>select * from t1 where i1 = 1;
+----+--------+
| i1 | v2     |
+----+--------+
|  1 | Oracle |
+----+--------+
1 row in set (0.00 sec)

```





#### 커밋되지 않은 읽기가 사용되지 않은 이유

그런데 앞에서 소개한 트랜잭션 격리 수준에서 ''커밋되지 않은 읽기'는 다루지 않았습니다. MVCC에서는 이 격리 수준이 별로 필요 없어서 안적은 이유도 있지만, 여기에는 다른 이유가 있습니다.



현재는 MVCC가 주류라고 할 수 있지만, Oracle과 Firebird가 구현된 시점에서는 주류가 아니었다. 그 당시 많은 데이터베이스가 잠금을 어떤 단위(테이블, 블록, 행)로 획득하는 방식에서 트랜잭션의 고립성을 담보하고 있었습니다. 이 경우 읽기의 시점에 따라 읽기가 블록되는 경우가 있습니다. 예를 들어, 부정확해도 그 순간 값의 스냅샷을 원하면 읽기를 기다리는 경우가 있습니다. 이때 커밋되지 않은 읽기를 이용하면 읽기를 이용하면 읽기가 블록되지 않으므로 그 순간의 대략적인 값을 알 수 있어 매우 편리합니다.