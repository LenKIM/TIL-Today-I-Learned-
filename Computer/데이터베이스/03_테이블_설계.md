

## 집합과 함수를 살펴보자

관계형 데이터베이스에서는 테이블에 데이터를 저장하고 관리합니다. 물론 다양한 데이터가 이 테이블에 저장되므로 어떤 기준에 따라 작성해야 합니다. 이것을 '테이블 설계'라고 하는데, 이 테이블 설계 시 중요한 것이 '집합'과 '함수'입니다.

**테이블은 집합이며 함수입니다.**

```xml
집합?
테이블은 '공통적인 요소의 집합'입니다. 이 말이 어렵게 생각될 수도 있지만, 사실 매우 간단합니다. 다음 항목을 공통적인 요소로 분류하고 각 그룹이 어떤 집합인지를 생각해 봅ㄴ시다.
[완두콩, 서울 특별시, 수소, 경기도, 토마토, 헬륨, 리툼, 옥수수, 제주도]
- 시도(서울특별시, 경기도, 제주도)
- 채소(완두콩, 토마토, 옥수수)
- 화학물질(수소, 헬륨, 리튬)
```



## 테이블 설계의 기초

**데이터를 관리하는 그룻, 테이블**

관계형 데이터에서 데이터를 관리하고 저장하기 위한 그릇은 '테이블'뿐이고 다른 곳은 없습니다. 결국, 관계형 데이터베이스에서는  '전체 데이터가 테이블에 포함되고 저장된다'는 것을 의미합니다. 따라서 관계형 데이터베이스에서는 테이블을 사용해 데이터를 적절히 다루는 것이 매우 중요합니다. 즉, 테이블로 시작해서 테이블로 끝난다고 봐도 무방합니다. 그렇다고 해도 업무에 필요한 데이터는 매우 다양하며 이를 관리하기 위한 데이터베이스의 테이블 수도 수백 개에서 천 개가 넘는 경우도 있습니다. 이 정도로 데이터가 복잡하고 대규모가 되면 생각나는 대로 테이블을 만들어 적당히 데이터를 집어넣어서는 데이터가 어디에 들어있는지를 알 수 없게 되고, 장기적인 운용도 견디지 못합니다. 실제로 허술한 테이블 설계 때문에 데이터에 모순이 생기는 문제가 끊이지 않고 일어나고 있습니다.

**관계형 데이터베이스가 주류가 된 이유**

시스템에서는 데이터베이스에 저장된 데이터가 전부라서 이것이 잘못된 경우에도 이에 기반을 둔 모든 처리 결과가 부정확해집니다. 'Garbage in, garbage out' (쓰레기에서는 쓰레기밖에 나오지 않는다.)

따라서 데이터베이스에서 데이터의 정합성은 매우 높은 단계로 요구됩니다. 데이터베이스에 여러 종류가 있다고 1장에서 언급했는데, 이중관계형 데이터베이스가 표준 데이터베이스 제품이 된 이유 중 하나는 데이터의 정합성을 높이기 위한 '설계 노하우'가 매우 발달했기 때문입니다.

설계 노하우? 이는 정규형과, ER다이어 그램을 말한다.

#### 테이블 설계는 논리의 세계

테이블 설계는 '논리 설계'란 말로 부르는 경우가 있습니다. 여기서 말하는 논리와 물리의 구별은 하드웨어와 관련이 있느냐 관점입니다. 시스템에서 하드웨어의 세계를 '물리', 소프트웨어의 세계를 '논리'로 부릅니다. 테이블 설계는 서버나 스토리지 같은 물리층과 관계없이 독립적으로 작성하는 것이 가능해서 '논리의 세계에서 결정된다 라고 간주하는 것입니다.'

#### 테이블이란?

테이블 설계의 기술을 배우기 전에 '테이블이란 무엇인가?'를 먼저 생각해 봅시다. 관계형 데이터베이스에서 테이블이란 2차원 표와 같다고 설명했습니다. '테이블은 공통적인 요소의 집합이다', 쉽게 표현하면 테이블은 관련성 없는 것이 이것저것 모여서는 안된다는 것입니다. 

**즉, 테이블은 공통 속성을 가진 것의 집합이다.**

테이블이란 각각의 행이 어떤 공통적인 특징을 가진 집합이어야 하기 때문입니다.  
'어떤 공통의 속성을 가진 것의 집합'을 나타내야 하고, 이것이 테이블 설계의 제 1규칙입니다. 이 규칙을 데이터베이스 세계에서는 '테이블명은 반드시 복수형이나 집합명사로 표현해야 한다'라고 표현합니다.

**테이블은 현실세계를 반영한다.**

이 규칙의 또 한 가지 의미는 '테이블은 현실 세계를 베낀 상이다'라는 것입니다. 우리는 현실을 여러 '개념'이나 '집합'으로 구별해 인식합니다. 예를 들어, '가늘고 길며 흰색과 녹색이고, 냄비에 넣으면 맛있는 것'을 '파', '빨갛고 둥글며 먹으면 시큼하면서도 약간 달게 느껴지는 것'을 '토마도'라는 이름을 붙여 이들의 공통적인 '채소'라는 집합(개념)으로 분류합니다.

이 분류는 사람의 인식 능력 고유한 속성이지만, 관계형 데이터베이스의 테이블에도 사람이 만든 개념이나 집합에 대응하는 형식으로 존재하지 않으면 안 됩니다. 따라서 현실 세계에서 이름이 붙지 않은 잡다한 모음은 관계형 데이터베이스의 세계에도 존재하지 않는 것입니다.

## 테이블 설계 규칙

### 테이블 설계는 간단하다?

사실 테이블 설계란 앞에서 언급하듯, '테이블은 현실 세계의 개념이나 집합을 나타낸 것'이라는 규칙을 충실하기만 하다면 어려울 게 없습니다. 물론 테이블 수가 증가하거나 테이블 간 관계성이 복잡해진다면 기술적으로 복잡한 부분이 증가합니다. 하지만 적어도 기본 방침에서는 그다지 고민할 거리는 없습니다. 따라서 이 규칙이 의미하는 바를 깨달으면 초급자라도 비교적 괜찮은 테이블 설계를 할 수 있습니다.

하지만 모두가 요령이 좋지는 않으므로 좀 더 이 규칙을 바탕으로 테이블 설계의 일반 원칙을 소개하겠습니다. 이것은 바꿔 말하면 '절대로 해서는 안 되는 설계 패턴'과 같습니다. '정말로 이런 황당한 일을 하는 사람이 있을까?'라고 생각할 수도 있지만, 필자가 실제로 시스템 개발 현장과 실제로 운용중인 시스템에서 본 사례입니다.

### 사물과 사물의 집합은 계층이 다르다.

**'테이블이란 공통점을 가진 사물의 집합을 나타낸 것이다'**는 테이블의 제1 규칙입니다. 이 규칙을 어기면 아무런 연관성도 없는 무작위 집합이 생깁니다. 이런 잡다한 *'무엇이든 상자*'같은 표를 만드는 것도 당연히 안티패턴의 한가지. 이것은 사물의 '공통점'이라는 부분을 무시한 경우에 일어나는 실패지만, 또 한 가지 안티패턴은 '사물과 집합의 계층성'을 무시하는 경우에 일어납니다.

무슨말? 
완두콩

| 이름   | 색   | 맛        |
| ------ | ---- | --------- |
| 완두콩 | 초록 | 약간 쓰다 |

토마토

| 이름   | 색   | 맛           |
| ------ | ---- | ------------ |
| 토마토 | 빨강 | 새콤달콤하다 |

옥수수

| 이름   | 색   | 맛        |
| ------ | ---- | --------- |
| 옥수수 | 노랑 | 약간 달다 |

무엇보다도 '무엇을 가져야 집합이라고 간주할 것인가'는 현실 세계의 문맥에 의해 바뀌는 것으로 '토마토'란 것을 '각각의 토마토의 집합'으로 생각하는 것도 가능합니다. 이때 '토마토'테이블을 만드는 것은 절대 이상하지 않습니다. 이 토마토 테이블에서 열은 무게나 모양 같은 각각의 토마토 속성을 나타내게 됩니다.



이것이 나쁜 패턴일 수 있지만, 안그럴 수도 있다.

**관계형 데이터베이스가 인간의 인식을 반영하는 거울이라는 것은 역으로 자의적으로 개념을 만들어서 집합을 나누는 인간의 자유로운 사고도 반영한다는 것이 됩니다. 이것이 데이터베이스 테이블 설계의 어려움입니다. '인간 인식을 반영한다'란 것은 무절제한 자유도와 패턴을 허용하는 것이기도 합니다.**

**그럼 기본적인 규칙에 대해 알아보자.**

### 1. 가장 상위의 개념집합으로 정리한다.

무슨 말일까? 즉, 일반과 프리미엄의 차이는  '열'로 표현하는 것. 이렇게 하는 이유는 이 테이블이 가장 애플에 대한 유연성이 있기 때문입니다. 위 둘을 구분할때 SQL문의 WHERE절로 열을 제어하면 간단하게 구현할 수 있다.

### 2.열이란 객체의 속성이다.

'열은 객체의 속성' 즉, Attribute 란 영단어의 번역으로 '성질'이나 '특징'과 거의 같은 의미입니다.  
객체지향언어와 친숙하다면 **테이블이라는 것은 '메소드를 뺀 클래스'입니다.**

### 3. 현실 세계에 같은 사람은 2명 있지 않다.

테이블을 클래스, 각 행을 인스턴스로 본다면 테이블에 있는 '기본키'의 중요성도 쉽게 이해할 수 있습니다. 테이블 설계 원칙의 하나로 '반드시 기본키를 설정할 것'이란 원칙이 있습니다. 이것은 '한 개 테이블의 내용에는 중복 행을 허용하지 않는다'라는 의미가 됩니다.

물론 한 개나 두 개의 열에서 값이 똑같은 행은 존재할 수 있습니다. 회원 테이블을 생각해보면 나이나 성별이 일치하는 회원이 있을 수 있고, 동성동명인 사람도 찾아보면 몃 명 발견될 가능성이 있습니다. 하지만 전체 열이 완전히 같은 데이터가 있다면 어느 행이 현실 세계의 특정 인물에 대응하는 것인지를 알 수 없게 됩니다.

### 4. 기본키 할당은 관리의 기본

### 5. 기본키는 중복되면 안 된다.

### 6. 기본키의 값이 바뀌면 왜 곤란한가?

\- 변경 후 값의 유일성을 보증할 수 없다.  
\- 과거 데이터와의 결합(매칭)이 어렵다.  

### 7. 기본키 열로 NULL은 불가

기본키가 레코드를 고유하게 식벽할 수 있는 열이란 것은 기본키 열에는 'NULL'이 존재해서는 안된다는 뜻도 있습니다.



## 정규형

**정규형이란?**

테이블을 한마디로 정리하면 '고유한 기본키를 가진 공통점에 의해 정리된 것들의 집합' 여기서는 더욱더 나아가 각 테이블이 구체적으로 어떤 열을 가져야 하는지를 생각해 보려고 합니다.

테이블은 앞에서도 본 것처럼 순수하게 기술적으로 본다면 매우 자의적으로 열을 정의하거나 테이블을 나눈 것이 가능합니다. 이 상태를 내버려 두면 설계자 이외 누구도 의미를 이해할 수 없는 카오스 같은 테이블이 세상에 넘쳐 흐르게 되므로 관계형 데이터베이스 세계에서는 오랜전부터 '테이블은 이렇게 정의해야 한다'는 이론이 구축됐습니다. 그 기본이 되는 것이 '정규형 입니다.' 정규형은 자세한 부분까지 학습하려면 매우 복잡해서 다양한 지식이 필요하지만, 실무에서 이용하는 수준에서는 그렇게 어려운 부분까지 이해할 필요없다.



### 제1 정규형(1NF)

**'테이블 셀에 복합적인 값을 포함하지 않는다.'인데 관계형 데이터베이스에서는 이 정의에 반하는 테이블을 작성하는 것이 기술적으로 불가능**

복합적인값? 예를 들면  '배열'입니다. 배열이란 (사과, 귤)이나 복수의 값을 하나로 정리한 데이터를 말합니다.

| 사원ID |  이름  | 나이 | 성별 |     피부양자     |
| :----: | :----: | :--: | :--: | :--------------: |
|  S001  | 김미경 |  38  |  여  |      박초롱      |
|  S002  | 이관식 |  62  |  남  | (이수빈, 이수민) |

피부양자에 배열이 들어가서 복합적인 배열로 인식되 안된다!

테이블을 나누면 된다.

**사원**

| 사원ID | 이름   | 나이 | 성별 |      |
| ------ | ------ | ---- | ---- | ---- |
| S001   | 김미경 | 38   | 여   |      |
| S002   | 이관식 | 62   | 남   |      |

사원-부양자

| 사원ID | 피부양자번호 | 피부양자이름 |
| ------ | ------------ | ------------ |
| S001   | 1            | 박초롱       |
| S002   | 1            | 이수빈       |
| S002   | 2            | 이수인       |

이런 식으로 사원뿐만 아니라 부양자 테이블을 만들어서 어느 쪽의 데이터도 셀에 한 개의 값을 기재헤 관리할 수 있게 되었다.

제 1 정규형이란?

> 스칼라 값 이외의 값을 포함하지 않는 테이블 

이라고 말할 수 있다.



#### 테이블은 함수다

제 1정규형의 정의는 이와같습니다. 그런데 왜 관계형 데이터베이스에서는 '복합적인 값'을 셀에 넣으면 안 될까요? 이 문제는 앞의 기본키 설명과 유사한데, 만약 복합적인 값을 허용하면 기본키가 있는 행의 값을 고유하게 특정할 수 없기 때문에 이것은 단적으로 기본키의 정의에 반하는 것입니다. 제 1정규형도 역시 **'레코드의 단일성을 보증한다'**라는 데이터 정합성의 관점에서 나온 규칙입니다.

그리고 이는 다음에 살펴볼 제 2정규형과 제 3정규형에서도 동일하게 들어맞습니다. 기본키를 특정하면 어떤 레코드의 열 값 전체가 고유하게 특정된다 라는 것을 바꿔 말하면 '기본키와 그 외의 열 사이에는 함수적인 관계가 있다'라는 뜻입니다.

수학에서 그리고 코드에서 배운것처럼 어떤 수식형태로 기술하는 것이 함수라는 것은 착각입니다.

**테이블 자체가 함수입니다.**



### 제2정규형(2NF)

제 1정규형을 만족한 상황에서 제 2정규형을 만족하지 않는 테이블을 예로 들면 다음과 같습니다.

| 고객기업ID | 주문번호 | 주문접수일 | 고객기업명 | 고객기업 규모 |
| ---------- | -------- | ---------- | ---------- | ------------- |
| CA         | O001     | 2014/12/20 | A 상사     | 대규모        |
| CA         | O002     | 2014/12/21 | A 상사     | 대규모        |
| CB         | O001     | 2014/12/12 | B 건설     | 중규모        |
| CB         | O002     | 2014/12/25 | B 건설     | 중규모        |
| CB         | O003     | 2014/12/25 | B 건설     | 중규모        |
| CC         | O001     | 2014/12/1  | C 화학     | 소규모        |

왜 제2정규형이 아닐까? **'부분함수 종속성'이라는 함수 종속이 존재하기 때문입니다.** **부분함수 종속은 간단히 말하면 '기본키를 구성하는 열의 일부에만 함수 종속이 존재하는 것'입니다.**

부분함수 종속은 간단히 말하면 '기본키를 구성하는 열의 일부에만 함수 종속이 존재하는 것'입니다.  
예를 들어, 다음과 같은 것이 함수 종속입니다.

> {고객기업 ID} => {고객 기업명}
>
> {고객기업 ID} => {고객 규모}

 기업의 이름은 기업ID만 안다면 고유하게 특정할 수 있습니다. 기업의 규모도 마찬가지입니다. 이 두 열에 한정해서 본다면 {주문번호} 열은 쓸데없는 정보일 뿐입니다. 주문번호를 안다고 한들 어떤 기업에서의 주문인지는 전혀 파악할 수 없습니다.

이와 같은 부분함수 종속이 존재할 경우 해당 키와 종속하는 열만 다른 테이블로 만들어 외부로 꺼내야 합니다.

**그럼 왜 제 2정규형은 필요한가?**

그런데 제2정규형은 무엇을 위해 만드는 걸까요? 이것은 제2정규형이 아닌 테이블을 실무에서 사용하는 경우에 어떤 불편과 위험이 발생할지를 생각해 보면 알 수 있습니다. 새로운 데이터를 갱신할 때 데이터 부정합을 '갱신 이상'이라고 합니다. 비정규형 테이블은 대체로 이 갱신 이상의 위험이 높은 테이블입니다. 그 이유는 테이블이 올바른 집합 단위에 기초를 두고 있지 않기 때문입니다. 관계형 데이터베이스에서 아름다운 테이블이란 바로 '기능적인 테이블'입니다.



### 제 3정규형(3NF)

고객기업 테이블(제 3정규형 아님!!)

| 고객기업ID | 고객기업명 | 고객기업규모 | 업계코드 | 업계명 |
| ---------- | ---------- | ------------ | -------- | ------ |
| CA         | A상사      | 대규모       | D001     | 석유   |
| CB         | B건설      | 중규모       | D002     | 건설   |
| CC         | C화학      | 소규모       | D003     | 바이오 |

이것은 당연히 제 1정규형은 만족하며 기본키가 '고객기업ID' 한 개의 열이라서 제 2정규형도 만족합니다.(기본키가 1개 열밖에 없는 경우 자동으로 제 2정규형을 만족하게 됩니다.)

하지만 이 테이블에도 역시 갱신이상이 존재합니다. 예를 들어, 앞으로 관리하고 싶은 업계는 석유,건설,바이오 외에도 시스템 또는 유통 등 다양하다고 해도 지금은 이 테이블에 해당 업계를 등록할 방법이 없습니다. 이 테이블이 '기업'이라는 단위의 집합을 반영하고 있어서 '유통'이라는 업계에 속한 기업과 거래를 하지 않은 이상 해당 업계의 레코드를 만들 수 없기 때문입니다.

이와 같은 사태가 발생한 이유는 이 테이블에도 한 개의 함수 종속, 즉 '추이함수 종속'을 가져왔기 때문입니다. 이것은 기본키 이외의 키 간에 발생하는 함수 종속으로 여기서는 다음의 종속성이 해당합니다.

> {업계코드} -> {업계명}

'추이함수 종속'에 '추이'라는 이름이 붙은 것은 2단계의 함수 종속이 존재하기 때문에

> {고객기업 ID} -> {업계코드} -> {업계명}

이와 같은 함수 종속도 제 2정규형과 동일하게 테이블을 나누어 외부로 빼놓아야 합니다.

고객기업 테이블

| 고객기업ID | 고객기업명 | 고객기업 규모 | 업계코드(FK) |
| ---------- | ---------- | ------------- | ------------ |
| CA         | A상사      | 대규모        | D001         |
| CB         | B건설      | 중규모        | D002         |
| CC         | C화학      | 소규모        | D003         |

| 업계코드 | 업계명 |
| -------- | ------ |
| D001     | 석유   |
| D002     | 건설   |
| D003     | 바이오 |

이제는 '업계 테이블'에 원하는 만큼 새로운 업계를 추가할 수 있다.

잘 이해가 안 간다면 '부분함 종속'과 '추이함수 종속'을 머리에 새겨두고 기계적으로 테이블을 나누기 바랍니다. 이렇게 해야 이해가 쉽다고 합니다.

## ER다이어그램

### 너무 많아진 테이블을 어떻게 할까?

정규화를 수행하면 테이블이 나누어져 그 수가 증가합니다. 특별히 테이블 수를 늘리는 것이 정규화의 목적은 아니고 어디까지나 '갱신 이상'의 위험을 없애는 것이 목적이지만, 결과적으로 테이블 수가 늘어나는 것도 사실입니다. 복잡한 업무 시스템이라면 테이블 수는 수백 개에 달합니다.

이런 테이블 간의 관련성을 한눈에 알 수 있게 고안된 기술이 ER다이어그램입니다. Entitiy(엔티티, 실체)란 '테이블','Relationship(릴레이션십, 관계, 관련성)'이란 '테이블 간의 관계'을 의미합니다. 이를 표시하는 데 그래픽으로 이해하기 쉽도록 해주는 기술이 ER다이어그램입니다.

### IE표기법이란?(Information Engineering)

이것은 ER다이어그램을 그리는 방법으로는 대중적인 데다가 알기 쉽고 직관적으로 이해하기 쉬운 이점이 있어서 처음 ER다이어그램을 배울 때 적합합니다. 또한 다른 ER다이어그램의 표기법도 다소 차이는 있지만, 기본적으로는 IE와 공통점이 많아서 한 표기법을 기억하면 후에 다른 표기법도 이해하기 쉽다.

### 엔티티란?

엔티니는 간단히 설명하면 테이블과 같고, 다음과같은 사각형으로 표시한다.

**업계테이블**

| 업계코드(PK) |
| ------------ |
| 업계명       |

### 릴레이션이란?

테이블을 엔티티의 사각형으로 대체한 것만으로는 대단하다고 할 수 없다. 아직 엔티티 간의 관련성이 묘사되어 있지 않기 때문에 이것은 이른바 서로 간에 무관계한 엔티티를 나열만 한 ER다이어그램에 지나지 않습니다.

엔티티간의 관련성을 표현하는 것이 앞에서 설명한 '외래키의 존재'입니다. 외래키가 존재하는 테이블은 해당 열이 다른 테이블의 기본키 열을 참조하는 것을 의미합니다. 이 관련성을 '릴레이션십'이라고 합니다. 이 열에서는 업계 테이블과 고객기업 테이블과의 사이에서는 

'일대다'의 관계가 존재합니다. 이것은 업계 테이블과 고객기업 테이블과의 사이에서는 '일대다'의 관계가 존재합니다.

###실제로 ER다이어그램을 작성해보자

### 2가지 중요한 핵심

테이블 설계에서 가장 중요한 것은 '테이블이 집합인 것'과 '테이블이 함수인 것'을 이해하는 것입니다. 이 2가지의 핵심만 머리에 넣어 둔다면 정규화나 ER다이어그램에 관한 세세한 이야기는 전부 잊어도 상관없다. 정규화나 ER다이어그램은 테이블이 집합이며 함수라는 것을 재확인하기 위한 보조적인 기법, 사고의 보조선에 지나지 않습니다. 핵심만 기억하고 있다면 나중에는 얼마든지 으용할 수 있고, 언제든지 관련된 실마리를 끌어낼 수 있습니다.