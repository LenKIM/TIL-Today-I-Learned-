## 연산 장치

```XML

Chapter 06 연산장치 ? 197 
1 연산장치의 개요 ? 199 
1 연산장치와 레지스터 파일 ? 199 
2 산술장치와 논리장치의 통합 ? 201 
3 플래그 레지스터 ? 202 

2 정수의 덧셈 ? 204 
1 덧셈 연산 ? 204 
2 덧셈?뺄셈장치 ? 206 

3 정수의 곱셈 ? 208 
1 곱셈 연산 ? 208 
2 시프트-덧셈 방식의 곱셈 연산 ? 209 
3 Booth 알고리즘 ? 213 
	
4 정수의 나눗셈 ? 217 
1 나눗셈 연산 ? 217 
2 복원 알고리즘 ? 218 
3 비복원 알고리즘 ? 221 

5 부동 소수점의 연산 ? 224 
1 부동 소수점의 덧셈 ? 224 
2 부동 소수점의 곱셈과 나눗셈 ? 225 
3 가드 디지트 ? 227 
요약 ? 229 
연습문제 ? 230 
```

**연산장치의 개요**

산술 논리 연산장치(ALU)를 줄인 말로 실행장치. 연산 장치는 덧셈, 뺄샘 같은 산술연산과 AND, OR같은 논리 연산을 수행하므로 산술 - 논리 연산산기를 기본적으로 가지고 있으며 시프터, 보수기 등도 포함할 수 있다.



연산장치는 산술장치와 논리장치를 합쳐서 연산 장치라 한다. 연산 중 발생하는 상태를 보관하는 레지스터가 플래그 레지스터
오버플로우, 반올림, 양/음 부호 다양하게 있다.

**정수의 덧셈**

덧셈 연산은 잉여 비트는 무시하는데 그 이유가 부호 비트와 동일하여 1비트 부호 확장한 것과 마찬가지이기 때문에.



  1 1 0 1

+1 0 1 0

10 1 1 1 

맨 앞에 잉여 비트를 무시하면, 7이 나와버림. -9가 나와야하는데, 이유는 오버플로우가 나기 때문에.

4개의 비트로 표현가능한 2의 보수는 -8부터 7까지 이기 때문에.



**정수의 곱셈**



1. 곱샘 연산

   - 종이-연필 방식

2. 시프트-덧셈 방식의 곱셈 연산

   - 종이-연필 방식에서 누적으로 곱하는 것.

     ![](https://ws3.sinaimg.cn/large/006tNc79gy1fmf483irouj309c04wglk.jpg)

   위 방식을 한 줄씩 컴퓨터가 계산하는 것.

3. Booth 알고리즘

   ![](https://ws2.sinaimg.cn/large/006tNc79gy1fmf4pz4hrej31ke0yuwka.jpg)

   **이진수 빼기 계산 과정 확인하기**



**정수의 나눗셈**

몫과 나머지 두 가지로 표현 됨.

나머지는 제수보다 크지 않기 때문에 나머지의 길이는 제수의 길이와 동일하게 설정될 수 있다. 그러나 다음과 같은 이유로 피제수는 제수를 구성하는 비트 수의 2배가 될 수 있다. 

D = Q x V + R (단, 0 <= R < V )

여기서 Q가 n비트 라면 D는 2n 비트이다. 

1. 복원 알고리즘
   똑똑하고 직관적인 인간과 달리 컴퓨터는 피제수에서 제수를 빼기 전에는 어는 것이 큰지 알수 없다. 
   복원 알고리즘은 만약 나머지 값이 음수(1)가 나온다면 다시 복원해서 계산해야 한다.

   ![](https://ws3.sinaimg.cn/large/006tNc79gy1fmf5lx5l2ej30t417u4qp.jpg)

2. 비복원 알고리즘

 복원알고리즘에서 복원하는 부분의 연산을 무시하는 방식이다.

아래 그림을 보고 이해해보자.

![](https://ws2.sinaimg.cn/large/006tNc79gy1fmf5xexe0aj31e623qaif.jpg)![](https://ws3.sinaimg.cn/large/006tNc79gy1fmf5xila3pj31kw1xytsh.jpg)



**부동 소수점의 연산**



1. 부동 소수점의 덧셈
   1.010(2) x 2^-1 + 1.111(2) x 2^-2. 
   [1] 지수 정렬 1.010(2) x 2^-1 / 0.111 x 2^-1. 
   [2] 가수 덧셈 10.001(2) x 2^-1. 
   [3] 정규화 1.0001(2) x 2^0. 
   [4] 오버플로우 점검 -> 정규화 과정에서 지수가 증가하거나 감소할 수 있다. 이때 지수가 지수 필드에 적합한지 확인. 
   [5] 자리 맞춤  -> 주어진 유효 자리 수만큼만 표현할 수 있기 때문에 4비트를 초과하는 비트는 절삭하거나 반올림.  
   즉 1.000 x 2^0 즉, 1. 

2. 부동 소수점의 곱셈과 나눗셈. 
   종이-연필 방식과 유사한데,   
   곱셈연산의 경우, 지수끼리는 더하고 가수끼리는 곱한다. 그러나 부동 소수점 수이기 때문에 지수 문제와 정규화, 오버플로우등을 고려해야 한다.  
   $$
   1.010_2 * 2^-1 과 1.111_2 * 2^-2        의  곱셈 계산 과정
   $$
   ​

   [1] 지수 덧셈  
   : -1과 -2 를 더하면 -3 근데 127초과 코드이므로 127을 더한다.  
   (-1+127) + (-2+127) = 124. 
   [2] 가수 곱셈. 
   : 1.010(2) X 1.111(2) = 10.010110(2). 
   [3] 정규화. 
   : 1.0010110(2) x 2^-2. 
   [4] 오버플로우 점검. 
   : 정규화 과정에서 지수가 증가하거나 감소할 수 있다. 지수가 너무 커서 적합하지 않은 경우에 오버플로우로 예외처리. 
   [5] 자리 맞춤. 
   : 유효 자리를 맞춰 정밀도 처리하면 마지막 네자리 절삭. 
   1.001(2) x 2^-2. 
   [6] 부호 결정. 
   :피승수와 승수 모두 동일한 부모이므로 양수.  
   $$
   1.010_2 * 2^-1 과 1.111_2 * 2^-2        의  나머지 계산 과정
   $$
   지수끼리는 뻴셈을 하고 가수끼리는 나눗셈을 하면 된다. 여기서 유의할 점은 지수 뺄셈을 할 때는 곱셈과는 달리 초과수를 더해야 한다는 것?   

   **위에서는 각각의 지수에 127을 더하고 더한 값에 더함을 했다면, 뺄셈에서는 초과수를 한 번 더 더해야 한다.**  

3. 가드 디지트. 

   가드 디지트는 분수에 대한 유효 자리의 오른쪽에 위치한 자리로, 부동 소수점 연산의 정확도를 향상하기 위한 기법. 가드 디지트는 정규화 과정에서 오른쪽으로 시프트할 때 발생하는 손실을 막기 위해 사용된다.  

   ​

   정수는 주어진 범위 내의 수를 정확하게 나타낼 수 있지만 부동 소수점 수는 많을 수를 근삿값만으로만 나타낼 수 있다. 따라서 가능하면 연산 결과를 정확한 근삿값으로 나타내는 것이 바람직하다.  

   ----

   연산 과정에서 발생하는 상태를 레지스터에 저장한다.  

   ​

   ## 데이터 경로

   ​



1. 단일 사이클 방식과 다중 사이클 방식. 

   16비트로 구성된 두 수를 덧셈하는 경우,
   단일 사이클 덧셈장치는 한 사이클동안 16개의 전 가산기를 사용하여 16비트를 더한다.  
   다중 사이클 덧셈장치는 하나의 가산기를 16번 사이클하여 16비트를 더한다.  
   CPU 실행 시간 = 명령어 개수 X 평균 CPI X 사이클 시간. 

   (명령어 1개) X (1사이클/명령어) X (16ns/사이클). 

   (명령어 1개) X (16사이클/명령어) X (1ns/사이클). 

   여기서 다중 사이클 덧셈장치에서는 플립플롭과 같은 저장장치를 무시했다.. 그러나 다중 사이클 덧셈장치는 하나의 전가산기를 동일한 명령어 수행과정 중에 여러 번 사용하므로 필수이다.  

2. ​



![](https://ws4.sinaimg.cn/large/006tNc79gy1fmf7yimpryj31kw0ren24.jpg)



![](https://ws4.sinaimg.cn/large/006tNc79gy1fmf7yonq5gj31ki0t8n2x.jpg)



단일 사이클 방식의 클록 사이클 시간은 명령어의 가장 느린 지연 시간과 동일하며, 다중 사이클 방식의 클록 사이클 시간은 가장 긴 단계의 지연 시간과 동일하다.. 파이프라이닝 기법을 사용하며 각 사이클마다 데이터 경로를 중첩 사용하려면 다중 사이클 방식을 도입해야 하며,  오늘날의 컴퓨터는 다중 사이클 방식의 데이터 경로를 사용한다.  



## 제어 장치

제어장치는 데이터 경로와 함께 CPU의 주요 구성 요소로서 명령어 장치라고도 한다.  

제어 장치는 메모리에서 명령어를 가져와 해독한 후 시스템 전체에 제어 신호를 보냄으로써 명령어의 지시대로 연산장치(ALU), 레지스터 파일, 메모리, 입출력장치가 동작하게 된다.  

- 명령어 해독 : 명령어의 연산 부호를 해독
- 제어 신호 생성 : 명령어의 연산 부호를 해독한 결과를 기능필드, 상태 레지스터, 외부 신호등과 같은 정보를 사용하여 명령어 실행에 필요한 제어 신호를 생성
- 제어 신호 인가 : 데이터 경로를 구성하는 각종 장치에 생성된 제어 신호를 인가함으로써 명령어가 지시하는 작업을 수행하게 한다. 예를 들어, 적제 혹은 저장 명령어라면 메모리의 읽기 혹은 쓰기 단자에 적절한 신호를 인가함으로써 메모리에 있는 데이터를 읽거나 메모리에 데이터를 기록한다.  



데이터 경로를 구성하는 기능 장치(메모리, 레지스터 파일 등)는 규칙적이지만 제어장치는 불규칙하고 전역적이다. 또한 제어장치는 데이터 경로와 달리 설계하기 어려울 뿐만 아니라 검증하기도 매우 복잡하다. 오늘날의 컴퓨터에서 사용하는 제어장치 구현방식은 크게 **고정결선식제어(hardwired control)**과 **마이크로프로그래밍 제어(miroprogrammed control)** 방식이 있다.  



#### 제어장치 구현의 두 가지 방식

- 고정결선식 제어 방식. 
  디코더를 통해 명령어 레지스터의 연산 부호를 해석한다. 그리고 조합논리회로가 디코더의 출력과 플래그 레지스터, 외부 장치의 신호 등을 이용하여 각 기능장치나 버스의 제어점을 적절한 제어 신호를 클록에 맞춰 제공한다.  

  고정결선식 제어장치를 구성할 경우, 명령어 구성이 복잡하거나 명령어의 수가 많아지면 조합 논리회로를 설계하거나 검증하기 매우 복잡하고 어려워진다. 따라서 오늘날의 컴퓨터는 조합 논리 회로 대신에 PLA를 사용하여 동등한 회로를 효과적으로 구현. 

  - 최적화할 수 있어서 일반적으로 제어 신호를 빠른 시간에 생성. 
  - ROM과 달리 불필요한 회로를 제거할 수 있으므로 칩의 크기가 작다.  

  현재에 더 많이 쓰이는데, 그 이유는 최근 RISC아키텍처의 출현으로 명령어 구성이 간단해지고 CAD기술의 발전으로 복잡한 회로 설계가 용이해짐에 따라 오늘날의 많은 컴퓨터는 고정결선식 방식을도입하고 있다.  

  ​

- 마이크로프로그래밍 제어 방식(펌웨어). 
  마이크로 연산을 수행할 수 있도록 마이크로 명령어를 PROM에 프로그래밍하는 방식이다. 모든 명령어는 연속된 마이크로 연산으로 분할되며, 일부 마이크로 연산은 동시에 수행될 수 있다. 여기서 동시에 수행되는 마이크로 연산의 집합을 마이크로 명령어 혹은 제어 단어라고 한다. 따라서 제어장치는 모든 연산에 대해 일련의 마이크로 명령어를 수행하는 컴퓨터 내의 또 다른 컴퓨터라고 할 수 있다.

  - 연산 부호가 바뀌거나 프로세서 상태가 추가될 경우 PROM에 수정된 내용을 프로그래밍하면 되므로 명령어 집합의 변경이 가능
  - 다른 종류의 명령어 집합을 에뮬레이션
  - 동일한 시스템에 다수의 명령어 집합을 구현
  - 컴퓨터의 구성, 타이밍, 기술의 변화에 쉽게 적응 가능.



#### PROM과 PLA

PLD(Programmable logic device)의 대표적인 2가지
**PROM(Programmable read only memory)와 PLA(Programmable logic array)**를 사용하여 제어장치를 실천.

ROM회로의 변종으로 프로그래밍 할 수 있다. PROM은 자주 사용되는 데이터를 영구적으로나 반영구적으로 보관하기 위한 메모리이다. PROM은 첫 번째 단계에서 디코더를 통해 모든 최소항을 생성한다. 두 번째 단계에서는 OR게이트를 사용하여 원하는 출력을 최소항의 합으로 구성한다.



PROM은 모든 종류의 최소항을 디코더로 생성하므로 최소항의 합을 사용하면 어떤 종류의 출력도 생성할 수 있다. 그러나 사용하지 않는 최소항도 생성하므로 낭비가 있을 수 있다.



PLA 첫 번째 단계에서 AND게이트를 사용하여 필요한 모든 곱의 항을 생성한다. 두 번째 단게에서는 OR게이트를 사용하여 전 단계에서 생성한 곱의 항에 대한 합으로 원하는 출력을 구성.



PLA는 PROM과 달리 AND게이트를 사용하기 때문에 불필요한 곱의 항을 생성할 필요가 없다. 따라서 동일한 기능일 때 PROM에 비해 작은 칩 공간을 사용한다. 하지만 출력신호를 변경하거나 추가하는 경우에 필요한 곱의 항이 없을 수도 있다.



. PLD는 프로그래밍이 가능한 논리장치로 프로그래밍이 가능한 전자 퓨즈선으로 연결된 게이트의 배열로 구성된 집적회로를 말한다.

2. PLD는 PROM, PAL, PLA의 세 가지 형태가 있으며, AND–OR 배열의 프로그래밍 가능 여부로 구별된다.

3. PLA는 ROM과 같은 기능을 수행하지만, ROM의 단점을 보완한 프로그래밍 가능한 논리장치로 모든 입력변수를 디코딩하지 않으며, 모든 최소항도 만들지 않는다.

4. PLA를 이용한 조합논리회로의 구현이란 PLA의 내부를 구성하는 AND–OR 게이트 배열을 프로그래밍한다는 것을 의미한다.

5. PLA를 이용한 조합논리회로를 구현하려면 조합논리회로의 논리를 나타내는 PLA프로그래밍표를 작성하면 되고, 작성된 프로그래밍표를 사용하여 PLA가 제작된다.



# # 스터디 문제들



1. ![](https://ws2.sinaimg.cn/large/006tNc79gy1fmgbof0xsnj30jw0h4jte.jpg)1.



**왜 제대로 된 값이 나오지 않는가?**

- 부동소수점의 표현 방식 때문입니다. 일반적으로 부동소수점의 표현이 다양하기 때문에 일괄되게 표현할 필요가 있었습니다. 그래서 IEEE 754에서는 부호비트, 지수비트, 가수비트로 나눠지는 총 32비트의 표현방식을 채택하였고, 채택된 데이터의 형식을 따라 표현하려다 보니 가수비트 부분에서 제대로된 값이 나오지 않아 정확히 1000.0이 나온것입니다.

  그럼 어떻게 하면 제대로된 값을 만들어 내려면 어떻게 해야 하는가?

  우리가 배운 가드비트너를 만들어 보는 것도 좋고

  이를 해결하기 위해서는 다음과 같은 과정을 거친다.

  1. 이진수 형태(base가 2인) 부동소수점보다는 십진수(base가 10)부동소수점을 사용한다.  
     : 이렇게 하면 정밀도 자리수에 따른 반올림 오류는 여전히 존재하겠지만 적어도 십진수를 이진수로 변환할 때 무한한 수가 되는 상황은 해결할 수 있다.  

  2. 정밀도가 보다 높은 부동소수점을 사용한다.  
     : Binary 32를 사용한다면 Binary 64를 decimal 64를 사용하면 128을 사용하면 정밀도가 높아지므로 연산에 의한 오차가 작아지게 된다.

  3.  가능하면 부동소수점 연산을 사용하지 않는다.  

     : 예를 들어 1.0 + 0.1 + 7을 계산해야한다고 하면 이를 모두 정수형태로 변형하기 위해 모든 수에 10을 곱하여 10 + 1 + 70으로 계산하고 계산된 결과를 다시 10으로 나누어 실수형태로 표현한다.



2. **범용 레지스터 컴퓨터 /최대 2개의 피연산자 사용 (2-주소 명령어)**

16개의 레지스터 사용
적재, 저장 명령어 컴퓨터(오늘날의 컴퓨터)
Y = ax + b 를 계산하여 메모리에 저장할 때 발생하는 명령어 인출 트래픽과 데이터 이동에 필요한 트래픽을 구해라
(레지스터 16개, 메모리 주소 2byte, 데이터 크기 4byte, 연산부호 1byte)







3. **코드의 결과 값은?**
   ​
   ![](https://ws2.sinaimg.cn/large/006tNc79gy1fmgbz39odnj30fg0hcabe.jpg)



메모리 정렬문제, 예상으로는 10바이트, 4바이트, 8바이트여서 총 22바이트가 나올 것이라 예상하지만

실제로는 24바이트가 나온다.



왜냐하면? 

![](https://ws2.sinaimg.cn/large/006tNc79gy1fmgch3mx9kj30tu0nwndf.jpg)



3. **리틀엔디언 과 빅 엔디언의 차이점과 각각의 차이는?**

   0x12345678을 빅엔디언 방식과 리틀엔디언 방식으로 나타내시오

   16진수

   12 34 56 78 -> 빅엔디언

   78 56 34 12 -> 리틀엔디언
   ​

4. **대부분의 아키텍처가 레지스터 직접 주소 지정방식을 택한 이유?**

   메모리의 주소보다 레지스터의 주소가 쓰는 공간이 더 짫기 때문이다.

   ​

5. **프로시저(함수) 호출 시 복귀주소는 어디에 저쟁해 두는가?**
   ​
   프로세스에서 스택 함수부분에 복귀주소를 저장해두고 하던 일을 멈추고 다시 복귀하면 확인할 수 있기 때문이다.
   예시)

   Int main(){

   ​	Int a = 1;

   ​	Int b = 2;

   ​	func(a,b);

   ​	//

   ​	Int c= 10;

   ​	return;

   }

6. 시프트 레지스터(Shift Register)에 있는 2진수가 5번 왼쪽으로 자리 이동되었다. 이때 수는?  
   32배가 된다.
   ​

7.  특정 비트의 값을 선택적으로 반전시키는 경우에 이용되는 경우  

   1) AND마스킹
   // 삭제

   2) OR 마스킹
   // 추가

   3) XOR 마스킹
   // 선택적 반전
   ​

8. 문제 6-2) CPU가 인스트럭션을 수행하는 순서로 옮은 것은?

   1. interrupt search 
   2. instruction decoding 
   3. instruction fetch 
   4. Operand Fetch 
   5. Execution 
      ​

   Fetch -> decoder -> operand fetch -> execution -> interrupt

9. 2의 보수 덧셈 연산에서 어떤 경우에 잉여비트를 무시할 수 있는가?

   부호비트와 잉여비트가 동일할 경우,
   만약 다르면 오버플로우.

   동일한 부호를 가진 두 수를 더할 때 부호 비트가 파괴되는 상황을 보여준다. 올림 C(in)과 출력 올림수C(out)이 서로 다를 때, 즉  C + C = 1일때 오버플로우가 발생하는 것을 알 수 있다.

   ​

10. Booth 알고리즘을 이용해서 6 * (-5) 연산을 하시오.  

   ![](https://ws2.sinaimg.cn/large/006tNc79gy1fmgd1v9wa3j313x0qb0zf.jpg)

   ​

11. PROM 은 (                         )의 출력을  (                          )의 입력과 연결,

    ​    PLA은 (                             )의 출력을 (                         )의 입력과 연결하는

    조합회로를 사용한다.

PROM은 디코더의 출력을 OR 게이트 배열의 입력과 연결하며,
PLA는 AND게이트배열의 출력을 OR게이트 배열릐 입력과 연결하는 조합회로이다.



12. 부호 확장과 제로 확장에 대해서 확실히 알기!
    http://air802.tistory.com/33

    ​