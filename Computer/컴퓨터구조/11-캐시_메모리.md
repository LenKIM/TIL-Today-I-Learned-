개요

CPU는 데이터를 처리하기 위해 메모리에서 데이터를, 처리한 데이터를 다시 메모리에 저장. 그러나 메모리는 CPU에 비해 속도가 매우 느리기 때문에 메모리에 접근할 때마다 CPU를 효율적으로 활용할 수 없기 때문에 이를 해결하기 위해 **CPU 캐시 메모리**를 활용한다. 



### 1. 적중과 실패

지역성의 원리에 따라 캐시 메모리의 성공 여부를 판단할 수 있다.  
지역성 원리란 짧은 시간 동안 제한된 주소 공간의 일부만 참조되는 경향을 말한다. 만약 프로그램의 작업 집합(working set) 대부분을 캐시 메모리에 포함된다면 CPU는 원하는 항목의 대부분을 캐시 메모리를 통해 얻을 수 있기 때문에 결과적으로 시스템 성능이 크게 향상 될 수 있다.

만약 캐시 메모리가 없다면?  
컴퓨터 시스템은 CPU가 명령어를 실행할 때마다 명령어와 데이터를 인출하기 위해 메모리에 접근해야 한다.  

그러나 있다면, 캐시 메모리가 있는 컴퓨터 시스템은 CPU가 먼저 캐시 메모리에 접근하여 원하는 명령어나 데이터의 존재 여부를 점검한다. 이때 원하는 항목이 캐시 메모리에 있을 경우 HIT, 없을 경우 MISS 라고 한다.  

적중률은 전체 메모리의 참조 횟수에서 캐시 메모리의 적중횟수를 나눈 값이다.

캐시와 메모리에서 HIT를 실패할 경우, 보조기억장치까지 계층까지 접근해서 처리한다.

- 보조기억장치에서 원하는 워드를 포함하는 페이지를 메모리에 복제
- 메모리에 복제된 페이지에서 원하는 워드를 포함하는 블록을 캐시 메모리에 복제
- 캐시 메모리에 복제된 블록에서 원하는 워드를 CPU 레지스터에 복제



### 2. 캐시 메모리의 기본 구성과 동작

CPU는 데이터(명령어 포함)을 요청할 때마다 데이터의 주소를 캐시 메모리에 보내고, 캐시 메모리는 해당 주소와 관련된 데이터의 존재 여부를 파악.  

캐시 메모리는 어떤 데이터를 포함하는지를 관리하기 위해 데이터 메모리뿐 아니라 태그 메모리(tag memory)를 사용한다.  
태그 메모리도 캐시 메모리의 일부분이지만, 캐시 메모리의 용량을 말할 때는 태그 메모리의 제외한 데이터 용량만을 의미한다.

데이터 메모리는 블록으로 구성, 블록은 워드의 집합으로 캐시와 메모리 간 데이터 전송의 기본 단위.

태그 메모리는 데이터 메모리의 블록을 탐색할 수 있는 정보를 포함하므로,  
태그 메모리의 각 엔트리는 데이터 메모리의 블록과 쌍을 이루면서 최소한 세 가지 정보(tag, valid bit, dirty bit) 포함. 또한 태그 메모리는 CPU주소와 태그를 비교하는 비교기를 가지고 있다.

\- 태그: CPU가 요청한 블록을 탐색하는 데 사용하는 주소 정보의 일부로 캐시 블록 주소에서 인덱스로 사용되지 않는 부분

\- 유효 비트 : 캐시 블록이 유효한 데이터인지 아닌지를 나타탬, 부팅될 때 모든 유효비트를 무효로 초기화

\- 갱신 비트 : 메모리에서 캐시로 블록을 가져온 후부터 CPU가 블록을 수정했는지 여부 나타냄



**캐시의 태그 메모리를 가장 우선적으로 탐색하고 히트한다면 블록 추출, 블록에서 데이터 선택.**  
**미스한다면, 주소를 메모리로 전송하여 대응하는 블록을 캐시에 저장.**

### 3. 캐시 메모리의 전략과 설계 논점

설계할 때 캐시 메모리의 용량과 블록 크기를 결정해야 하지만 **블록 사상 방식, 블록 교체 방식, 블록 갱신 방식** 등과 같은 전략을 정하는 것도 매우 중요하다.  

**블록 사상 방식** 캐시 블록과 메모리 블록을 대응시키는 방식으로 직접 사상, 완전 연관 사상, 집합 연관 사상

**블록 교체 방식**은 캐시 실패가 발행하고 캐시 메모리에 적절한 빈 블록이 없을 떄 사용 중인 캐시 블록 가운데 어느 것을 교체할지를 결정하는 방식으로 무작위, 선입 선출, 최소 최근 사용 등이 있다.

**블록 갱신 방식**은 캐시 메모리의 데이터가 수정되었을 때 대응하는 메모리 블록에 대한 갱신 시점을 결정하며, 즉시 쓰기와 나중 쓰기가 있다.

## # 블록 사상(블록 배치)

메모리에서 읽은 블록이 저장될 캐시의 위치를 결정하는 방법. 예를 들면 도매상에서 가져온 물건을 소매상이 어떻게 배치하느냐는 소비자의 구매에 큰 영향을 미친다. 마찬가지로 캐시의 블록사상방식도 캐시의 성능에 큰 영향을 미친다.

- 직접 사상 - 메모리 블록을 정해진 하나의 캐시에만 사상
- 완전 연관 사상 - 메모리 블록을 어떤 캐시 블록에도 사상
- 집합 연관 사상 - 직접 사상과 완전 연관 사상을 절충한 방법으로, 메모리 블록을 정해진 블록의 집합 내 에디든지 사상



**메모리에서 읽은 블록(데이터 정보)이 저장될 캐시의 위치를 결정하는 것이 블록 사상**

ex) 빅엔디언 기반으로 512바이트의 메모리와 128바이트의 캐시를 가지고 있다. 그리고 블록 크기는 16바이트, 워드 크기는 4바이트로, 즉 메모리는 32개의 블록, 캐시는 8개의 블록 포함  
다음은 메모리와 캐시의 대한 주소 구성이다.

- 메모리는 512(= 2^9)바이트 이므로 바이트 주소로는 9비트가 필요하고, 메모리 블록이 32( = 2^5)개이므로 블록 번호로는 5비트가 필요하다.
- 캐시는 128(=2^7)바이트이므로 바이트 주소로는 7비트가 필요하고, 캐시 블록이 8(=2^3)개이므로 블록 번호로는 3비트가 필요
- 메모리나 캐시에서 하나의 블록을 동일하게 16(2=^4)바이트이므로 블록 오프셋은 4비트. 블록 내에서 1바이트를 선택하려면 블록 오프셋 4비트를 사용하고, 1워드를 선택하려면 블록 오프셋의 상위 2비트를 사용하면 된다.

// 무슨 말?

32개의 메모리 블록을 8개의 캐시 블록에 배치해야 하므로 메모리 블록 번호 5비트를 캐시 블록 번호 3비트로 사상해야 한다.  
이때 캐시 메모리는 블록 단위로 데이터를 취급하므로 블록 오프셋이 필요 없지만, CPU는 워드 단위로 데이터를 취급하므로 선택된 블록에서 원하는 데이터를 추출하려면 블록 오프셋을 사용해야 한다.

#### 직접 사상

모듈로 연산을 사용하여 메모리 블록을 정해진 캐시 블록에만 사상하는 방식.

`캐시 블록 번호 = 메모리 블록 번호 mod 캐시 블록 개수.`  

위 예제에서 캐시 블록이 8개이므로 사상된 캐시블록 번호는 메모리 블록 번호를 8로 나눈 나머지 값.  
2진법에서 8로 나눈 후 나머지 값을 구하는 것은 마지막 비트 세 자리를 구한다는 의미이다. 이는 메모리의 블록 주소 5비트 중에서 하위 3비트를 추출하는 것을 말하며, 상위 2비트는 몫에 해당하므로 캐시 블록 번호와 무관하다. 따라서 직접 사상은 모듈러 연산의 결과인 하위 3비트를 사용하여 메모리 블록을 캐시 블록으로 사상. 캐시 블록의 위치는 메모리 블록 번호의 마지막 3비트 정보를 내포한.

**메모리의 9비트는 상위 2비트는 태그, 중간 3비트는 인덱스 필드(캐시 블록 번호), 하위 4비트는 블록 오프셋을 가리킴.**

// TODO 동작 방식 이해

직접 사상은 태그의 길이가 짧고, CPU태그를 하나의 캐시 태그와 비교하기 때문에 하나의 비교기만 있으면 된다. 또한 메모리 블록이 사상될 캐시 위치가 선택의 여지 없이 하나의 블록으로 정해져 있기 때문에 교체 방식이 필요 없다. 따라서 하드웨어 구현이 단순하고 접근 속도가 빠르다. 그러나 적중률이 나쁜데, 특히 동일한 캐시 블록에 사상되는 다른 메모리 블록을 번갈아가면서 참조할 때 캐시 블록에 심각한 충돌을 발생하여 적중률이 급격히 떨어진다. 그래서 **대용량 캐시 메모리일 경우 주로 직접 사상 방식 사용**



#### 완전 연관 사상

메모리 블록이 어느 캐시 블록에도 사상될 수 있는 방식으로, 캐시 블록을 정할 수 있는 인덱스 필드가 없다. 캐시 블록 번호는 메모리 블록 번호와 전혀 무관하여, 메모리 블록의 어떤 정보도 포함하지 않는다. 그러므로 완전 연관 사상은 캐시 블록이 어느 메모리 블록에 대응하는지 식별하기 위해 메모리 블록 번호 5비트를 모두 캐시 태그로 사용. 만약 메모리 블록 011000이 캐시 블록 번호 100에 복제되었다면 캐시 블록 번호 100에 대응하는 캐그는 01100이다.

**9비트중, 상위 5비트는 메모리 블록 번호이면서 태그, 나머지 4비트는 블록 오프셋**

// TODO 동작 방식 이해

완전 연관 사상은 CPU가 요청한 메모리 블록이 어느 캐시 블록에도 있을 수 있다. 따라서 에제 컴퓨터의 경우 CPU가 요청한 태그를 모든 캐시 태그와 병렬로 비교해야 하므로 8개의 비교기가 필요하다. 직렬로 비교하면 비교하는 시간이 길어져 대부분의 완전 연관 사상은 많은 캐시 태그와 메모리 태그를 신속하게 비교하기 위해 고가의 연관 메모리를 사용한다. 완전 연관 사상은 태그의 길이가 길기 때문에 직접 사상에 비해 속도가 느리지만, 소용량의 캐시 메모리를 사용하더라도 높은 적중률을 보인다.



#### 집합 연관 사상

 위 2개의 사상을 절충한 방식. 직접 사상처럼 정해진 장소에만 사상될 수 있으나 완전 연관 사상처럼 정해진 장소 내에서는 어느 캐시 블록에든 사상될 수 있다. 그런데 직접 사상은 정해진 장소가 하나의 블록이지만 집합 연관 사상은 2개 이상의 블록으로 구성된 집합. 캐시 집합의 크기가 2개 블록이라면 2-방향 집합 연관 사상. 또는 집합 연관도(set associativity)가 2. 2-방향 집합 연관 사상은 2개의 캐시 블록 중 어디에든 메모리 블록을 사상할 수 있고, 만약 4-방향 집합 연관 사상이라면 4개의 캐시 블록 중 어디에든 메모리 블록을 사상할 수 있다. 집합 연관 사상은  
`캐시 집합 번호 = 메모리 블록 번호 mod 캐시 집합의 개수`

예제 컴터의 캐시블록은 8개. 2-방향 집합 연관 사상이라면 집합의 크기가 2개 블록이므로 캐시 집합의 개수는 4개. 따라서 메모리 블록을 캐시 집합에 사상하려면 메모리 블록 번호를 4로 나눈 나머지 값을 사용.

**9개의 비트 중 상위 3개는 태그 비트, 중간에 2개의 비트는 인덱스 필드(캐시 집합 번호), 나머지 4개는 블록 오프셋이다.**

## 블록 교체와 블록 갱신

CPU의 요청으로 캐시와 메모리 사이의 블록을 전송할 때 다양한 전략 필요.  
정해진 캐시 블록이 이미 사용 중이거나 캐시 블록 전체가 사용 중일 때는 블록 사상 방식에 따라 메모리 블록을 캐시 블록에 사상할 수 없으므로 이에 대한 대책 필요. 또한 CPU가 캐시 블록을 수정할 때 메모리의 일관성을 유지하기 위한 대책도 필요.



#### 블록 교체 방식

캐시의 모든 블록이 사용 중인 경우에도 CPU가 요청한 새로운 메모리 블록이 캐시에 사상될 수 있다. 또한 일부 캐시 블록이 비어 있더라도 CPU가 요청한 새로운 메모리 블록을 블록 사상방식에 따라 이미 사용중인 캐시 블록에 사상할 수도 있다. 이런 경우에 캐시는 이미 사용중인 캐시 블록의 내용 중 하나를 선택하여 메모리로 내보내어 CPU가 요청하는 새로운 메모리 블록이 사상될 공간을 마련해야 한다. 따라서 어느 캐시 블록을 비울 것인지 결정하는 블록 교체 방식이 필요하다.



이상 적인 블록 교체 방식은 가장 오랫동안 참조되지 않을 블록을 교체하는 빌래디의 MIN알고리즘. 이 방식은 미래를 예측해야 하므로 하드웨어로 구현될 수 없으며, 다른 블록 교체 방식과 비교할 기준으로만 사용.

- **최소 최근 사용** - 모든 블록에 대해 최근에 참조된 정보를 포함해야 하므로 구현 비용 높음
- **무작위 형식** - 구현 비용이 저렴하고 간단 그러나 효율성 보장 못함
- **선입 선출(FIFO) 방식**  - 캐시 메모리에 먼저 적재된 블록을 먼저 축출함으로써 캐시 메모리 공간을 준비하는 방식



#### 블록 갱신 방식

캐시를 사용하는 시스템은 동일한 데이터가 최소한 두 장소(캐시와 메모리)에 존재한다. CPU가 데이터 쓰기 연산을 수행하면 일반적으로 캐시에 있는 내용부터 수정. 그러나 캐시의 내용만 수정한다면 수정된 캐시 블록이 블록 교체 방식에 의해 축출될 때 수정 내용이 손실 될 수 있다. 그러나 캐시의 내용만 수정한다면 수정된 캐시 블록이 블록 교체 방식에 의해 축출될 때 수정 내용이 손실될 수도 있다. 따라서 CPU의 쓰기 요청을 메모리에도 반영하여 캐시와 메모리의 데이터를 일치시켜야 하는데, 이를 블록 갱신 방식 또는 블록 쓰기 방식이라고 한다.

- **즉시 쓰기 방식(Write-through) 방식** : 캐시 블록에 쓰기 연산을 수행할 때 메모리에도 수정 내용을 전달하여 쓰기 연산을 함께 수행하는 것으로 즉시 복사 방식이라고도 한다. 따라서 메모리는 항상 캐시의 모든 블록에 대한 유효 복사본을 갖는다. 이는 다수의 캐시를 가진 다중 프로세서 시스템이라면 데이터 일관성 유지 문제를 단순화하지만, 쓰기 연산을 수행할 때마다 메모리를 수정해야 하므로 메모리 트래픽이 커지고 속도도 느려진다.
- **나중쓰기(Write-back) 방식** : 수정된 캐시 블록이 교체되는 경우나 CPU 사이클이 대기 상태인 경우에 수정된 캐시 블록의 내용을 메모리에 반영하는 것으로 나중 복사방식이라고도 한다. 이때 캐시 블록의 수정 여부를 표시하기 위한 갱신 비트가 필요하다. 수정된 캐시블록이 교체되기 전까지는 캐시에만 쓰기 연산을 수행하므로 속도가 빠르고 메모리 트래픽이 줄어든다.  따라서 CPU칩에 내장되는 캐시는 주로 나중 쓰기 방식을 사용하지만, 메모리 블록과 캐시 블록에 일하지 않는 데이터를 포함할 수 있다. CPU와 캐시에 문제가 있을 때는 메모리의 내용을 복구할 수 없는 경우가 발생할 수 있다. 특히, 입출력장치가 데이터를 요청할 때 캐시와 메모리 중 어느 곳이 유효한 데이터를 제공할 수 있는지 살펴봐야 한다.

## 캐시 메모리를 통한 성능 향상

캐시 메모리의 성능을 평가하는데, 적중률과 적중 시간을 사용하기도 하지만, 궁극적으로는 유효 접근 시간(effective access time) 이 절에서는 유효 접근 시간을 비롯해 유효 접근 시간을 최소화할 수 있는 다양한 방법을 봅시다. 또한 캐시 용량, 블록 크기, 캐시 연관도의 변화에 따라 캐시 메모리의 성능에 영향을 미친다.

#### 1 캐시 실패의 우형

캐시 메모리 실패의 3가지 요소 - 3C 라고도 한다.

- **강제 실패(compulsory miss)**
  : 모든 메모리 블록의 최초 접근에 의해 발생하는 실패를 말하며, 필수 실패, 초기 실패, 최초 참조 실패라고도 한다. 캐시 용량과 연관도는 강제 실패의 횟수와 무관하며, 블록 크기를 크게하거나 선인출 정책을 사용함으로써 강제 실패를 줄일 수 있다.
- **용량실패(Capacity miss)**
  : 캐시 메모리의 유한한 용량 때문에 발생하는 실패를 말하며, 블록이 교체된 후 나중에 다시 그 블록을 가져올 때 발생
- **충돌 실패(Collision miss)**
  : 집합 연관 사상이나 직접 사상의 경우에 다수의 블록이 동일한 집합이나 블록에 사상되기 때문에 발생하는 실패.

#### 2 유효 접근 시간

**적중률이 높은 것이 캐시 메모리의 성능 척도를 나타내기도 하지만, 유효 접근 시간이 작을수록 더욱 효율성이 높다고 할수 있다.**

// 계산 방식



#### 3 캐시 메모리의 성능 개선

메모리 계층 구조의 궁극적인 목적은 유효 접근 시간을 줄이는 것. 그러려면 **실패율, 실패 패널티, 적중 시간**을 줄여야 하는데 이 세가지 요소는 서로 상충.

각각의 요소들이 어떻게하면 성능을 개선할 수 있을까?

- 실패율
  : 실패율을 줄인다는 것은 강제 실패, 충돌 실패, 용량 실패를 줄인다는 의미.
  강제 실패를 줄이려면 블록을 크게, 충돌 실패를 줄이려면 연관도를 높이며, 용량 실패를 줄이려면 캐시 용량을 크게한다.
  이 외에도 컴파일러를 통해 프로그램을 최적화하고, 요구 인출 정책 대신에 선인출 정책으로 미래에 접근할 블록을 미리 캐시 메모리에 준비하는 방법 등을 이용하여 캐시 실패율을 줄일 수 있다.
- 실패 패널티
  : 메모리의 성능과 밀접한 관계. 메모리 대역폭을 향상하는 광폭버스 메모리, 교차 메모리등은 실패 패널티를 줄이며, 캐시와 메모리 사이의 전송 단위인 블록의 크기를 즐이면 블록의 전송 시간이 줄어들어 실패 패널티를 줄일 수 있다. 이 외에도 조기 재시작, 중요 워드 우선등의 방법이 있다.
- 적중 시간
  : 적중 시간을 향상하려면 소용량 캐시 메모리, 직접 사상, 캐시 메모리 접근의 파이프라인화 등과 같은 방법을 사용할 수 있다. 캐시 용량이 작으면 적중 시간이 짧아지고, 직접 사상은 태그 비교 시간이 짧기 때문에 캐시 메모리의 적중 시간을 줄일 수 있다. 그리고 캐시 메모리 접근을 파이프라인화하면 접근 시간의 일부를 숨길 수 있으므로 적중 시간이 짧아진다.

#### 4 블록 크기, 캐시 용량, 캐시 연관도

캐시 메모리의 성능을 결정하는 중요한 설계 요인으로 블록 크기, 캐시 용량, 캐시 연관도도 있다.

| 설계 요인  | 크게 하거나 높일 경우                    | 작게 하거나 낮출 경우                    |
| ------ | ------------------------------- | ------------------------------- |
| 블록 크기  | 적중률 상승, 실패 패널티 중가, 태그 메모리 부담 감소 | 적중률 감소, 실패 페널티 감소, 태그 메모리 부담 상승 |
| 캐시용량   | 하드웨어 부담 증가, 적중 시간 증가            | 하드웨어 부담 감소, 용량 실패와 충돌 실패 증가     |
| 캐시 연관도 | 적중률 상승, 적중 시간 증가                | 적중률 감소, 적중 시간 감소                |