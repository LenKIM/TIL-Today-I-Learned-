- 컴퓨터 부팅과정
  1. 컴퓨터에 전원을 인가하면 ROM에 저장된 BIOS가 실행된다.
  2. BIOS는 CPU, 메인 메모리, 하드 디스크와 같은 각종 하드웨어의 상태를 검사한 후 이상이 있으면 오류를 통지하고 동작을 멈춘다.
  3. BIOS는 부팅 메체인 하드디스크에 저장된 부트스트랩 로더를 메인메모리로 옮긴다. 2개 이상의 부팅 매체를 지정하여 BIOS로 하여금 운영체제를 선택하도록 할 수도 있는데, 이를 멀티 부팅이라고 한다.
  4. 부팅로더는 BIOS를 종료하고 하드디스크에 저장된 운영체제를 메인 메모리에 적재한 후 운영체제에 제어권을 넘긴다.
  5. 운영체제는 응용 소프트웨어의 실행 환경을 조성한다.
  6. 부트로더가 하드디스크에 있는 운영체제 커널을 찾아 RAM에 적제한다.
  7. 부트로더는 제어권을 운영체제에게 전달한다.
- 컴파일러와 인터프리터
  1. 컴파일러는 고급언어로 작성된 원시 프로그램을 저급언어로 구성된 목적 프로그램으로 변환하는 소프트웨어
  2. 인터프리터는 고급언어에서 하나의 명령을 분석하여 동일한 효과를 가진 저급언어로 명령어로 변환한 후 적브언어 명령어를 실행시키며, 전체 프로그램이 실행될 때까지 이 과정을 반복하는 소프트웨어
- RISC와 CISC
  RISC는 일반적으로 단순한 명령어로만 구성된 명령어 집합으로 명령어의 종류가 적다. 그러나 CISC는 일반적으로 단순한 명령어뿐만 아니라 복잡하고 강력한 명령어까지 포함하므로 명령어의 종류가 많다.
- CPU 성능은 명령어 개수, 평균 CPI, 클록 사이클 시간에 의해 결정된다.
  명령어 개수는 프로그램의 크기, 평균 CPI는 하나의 명령어를 싱행하는 데 필요한 평균 클록 사이클의 수, 클록 사이클 시간은 하나의 클록 사이클에 소요되는 시간을 의미한다.
- 무어의 법칙 : 마이크로칩 기술의 발전 속도를 예측해서 18개월마다 약 2배씩 증가한다는 것을 의미
- 하버드 아케텍쳐 / 폰 노이만 아키텍처
  메모리를 2개로 분할하여 명령어와 데이터를 별도의 메모리에 저장.
  CPU의 제어장치와 연산장치를 별도의 버스로 각각 연결하여 명령어와 데이터를 병렬로 인출



![](https://ws3.sinaimg.cn/large/006tNc79gy1fmevh0sla6j30sg0iiwia.jpg)





#### 명령어 집합

CPU가 수행할 동작을 2진수 코드로 정의한 것. 일반적으로 2진수 코드 대신에 연상 부호를 사용한 어셈블리 형태의 명령어로 표현.



#### 명령어 집합 구조?

- 컴퓨터 하드웨어가 어떤 연산을 수행할 수 있고, 각 연산에 어떤 데이터가 필요한지를 명시한다.
- 사용할 수 있는 데이터의 표현 방식, 즉 데이터 형식을 명시한다.
- 데이터의 위치에 대한 정보를 알려주는 주소 지정 방식을 명시한다.

#### 명령어 인출 / 실행 사이클

#### 명령어와 CPU 기억장치

- 연산부호 크기는 8비트, 즉 1바이트
- 연산마다 최대 2개의 피연산자 필드
- 첫 번째 피연산자 필드는 근원지 및 목적지 겸용
- 메모리 주소는 16비트, 즉 2바이트
- 데이터 크기는 32비트, 즉 4바이트

이 말의 뜻은? 명령어가 최대 2^8개, 즉 256개, 데이터는 4바이트 단위로 취급하기 때문에 워드 크기가 4바이트
메모리 주소가 16비트이므로 최대 2^16워드 용량의 메모리를 사용할 수 있다는 의미.

y = ax^2 + bx + c 일 경우?
Mov y, a < y <- M[a]

Mul y, x < y 



#### 메모리 트레픽 계산 방법?

#### CPU 내부에 소규모 기억장치가 있으면 폰노이만 병목에 발생하는 트래픽을 감소시킬 수 있다. 왜? 반복적으로 사용되는 데이터를 위한 메모리 접근을 줄여주고, 명령어의 길이가 축소되어 명령어 인출을 위한 트래픽이 감소되기 때문입니다. 



반복적으로 사용되는 데이터를 위한 메모리 접근을 줄여주고, 명령어의 길이가 축소되어 명령어 인출을 위한 트래픽이 감소도기 때문입니다.



#### 엔디언 방식

여러 개의 연속된 대상을 1차원 공간에 배열하는 방법.

예를 들어, 32비트 컴퓨터의 경우, 메모리 워드에 32개의 비트를 배열하거나 4개의 바이트를 배열하는 방법.

일반적으로 엔디언은 바이트를 배열하는 후자에 의미, 엔디언 방식에는 비트, 바이트, 워드의 순서는 어느 방법이든 성능에 차이가 없다. 그러나 컴파일된 실행 파일을 다른 아키텍처로 이식할 때는 워드 내부의 비트 혹은 바이트의 순서가 달라지기 때문에 의미가 있다.

바이트를 메모리 워드 내부에서 배열하는 방식은 다양하지만 주로 빅엔디안, 리틀 엔디언 방식 사용

빅 엔디언 방식은 왼쪽에서 오른쪽으로 바이트를 배열하는 것 -> 사람이 숫자를 쓰는 방법과 마찬가지로 큰 단위의 바이트가 앞자리에 위치한다. 이 방식에서는 각 워드의 최대 유효 비트(MSB) 가 포함된 바이트의 주소가 워드 주소가 된다.

리틀 엔디언 방식은 빅 엔디언 방식과 반대 방향으로 바이트를 배열하므로 작은 단위의 바이트가 앞자리에 위치하여 각 워드의 최소 유효 비트가 포함된 바이트의 주소가 워드 주소가 된다. 각 워드의 주소는 빅 엔디언의 경우 가장 왼쪽 바이트의 주소이고, 리틀 엔지언의 경우 가장 오른쪽 바이트의 주소이다.



### 주소 지정 방식

#### 0-단계 주소 지정 방식

데이터가 있는 위치를 파악하기 위해 특별한 과정이 필요 없는 방식으로 데이터의 유효 주소를 명시하지 않는다.

1. 즉시 주소 지정 방식
2. 묵시 주소 지정 방식



![](https://ws2.sinaimg.cn/large/006tNc79gy1fmeyur9e9oj31ey0meq5i.jpg)

#### 1-단계 주소 지정 방식

데이터의 위치, 즉 유효 주소를 확정하기 위해 주소 계산이나 읽기 연산 과정을 한 번 수행하는 방식.

![](https://ws3.sinaimg.cn/large/006tNc79gy1fmeyyk14exj31kw0pq78c.jpg)

#### 2단계 주소 지정 방식

데이터의 유효 주소를 확정하기 위해 주소 계산이나 읽기 연산 과정을 두번 수행. 이 방식은 데이터가 메모리에 저장되므로 많은 데이터의 위치를 명시할 수 있다. 그러나 데이터의 주소를 확정하기 위해 2-단계 과정을 거쳐야 하므로 0-단계 혹은 1-단게 주소 지정방식보다 데이터를 참조하는데 더 많은 시간이 걸린디ㅏ,



![](https://ws4.sinaimg.cn/large/006tNc79gy1fmeyuj2hdaj30q219gn1p.jpg)







#### CISC(complex instruction set computer 복합 명령어 집합 구조)  

#### 와 RISC(reduced instruction set computer 축약 명령어 집합 구조)의 차이 



![](https://ws4.sinaimg.cn/large/006tNc79gy1fmez51u76oj31kw0txteg.jpg)



질문

1. 피연산자 필드를 짫게 명시하는 것이 중요한 이유는 무엇이며, 오늘날의 컴퓨터는 어떤 방법을 사용하여 피연산자 필드를 짫게 하는가?**명령 인출에 필요한 주기억장치 접근 횟수가 적습니다.**

2. RISC 아키텍처의 주된 아이디어는?
   **지금의 함수형 프로그래밍이 트랜드인 것처럼 컴파일러에게 하여금 기본 명령어의 최적 조합을 이용하도록 발상을 전환하는것,** 

3. RISC 아키텍처에서 3-주소 명령어를 주로 사용하는 이유는?
   **특수 목적의 컴퓨터에서 정확도를 높이기 위해?**

4. ****주소 해상도란 무엇인가? 명령어와 데이터를 위해 동일한 주소 해상도를 사용해야 하는가? 비트 단위의 주소 해상도를 사용하지 않는 이유는?

5. 레지스터 직접 주소 지정방식이 흔히 사용되는 이유?

   높은 효율과 빠른 속도로 대부분의 아키텍처에서 사용, 레지스터 주소가 짧아서 짫은 피연산자 필드를 요구할 뿌만 아니라 데이터 접근 속도도 빠르다.



레지스터란 ?

**레지스터**는 컴퓨터의 [프로세서](https://ko.wikipedia.org/wiki/%EC%A4%91%EC%95%99%EC%B2%98%EB%A6%AC%EC%9E%A5%EC%B9%98) 내에서 자료를 보관하는 아주 빠른 기억 장소이다. 일반적으로 현재 계산을 수행중인 값을 저장하는 데 사용된다. 대부분의 현대 프로세서는 메인 메모리에서 레지스터로 데이터를 옮겨와 데이터를 처리한 후 그 내용을 다시 레지스터에서 메인 메모리로 저장하는 [로드-스토어 설계](https://ko.wikipedia.org/w/index.php?title=%EB%A1%9C%EB%93%9C-%EC%8A%A4%ED%86%A0%EC%96%B4_%EC%84%A4%EA%B3%84&action=edit&redlink=1)를 사용하고 있다.

데이터를 저장하기 위한 임시 변수, 생각해보기 -> 만약 swap해야되는 변수에 temp가 없다면 더많은 호출 요구.





참고 : http://jade314.tistory.com/entry/4-명령어의-형식과-CPU구조



### 데이터와 디지털 논리회로

진수 변환

Int a = 26;

int b = 032;

int c = 0x1A;

코드로는 어떻게?



2진수, 8진수, 16진수 변환



**4비트로 구성된 유부호 정수의 표현방식은 크게 4가지**

1. **부호-크기 방식**
   : 4비트 정수에서 MSB를 활용하여 맨 앞에 부호, 나머지 3개의 비트를 통해 최대 7에서 -7까지 표현 가능
   그러나, 2가지 단점.
   연산을 수행할 때 부호를 별도로 점검해야 하며, 2개의 0, 즉 +0과 -0이 존재한다는 것
   예를 들어 32비트로 구성된 워드는 MSB를 부호 비트 사용하고 32비트로 크기 사용.
   즉 워드는 -2^31-1부터 +2^32-1을 표현 할수 있다.

2. **2의 보수 방식**
   : 양의 정수와 +0을 부호-크기 방식 및 1의 보수 방식과 동일하나 -0이란 표현이 없고, 음의 정수는 1의 보수 방식보다 1을 크게 표현한다. 32비트 일 경우, -2^31부터 +2^31-1을 표현.

3. **1의 보수 방식**
   : 음수를 표현하기 위해 각 비트를 0과 1사이에 상호 반전 하는 것. 
   k비트 정수의 경우, 양의 2진수 y에 대한 1의 보수는 (2^k -1) - y 이다. 1의 보수 방식은 양수일 때는 일반적으로 동일하나, 마이너스 일때는 0을 1로 1을 0으로 반전하면 된다.
   *장점및 단점은 부호-크기 방식처럼 양수 및 음수 전환이 용이하지만 2개의 0을 포함하고 있다는 것.*
   또한 부호확장을 통해 32비트의 경우 MSB가 마이너스 일경우 11111111111... 같이 표시해야 한다.
   ​

4. **7-초과 코드 방식**
   : 실제 수에 어떤 수만큼 더해서 표현하는 방식으로, 바이어스된 수라고도 한다. 따라서 7-초과 코드 방식은 실제 수에 7을 더하여 표현하는 것.

   //TODO 계산 방식이 이해 안됨.

7-초과코드를 제외한 나머지 방식은 양의 정수에 대한 표현이 모두 동일.



**여기서 주의할 점은 부호 확장의 개념과, 2의 보수 방식 표현**

**그리고 왜 2의 보수방식이 대중화 되었는가를 생각해보기.**

2의 보수방식이 대중화될 수 있었던 결정적인 계기는 올림수가 발생하더라도 무시하면되고, 2의 보수 방식은 양수와 음수 사이의 전환 과정이 부호-크기 방식이나 1의 보수 방식보다 번거롭지만, 0이 유일하고 덧셈뺄셈 연산등을 쉽게 구현할 수 있는 장점을 가지고 있다. 또한 0에 대한 표현의 유일성이 범위의 대칭성보다 더 중요하기 때문에 대부분의 아키텍체에서 사용됨







![](https://ws3.sinaimg.cn/large/006tNc79gy1fmf1c308wnj30qc0u6h2g.jpg)





### 부동소수점 표현

![](https://ws1.sinaimg.cn/large/006tNc79gy1fmf1fp65yhj30xs08gdky.jpg)

부동 소수점의 구성.



왜? 표현하지 못하는가?
https://linsoo.co.kr/archives/13865

사이트 참조, IEEE의 표현 방식에 따라 부호비트 1,비트 지수필드 8비트, 가수 필드 23필드, 총 32비트에서
가수 필드에서 23번의 이진수를 표현하면 1.0 되서 끝나지 않는 이상 계속 쭈욱 가게되어 정확한 계산이 안되는 것



#### BCD 코드

#### ASCII코드

#### 유니코드



0 10000000 0000..23개 10진수 값은?

답은 2.

