## 연산 장치

```XML

Chapter 06 연산장치 ? 197 
1 연산장치의 개요 ? 199 
1 연산장치와 레지스터 파일 ? 199 
2 산술장치와 논리장치의 통합 ? 201 
3 플래그 레지스터 ? 202 

2 정수의 덧셈 ? 204 
1 덧셈 연산 ? 204 
2 덧셈?뺄셈장치 ? 206 

3 정수의 곱셈 ? 208 
1 곱셈 연산 ? 208 
2 시프트-덧셈 방식의 곱셈 연산 ? 209 
3 Booth 알고리즘 ? 213 

4 정수의 나눗셈 ? 217 
1 나눗셈 연산 ? 217 
2 복원 알고리즘 ? 218 
3 비복원 알고리즘 ? 221 

5 부동 소수점의 연산 ? 224 
1 부동 소수점의 덧셈 ? 224 
2 부동 소수점의 곱셈과 나눗셈 ? 225 
3 가드 디지트 ? 227 
요약 ? 229 
연습문제 ? 230 
```

**연산장치의 개요**

산술 논리 연산장치(ALU)를 줄인 말로 실행장치. 연산 장치는 덧셈, 뺄샘 같은 산술연산과 AND, OR같은 논리 연산을 수행하므로 산술 - 논리 연산산기를 기본적으로 가지고 있으며 시프터, 보수기 등도 포함할 수 있다.



연산장치는 산술장치와 논리장치를 합쳐서 연산 장치라 한다. 연산 중 발생하는 상태를 보관하는 레지스터가 플래그 레지스터
오버플로우, 반올림, 양/음 부호 다양하게 있다.

**정수의 덧셈**

덧셈 연산은 잉여 비트는 무시하는데 그 이유가 부호 비트와 동일하여 1비트 부호 확장한 것과 마찬가지이기 때문에.



  1 1 0 1

+1 0 1 0

10 1 1 1 

맨 앞에 잉여 비트를 무시하면, 7이 나와버림. -9가 나와야하는데, 이유는 오버플로우가 나기 때문에.

4개의 비트로 표현가능한 2의 보수는 -8부터 7까지 이기 때문에.



**정수의 곱셈**



1. 곱샘 연산

   - 종이-연필 방식

2. 시프트-덧셈 방식의 곱셈 연산

   - 종이-연필 방식에서 누적으로 곱하는 것.

     ![](https://ws3.sinaimg.cn/large/006tNc79gy1fmf483irouj309c04wglk.jpg)

   위 방식을 한 줄씩 컴퓨터가 계산하는 것.

3. Booth 알고리즘

   ![](https://ws2.sinaimg.cn/large/006tNc79gy1fmf4pz4hrej31ke0yuwka.jpg)

   **이진수 빼기 계산 과정 확인하기**



**정수의 나눗셈**

몫과 나머지 두 가지로 표현 됨.

나머지는 제수보다 크지 않기 때문에 나머지의 길이는 제수의 길이와 동일하게 설정될 수 있다. 그러나 다음과 같은 이유로 피제수는 제수를 구성하는 비트 수의 2배가 될 수 있다. 

D = Q x V + R (단, 0 <= R < V )

여기서 Q가 n비트 라면 D는 2n 비트이다. 

1. 복원 알고리즘
   똑똑하고 직관적인 인간과 달리 컴퓨터는 피제수에서 제수를 빼기 전에는 어는 것이 큰지 알수 없다. 
   복원 알고리즘은 만약 나머지 값이 음수(1)가 나온다면 다시 복원해서 계산해야 한다.

   ![](https://ws3.sinaimg.cn/large/006tNc79gy1fmf5lx5l2ej30t417u4qp.jpg)

2. 비복원 알고리즘

 복원알고리즘에서 복원하는 부분의 연산을 무시하는 방식이다.

아래 그림을 보고 이해해보자.

![](https://ws2.sinaimg.cn/large/006tNc79gy1fmf5xexe0aj31e623qaif.jpg)![](https://ws3.sinaimg.cn/large/006tNc79gy1fmf5xila3pj31kw1xytsh.jpg)



**부동 소수점의 연산**



1. 부동 소수점의 덧셈
   1.010(2) x 2^-1 + 1.111(2) x 2^-2
   [1] 지수 정렬 1.010(2) x 2^-1 / 0.111 x 2^-1
   [2] 가수 덧셈 10.001(2) x 2^-1
   [3] 정규화 1.0001(2) x 2^0
   [4] 오버플로우 점검 -> 정규화 과정에서 지수가 증가하거나 감소할 수 있다. 이때 지수가 지수 필드에 적합한지 확인
   [5] 자리 맞춤  -> 주어진 유효 자리 수만큼만 표현할 수 있기 때문에 4비트를 초과하는 비트는 절삭하거나 반올림. 
   즉 1.000 x 2^0 즉, 1

2. 부동 소수점의 곱셈과 나눗셈
   종이-연필 방식과 유사한데, 
   곱셈연산의 경우, 지수끼리는 더하고 가수끼리는 곱한다. 그러나 부동 소수점 수이기 때문에 지수 문제와 정규화, 오버플로우등을 고려해야 한다.
   $$
   1.010_2 * 2^-1 과 1.111_2 * 2^-2        의  곱셈 계산 과정
   $$
   ​

   [1] 지수 덧셈 
   : -1과 -2 를 더하면 -3 근데 127초과 코드이므로 127을 더한다. 
   (-1+127) + (-2+127) = 124
   [2] 가수 곱셈
   : 1.010(2) X 1.111(2) = 10.010110(2)
   [3] 정규화
   : 1.0010110(2) x 2^-2
   [4] 오버플로우 점검
   : 정규화 과정에서 지수가 증가하거나 감소할 수 있다. 지수가 너무 커서 적합하지 않은 경우에 오버플로우로 예외처리
   [5] 자리 맞춤
   : 유효 자리를 맞춰 정밀도 처리하면 마지막 네자리 절삭 
   1.001(2) x 2^-2
   [6] 부호 결정
   :피승수와 승수 모두 동일한 부모이므로 양수.
   $$
   1.010_2 * 2^-1 과 1.111_2 * 2^-2        의  나머지 계산 과정
   $$
   지수끼리는 뻴셈을 하고 가수끼리는 나눗셈을 하면 된다. 여기서 유의할 점은 지수 뺄셈을 할 때는 곱셈과는 달리 초과수를 더해야 한다는 것? 

   **위에서는 각각의 지수에 127을 더하고 더한 값에 더함을 했다면, 뺄셈에서는 초과수를 한 번 더 더해야 한다.** 

3. 가드 디지트

   가드 디지트는 분수에 대한 유효 자리의 오른쪽에 위치한 자리로, 부동 소수점 연산의 정확도를 향상하기 위한 기법. 가드 디지트는 정규화 과정에서 오른쪽으로 시프트할 때 발생하는 손실을 막기 위해 사용된다.

   ​

   정수는 주어진 범위 내의 수를 정확하게 나타낼 수 있지만 부동 소수점 수는 많을 수를 근삿값만으로만 나타낼 수 있다. 따라서 가능하면 연산 결과를 정확한 근삿값으로 나타내는 것이 바람직하다.

   ----

   연산 과정에서 발생하는 상태를 레지스터에 저장한다.

   ​

   ## 데이터 경로

   ​



1. 단일 사이클 방식과 다중 사이클 방식

   16비트로 구성된 두 수를 덧셈하는 경우,
   단일 사이클 덧셈장치는 한 사이클동안 16개의 전 가산기를 사용하여 16비트를 더한다.
   다중 사이클 덧셈장치는 하나의 가산기를 16번 사이클하여 16비트를 더한다.
   CPU 실행 시간 = 명령어 개수 X 평균 CPI X 사이클 시간

   (명령어 1개) X (1사이클/명령어) X (16ns/사이클)

   (명령어 1개) X (16사이클/명령어) X (1ns/사이클)

   여기서 다중 사이클 덧셈장치에서는 플립플롭과 같은 저장장치를 무시했다.. 그러나 다중 사이클 덧셈장치는 하나의 전가산기를 동일한 명령어 수행과정 중에 여러 번 사용하므로 필수이다.

2. ​



![](https://ws4.sinaimg.cn/large/006tNc79gy1fmf7yimpryj31kw0ren24.jpg)



![](https://ws4.sinaimg.cn/large/006tNc79gy1fmf7yonq5gj31ki0t8n2x.jpg)



단일 사이클 방식의 클록 사이클 시간은 명령어의 가장 느린 지연 시간과 동일하며, 다중 사이클 방식의 클록 사이클 시간은 가장 긴 단계의 지연 시간과 동일하다.. 파이프라이닝 기법을 사용하며 각 사이클마다 데이터 경로를 중첩 사용하려면 다중 사이클 방식을 도입해야 하며,  오늘날의 컴퓨터는 다중 사이클 방식의 데이터 경로를 사용한다.



## 제어 장치

제어장치는 데이터 경로와 함께 CPU의 주요 구성 요소로서 명령어 장치라고도 한다.

제어 장치는 메모리에서 명령어를 가져와 해독한 후 시스템 전체에 제어 신호를 보냄으로써 명령어의 지시대로 연산장치(ALU), 레지스터 파일, 메모리, 입출력장치가 동작하게 된다.

- 명령어 해독 : 명령어의 연산 부호를 해독
- 제어 신호 생성 : 명령어의 연산 부호를 해독한 결과를 기능필드, 상태 레지스터, 외부 신호등과 같은 정보를 사용하여 명령어 실행에 필요한 제어 신호를 생성
- 제어 신호 인가 : 데이터 경로를 구성하는 각종 장치에 생성된 제어 신호를 인가함으로써 명령어가 지시하는 작업을 수행하게 한다. 예를 들어, 적제 혹은 저장 명령어라면 메모리의 읽기 혹은 쓰기 단자에 적절한 신호를 인가함으로써 메모리에 있는 데이터를 읽거나 메모리에 데이터를 기록한다.



데이터 경롤를 구성하는 기능 장치(메모리, 레지스터 파일 등)는 규칙적이지만 제어장치는 불규칙하고 전역적이다. 또한 제어장치는 데이터 경로와 달리 설계하기 어려울 뿐만 아니라 검증하기도 매우 복잡하다. 오늘날의 컴퓨터에서 사용하는 제어장치 구현방식은 크게 **고정결선식제어(hardwired control)**과 **마이크로프로그래밍 제어(miroprogrammed control)** 방식이 있다.



#### 제어장치 구현의 두 가지 방식

- 고정결선식 제어 방식
  디코더를 통해 명령어 레지스터의 연산 부호를 해석한다. 그리고 조합논리회로가 디코더의 출력과 플래그 레지스터, 외부 장치의 신호 등을 이용하여 각 기능장치나 버스의 제어점을 적절한 제어 신호를 클록에 맞춰 제공한다.

  고정결선식 제어장치를 구성할 경우, 명령어 구성이 복잡하거나 명령어의 수가 많아지면 조합 논리회로를 설계하거나 검증하기 매우 복잡하고 어려워진다. 따라서 오늘날의 컴퓨터는 조합 논리 회로 대신에 PLA를 사용하여 동등한 회로를 효과적으로 구현

  - 최적화할 수 있어서 일반적으로 제어 신호를 빠른 시간에 생성
  - ROM과 달리 불필요한 회로를 제거할 수 있으므로 칩의 크기가 작다.

  현재에 더 많이 쓰이는데, 그 이유는 최근 RISC아키텍처의 출현으로 명령어 구성이 간단해지고 CAD기술의 발전으로 복잡한 회로 설계가 용이해짐에 따라 오늘날의 많은 컴퓨터는 고정결선식 방식을도입하고 있다.

  ​

- 마이크로프로그래밍 제어 방식(펌웨어)
  마이크로 연산을 수행할 수 있도록 마이크로 명령어를 PROM에 프로그래밍하는 방식이다. 모든 명령어는 연속된 마이크로 연산으로 분할되며, 일부 마이크로 연산은 동시에 수행될 수 있다. 여기서 동시에 수행되는 마이크로 연산의 집합을 마이크로 명령어 혹은 제어 단어라고 한다. 따라서 제어장치는 모든 연산에 대해 일련의 마이크로 명령어를 수행하는 컴퓨터 내의 또 다른 컴퓨터라고 할 수 있다.

  - 연산 부호가 바뀌거나 프로세서 상태가 추가될 경우 PROM에 수정된 내용을 프로그래밍하면 되므로 명령어 집합의 변경이 가능
  - 다른 종류의 명령어 집합을 에뮬레이션
  - 동일한 시스템에 다수의 명령어 집합을 구현
  - 컴퓨터의 구성, 타이밍, 기술의 변화에 쉽게 적응 가능.



#### PROM과 PLA

PLD(Programmable logic device)의 대표적인 2가지
**PROM(Programmable read only memory)와 PLA(Programmable logic array)**를 사용하여 제어장치를 실천.

ROM회로의 변종으로 프로그래밍 할 수 있다. PROM은 자주 사용되는 데이터를 영구적으로나 반영구적으로 보관하기 위한 메모리이다. PROM은 첫 번째 단계에서 디코더를 통해 모든 최소항을 생성한다. 두 번째 단계에서는 OR게이트를 사용하여 원하는 출력을 최소항의 합으로 구성한다.



PROM은 모든 종류의 최소항을 디코더로 생성하므로 최소항의 합을 사용하면 어떤 종류의 출력도 생성할 수 있다. 그러나 사용하지 않는 최소항도 생성하므로 낭비가 있을 수 있다.



PLA 첫 번째 단계에서 AND게이트를 사용하여 필요한 모든 곱의 항을 생성한다. 두 번째 단게에서는 OR게이트를 사용하여 전 단계에서 생성한 곱의 항에 대한 합으로 원하는 출력을 구성.



PLA는 PROM과 달리 AND게이트를 사용하기 때문에 불필요한 곱의 항을 생성할 필요가 없다. 따라서 동일한 기능일 때 PROM에 비해 작은 칩 공간을 사용한다. 하지만 출력신호를 변경하거나 추가하는 경우에 필요한 곱의 항이 없을 수도 있다.



. PLD는 프로그래밍이 가능한 논리장치로 프로그래밍이 가능한 전자 퓨즈선으로 연결된 게이트의 배열로 구성된 집적회로를 말한다.

2. PLD는 PROM, PAL, PLA의 세 가지 형태가 있으며, AND–OR 배열의 프로그래밍 가능 여부로 구별된다.

3. PLA는 ROM과 같은 기능을 수행하지만, ROM의 단점을 보완한 프로그래밍 가능한 논리장치로 모든 입력변수를 디코딩하지 않으며, 모든 최소항도 만들지 않는다.

4. PLA를 이용한 조합논리회로의 구현이란 PLA의 내부를 구성하는 AND–OR 게이트 배열을 프로그래밍한다는 것을 의미한다.

5. PLA를 이용한 조합논리회로를 구현하려면 조합논리회로의 논리를 나타내는 PLA프로그래밍표를 작성하면 되고, 작성된 프로그래밍표를 사용하여 PLA가 제작된다.