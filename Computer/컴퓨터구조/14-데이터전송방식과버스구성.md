# #데이터 전송 방식과 버스 구성



IO모듈은 입출력장치로 하여금 CPU또는 메모리와 데이터를 전송.
메모리와 입출력장치 사이의 데이터 전송은 CPU의 개입 정도에 따라  
프로그램 입출력(PIO programmed IO)방식, 인터럽트 구동 입출력(interrupt driven IO)방식, 직접 메모리 접근(DMA direct memory access)입출력 방식 등으로 분류된다. PIO방식과 인터럽트 구동 방식은 CPU를 통해 출력할 데이터를 메모리로 가져오거나, 입력될 데이터를 메모리에 저장시킨다. 그러나 DMA 방식 또는 DMA방식을 개선한 IO채널 방식의 경우, CPU가 개입하지 않고 IO모듈과 메모리 사이에 직접 데이터를 교환된다. 



### 1 프로그램 입출력 방식(주기적으로 Pull)

입출력 동작의 모든 과정을 CPU가 통제하고 개입하는 가장 단순한 방법. 비 방식은 수업 시간의 모든 활동을 교수가 통젷고 주기적으로 학생의 질문 여부를 점검하는 것과 유사. 이때 교수는 학생의 질문이 없더라도 주기적으로 학생의 상태를 점검한다.

**IO모듈과 CPU에 있는 한 쌍의 입출력 레지스터를 버스로 연결한 가장 간단한 입출력 방식이며 바이트 단위로 입출력 동작을 수행** CPU는 자신보다 느린 입출력장치의 동작을 확인하기 위해 주기적으로 IO모듈의 상태를 점검해야한다. 따라서 PIO방식을 소프트웨어 폴링(software polling)방식 또는 간단히 폴링 방식이라고도 한다.



데이터 전송의 시작부터 데이터 전송의 모든 입출력 동작을 CPU가 직접 제어하고, 입출력 동작이 완료될 때까지 CPU가 대기하면서 감시한다. 입출력장치의 동작 속도가 CPU의 실행속도에 비해 매우 느리므로 CPU의 사용효율을 떨어뜨린다는 단점이 있지만, 하드웨어 비용의 부담이 거의 없어서 대부분의 컴퓨터에서 선택할 수 있도록 지원하고 있다.



### 2 인터럽트 구동 방식

PIO방식은 입출력장치가 데이터를 송신하거나 수신할 준비가 될 때까지 CPU가 계속 상태 비트를 점검해야 한다. 즉, 학생에게 질문거리가 전혀 없더라도 교수는 주기적으로 학생의 질문 여부를 점검하므로 효율적이지 못하다. 이보다는 수업을 진행하다가 학생이 손을 들 때만 질문을 받는 방식이 더 적합한데, 이와 같은 방식을 인터럽트 구동 방식  

인터럽트 구동 방식은 입출력의 입출력 준비 상태에 대해 폴링할 필요가 없고, 입출력 준비가 된 경우에만 CPU가 데이터 전송에 개입하는 방식.



인터럽트 구동 방식은 PIO 방식에 비해 CPU의 부담이 많이 줄어든다. 그러나 여전히 CPU의 부담은 감당하기 어려울 정도!!



### 3 직접 메모리 접근 방식

 PIO 방식이나 인터럽트 구동 방식은 입출력장치와 메모리 사이의 데이터 전송에 CPU가 개입한다. 이때 CPU의 전송 단위가 워드이므로 대량의 데이터를 효율적으로 전송하기가 어렵고, 입출력장치의 실행 속도도 CPU에 비해 매우 느리기 때문에 CPU의 효율이 크게 떨어진다.



교수는 강의에 열중하고 학생의 질문은 조교가 맡도록 한다면 더욱 효율적으로 수업을 진행할 수 있다. 이와 같이 CPU도 데이터 전송의 시작과 끝 부분에만 관여하고, 데이터 전송에 대한 요청이 있으면 전담 하드웨어에 부담시키는 방식이 직접 메모리 접근(DMA)방식, 여기서 데이터 전송을 전담 하드웨어를 DMA제어기 라고한다.

DMA방식은 메모리와 입출력장치 사이에서 대량의 데이터를 직접 전송할 수 있도록 허용하는 메커니즘!

\- 입출력장치에서 데이터의 위치

\- 메모리의 블록 시작 주소

\- 전송될 블록 크기

\- 전송 방향, 즉 읽기(입출력장치 -> 메모리) 또는 쓰기(메모리 -> 입출력장치)

CPU가 DMAC로 하여금 데이터 전송을 시작시키면 DMAC는 메모리와 입출력 장치 사이에 데이터를 전송하고, 데이터 전송이 끝나면 인터럽트를 통해 CPU에 알린다. CPU는 데이터 전송에 능동적으로 개입하지 않기 떄문에 데이터를 전송하는 동안 다른 작업을 수행할 수 있다. 따라서 DMA방식은 다중 사용자 시스템에서 유용하다.

DMA는 주소 레지스터, 데이터 레지스터, 카운트 레지스터와 같은 다수의 레지스터를 사용한다.  
예를 들어 카운트 레지스터는 전송될 블록의 크기를 저장한다. CPU로부터 입출력 명령을 받은 DMAC는 한 번에 1워드씩 메모리와 입출력장치 사이에 직접 데이터를 전송한다. 전송한 데이터의 수는 DMA 내부에 있는 카운트 레지스터를 사용하여 계산한다. 전송된 데이터의 수는 DMA 내부에 있는 카운트 레지스터를 사용하여 계산한다. 블록 데이터의 전송이 완료되면 DMA는 CPU에 인터럽트 신호를 보낸다. 이처럼 CPU는 데이터 전송의 시작과 마지막 부분에만 관여.

DMAC는 CPU와 함께 시스템버스를 공유하므로 동시에 시스템버스를 사용하려고 요청할 수 있다. 따라서 시스템버스에 대한 충돌을 피하는 방법이 필요하다.  


DMA방식은 시스템버스의 사용 권한에 대한 우선순위에 따라 다음과 같이 분류한다.

- 버스트(Burst) DMA : CPU보다 DMAC가 시스템버스를 우선적으로 사용하는 방식. 한번에 하나의 블록 전송!
- 사이클 스틸링(cycle stealing) DMA : CPU가 제어하고 있는 메모리 사이클을 DMAC가 하나씩 훔쳐서 1워드씩 전송하는 방식이다. 하나의 블록을 전송하기 위해 DMAC는 CPU로부터 다수의 메모리 사이클을 훔쳐야 하므로 저속인 입출력장치에 유용
- 투먕(transparent) DMA : DMAC보다 CPU가 시스템버스를 우선적으로 사용하는 방식, CPU는 산술,논리 연산을 수행할 동안 메모리 사이클을 사용하지 않는데, 이때 DMAC가 메모리 사이클을 사용하여 데이터를 전송한다. 하지만 이는 거의 사용하지 않는 방식이다.

### 4 IO채널 방식

DMA방식은 PIO나 인터럽트 구동 방식에 비해 매우 효율적이다. 그러나 CPU에 의한 초기화 과정이 필요할 뿐만 아니라 다양한 속도와 제어 방법을 가진 많은 입출력장치를 지원하기가 어렵다.  
또한 DMA내부에 지역 메모리가 없기 때문에 큰 불록을 사용하는하드디스크와 같은 입출력장치를 효율적으로 지원하지 못한다.  
이와 같은 문제점을 해결하기 위해 고성능 컴퓨터 시스템에서는 DMA개념을 확장한 IO채널을 사용한다.  
IO채널 방식은 고수준의 입출력 기능을 제공하고 다양한 입출력장치를 제어할 수 있도록 특수목적용 프로세서를 사용한다. IO채널은 데이터 전송을 비롯해 산술,논리 및 코드 변환과 같은 다른 종류의 연산도 수행할 수있다. IO채널 방식은 메모리나 지역 메모리에 입출력 명령어를 저장하고, CPU는 IO채널에 입출력 명령을 수행하도록 지시함으로써 데이터 전송을 시작시킨다. IO채널 방식은 CPU와 장치 독립적인 인터페이스를 허용한다. 따라서 IO채널 방식은 다양한 종류의 저장장치나 입출력장치와 연결될 수 있고, 또한 장치 구동기를 쉽게 구현할 수 있도록 해준다.

IO채널 방식은 DMA 전송과 원리는 비슷하지만 하나의 블록을 전송하기 위해 하나의 채널 명령어를 사용한다. 채널 프로그램은 데이터와 명령을 연쇄적으로 처리할 수 있도록 일련의 채널 명령 워드(CCW channel command word)로 구성되어 있다. IO채널 방식의 채널 프로그램과 버퍼링 기능은 입출력에 대한 부담을 덜어준다. IO채널 방식은 채널의 전용 여부에 따라 다음과 같이 두 가지 종류로 분류

- 선택자 채널(selector channel) - 선택된 입출력장치가 입출력 작업을 끝낼 때까지 하나의 채널을 전용하는 방식, 따라서 입출력장치가 사용하는 채널을 다른 입출력장치가 사용할 수 없으므로 특정 시점에 한 대의 입출력장치만 데이터를 전송할 수 있다. 전형적으로 하드디스크와 같은 높은 데이터 전송률을 가진 장치와 연결하여 사용하며 버스트 DMA방식으로 데이터를 전송한다.
- 다중화 채널(multiplexor channel) - 하나의 채널에 많은 입출력장치를 연결하여 채널을 공유하는 방식. 채널에 할당된 시간을 다수의 입출력장치에 맞게 할당하여 동작시키므로 선택자 채널에 비해 상대적으로 느리다. 저속의 입출력장치를 위한 문자 다중화 채널(character multiplexor channel)과 고속의 입출력장치를 위한 블록 다중화 채널(block multiplexor channel)이 있으며, 문자 다중화 채널은 바이트 다중화 채널(byte multiplexor channel)이라고도 한다.



## 2 인터럽트

CPU와 입출력장치의 속도 차이에 따른 문제점으로 인터럽트로 해소한다. 여기서는 인터럽트의 종류 및 우선순위와 처리 과정에 대해 공부해봅시다.



### 1 인터럽트의 종류

- 외부인터럽트
  정전이나 기계 결함과 같은 외부적 원인으로 발생하는 인터럽트를 의미.  
  주로 입출력을 요구하는 입출력장치와 같은 하드웨어에 의해 발생하므로 하드웨어 인터럽트라고 부른다. 내부 인터럽트와 달리 대부분 CPU와 비동기적이다.
  \- 정전 및 기계적 오류에 의한 인터럽트  
  \- 조작원의 의도적 조작이나 타이머에 정해진 시간이 경과되었을 때 발생하는 인터럽트  
  \- 조작원이나 다른 프로세서에 의해 재시작 명령이 도착했을 때 실행되는 인터럽트  
  \- 키보드나 하드디스크와 같은 입출력장치의 요청에 의한 인터럽트  

- 내부인터럽트

  대개 CPU외부에서 인터럽트를 요청하는 경우가 일반적이지만, CPU내부에서도 인터럽트가 발생할 수 있다. 대표적인 예로 예외(exception)과 트랩(trap)

  \- 예외는 프로그램의 오류로 발생하는 인터럽트로써 예측하기 어렵지만 자주 발생하지는 않는다.  
  (나누기-0, 보호 영역 메모리 접근, 미정의 명령어 사용, 오버플로우 등이 대표적인 예외)



### 2 인터럽트의 우선순위

다수의 인터럽트가 동시에 발생하면 CPU는 우선순위를 결정해야 하는데 일반적으로 내부 인터럽트보다 외부 인터럽트가 우선순위가 높다. CPU는 인터럽트에 대한 긴급 여부를 판별할 수단으로 인터럽트 마스크를 사용. 마스크가 설정되면 CPU는 우선순위가 낮은 인터럽트를 무시할 수 있다.

최우선순위의 인터럽트는 메모리 고장과 같이 즉시 처리할 필요가 있는 심각한 오류에 대처하는 인터럽트. 최우선순위의 인터럽트를 마스크 불가능 인터럽트(NMI non-maskable interrupt) 또는 차단 불가능 인터럽트라고 한다.

인터럽트의 일반적인 우선순위는 다음과 같다.

1. 정전에 의한 인터럽트
2. 기계 오작동에 의한 인터럽트
3. 입출력 인터럽트
4. 예외에 의한 인터럽트
5. 트랩 의한 인터럽트



### 3 인터럽트의 처리

처리과정은 CPU의 종류마다 다르며, 인터럽트의 종류에 따라서도 처리 과정이 달라질 수 있다. 하지만 어떠한 경우에도 인터럽트를 일으킨 이벤트를 신속히 처리해야한다. 인터럽트를 처리하는 시간이 길어지면 전체 시스템의 성능에 심각한 영향을 주기 때문이다.  
인터럽트를 처리하는 루틴을 서비스 루틴(ISR interrupt service routine) 또는 인터럽트 핸들러(interrupt handler)라고 부른다.   
인터럽트의 처리 과정은 다음과 유사하다.

1. 인터럽트 요청 신호의 검출
2. 인터럽트 우선순위 제어 및 허용 여부 판단
3. ISR의 시작 번지 확인
4. 복귀주소 및 레지스터 확인
5. ISR의 실행
6. 인터럽트된 프로그램으로 복귀



## 3 버스의 개요

CPU, 메모리, 입출력장치를 연결해야 서로 정보를 교환 / 이를 위한 가장 기본적이고 효율적인 방법이 바로 버스를 사용하는 것

### 1 버스의 의미와 용어

버스는 컴퓨터 시스템 구성 요소들이 공유하는 배선의 집합으로 구성 요소들이 통신하기 위한 수단. 

많은 입출력장치를 버스에 연결하는 것도 중요하지만 버스 대역폭을 향상하는 것도 중요!!  
따라서 버스를 사용하여 데이터를 전송하려면 버스 요청부터 데이터 전송이 끝날 때까지 일련의 과정을 거쳐야 한다. 이를 버스 트랜젹션이라고 하는데, 하나의 버스 사이클을 사용할 수도 있고 다수의 버스 사이클을 사용할 수도 있다.



### 2 버스에 의한 데이터 전송 과정

데이터 전송은 버스 마스터와 버스 슬레이브 사이에서 제어 신호, 주소 신호, 데이터 신호의 교환으로 이루어진다.  
제어신호는 읽기, 쓰기와 같은 데이터의 전송 방향을 위한 정보.



블록단위의 데이터를 전송할 때는 버스 이용률을 높이기 위해 버스트 전송방식을 사용할 수 있다. 버스트 전송의 경우, 일단 데이터를 전송하기 시작하면 전송이 끝날 때까지 다음 버스 마스터가 오랜 시간 동안 기다려야 하는 문제점이 있지만, 이를 해결하기 위해 선점 방식을 사용할 수 있다.



### 3 분리형 버스 트랜잭션

읽기를 위한 데이터 전송의 경우, 접근 시간 동안에는 버스를 사용하지 않기 때문에 버스를 잡아둘 필요가 없다. 따라서 다른 버스 트랜잭션이 발생할 수 있도록 데이터를 읽는 접근 시간 동안 버스 마스터가 버스를 양보한다면 버스 대역폭이 개선될 수 있다. 이를 위해 접근 시간 전후의 과정을 별도의 트랜잭션으로 분리하는 방식을 분리형 버스 트랜잭션 또는분할 버스 트랜잭션이라고 한다.

### 4 버스의 성능 향상

버스의 성능을 나타내는 척도로 버스 대역폭을 사용. 버스 대역폭은 단위 시간당 전송할 수 있는 데이터의 양을 나타내는 것으로, 버스 클록의 주기나 버스 폭에 의해 결정된다!
예를 들어 버스 클록의 주기가 20ns, 즉 클록률이 50Mhz이고 버스 폭이 64비트, 즉 8바이트라면 버스 대역폭은 다음과 같다.

버스 대역폭 = 8 / 20 * 10^-9 = 400바이트



## 4 버스의 분류

버스는 다양한 방법으로 분류할 수 있는데, 예를 들어, 버스가 전달하는 정보의 종류에 따라 분류하면  
주소 버스, 데이터버스, 제어버스로 나눌 수 있다.  
이 번에는 **버스의 위치, 버스의 전용 여부, 동기화** 여부에 따라 버스를 분류해보자.

### 1 시스템버스와 IO버스

버스는 컴퓨터의 구성 요소와 연결되는 위치에 따라 보드(board)계층 버스, 백플레인(backplane)계층 버스, 인터페이스(interface)계층 버스로 분류할 수 있다.  
**보드 계층버스**는 인쇄회로기판(PCB)위에 있는 하나 이상의 컴포넌트로 이루어진 시스템 구성 요소를 연결하고  
**백플레인 계층 버스**는 보드를 구성하는 시스템 구성 요소 사이의 통신 경로를 제공하며  
**인터페이스 계층 버스**는 입출력장치 및 시스템의 나머지 부분과 공통된 통신 경로를 제공

그러나 기술의 발달로 백플레인 계층과 인터페이스 계층의 경계가 모호. 그래서 다음과 같이 분류한다.

- **시스템 버스**
  : 프로세스와 메모리를 연결하는 버스로 길이가 짧고 매우 빠르며 주로 동기식으로 동작. 클록 속도와 같은 프로세서의 특성과 매우 밀접하기 때문에 표준하기가 어렵다. 일반적으로 프로세서와 메모리 사이의 처리량을 극대화할 수 있도록 맞춤식으로 설계한다. 시스템버스는 프로세스-메모리버스, 프로세서버스, 메모리버스, 호스트버스, 전면버스(FSB)라고도 한다.

cf) 전면 버스 ? CPU와 나머지 컴퓨터 시스템의 외부 인터페이스를 가리키지만, 정확한 의미는 CPU와 메모리 컨트롤러 허브인 노스브리지 사이를 연결하는 통로를 말한다.

- **IO 버스**
  : 버스의 길이가 길고 느리며 주로 비동기식으로 동작한다. 다양한 종류의 입출력장치를 쉽게 연결할 수 있도록 컴퓨터 회사들이 여러 가지 IO버스 표준을 개발. 최근에 많은 IO버스 표준은 컴퓨터가 동작 중인데도 입출력장치를 장착할 수 있는 PnP기능 제공.



### 2 전용 버스와 다중화 버스

각종 구성 요소 사시에 데이터를 전달하는 데 사용되는 버스는 서로 공유. 버스에 적재되는 데이터의 기능적인 특화나 버스의 전용 여부에 따라 버스를 분류

- 전용 버스(dedicated bus)
  : 명령어, 데이터, 입출력 등으로 기능이 지정되어 지정된 신호만을 전송할 수 있는 버스. 따라서 큰 대역폭을 확보할 수 있고 다수의 장치가 동시에 통신이 가능하다. 그러나 여러 가지 종류의 전용 버스가 있어야 하므로 비용이 높다. 

- 다중화 버스
  : 제어 신호에 의해 여러 가지 목적으로 사용할 수 있는 버스. 배선의 수가 적어서 공간과 비용을 절감할 수 있으나 제어회로가 복잡하고 시분할 방식을 사용하기 때문에 성능이 떨어진다. 다중화 버스는 2개 이상의 잠재적 장치가 버스를 동시에 사용하려고 할 때 충돌을 방지하는 중재 메커니즘이 필요.

  상대적으로 소규모 저성능의 컴퓨터 시스템은 단일 다중화 버스로도 충분하지만, 다중 프로세서 시스템이라면 버스에 많은 트래픽이 발생하여 시스템의 성능이 떨어지기 때문에 다중화 버스로도 충분치 않다. 이 경우에 다수의 다중화 버스를 사용하면 문제를 해결할 수 있고, 이를 대체할 다수의 버스가 있기 떄문에 버스 요청에 대한 충돌을 줄일 수 있고, 일부 버스에 고장이 있더라도 유용한 버스의 수만 줄어들어 성능 저하만 있을 뿐 정상적으로 동작 X

### 3 동기식 버스와 비동기식 버스

 데이터를 전송할 때 서로의 상태를 파악하고 동작을 제어할 필요가 있는데, 버스는 데이터 전송 과정을 제어하는 방식에 따라 **동기식버스 또는 비동기식 버스**로 구분.

 데이터를 버스 위에 병렬로 전송할 때 모든 데이터 비트가 수신지에 동일한 시간에 도작하지 않는다. 송신지의 드라이버나 수신지의 리시버에 의한 시간 편차, 버스 라인의 지연 편차 등이 존재하기 때문. 따라서 데이터의 발송이나 수신 여부를 상대방에게 알리기 위해 서로 약속을 하는데, 이를 통신 프로토콜이라고 한다.

- 동기식 버스
  : 공통된 클럭을 사용하여 데이터 전송 과정을 제어하는 방식이며, 일반적으로 빠르고 인터페이스 논리회로가 간단하다. 그러나 모든 장치가 동일한 클록 속도에 맞춰 동작해야 하므로 동기화를 위한 클록이 필요하고, 또한 클록 스큐(Clock skew)를 피하기 위해 짫은 버스에서만 사용해야 한다. 따라서 적은 수의 장치들이 짦은 거리에서 통신하는 시스템버스와 같은 고속 시스템에 적합.  
  **장점**: 대역폭이 넓으나  
  **단점**: 입출력장치 중 가장 느린 장치에 맞춰야 한다.  
- 비동기식 버스
  : 공통된 클럭을 사용하지 않고 상대방에게 이벤트를 위한 시그널을 전파함으로써 데이터 전송 과정을 제어하는 방식, 이는 마치 악수를 주고받듯이 송신지와 수신지 사이에 이벤트 시그널을 교환하기 때문에 핸드셰이킹(handshaking)방식이라고도 한다. 비동기식 버스를 사용하면 다양한 종류의 장치를 수용할 수 있고, 클록 스큐나 동기화에 관련된 문제가 없기 때문에 길이가 긴 버스도 사용할 수 있다. 그러나 핸드퀘이킹 신호를 송수신하는 제어선이 추가적으로 필요하고, 핸드셰이킹에 대한 부담으로 인해 비교적 속도가 느리다. 그래서 저속 시스템의 IO버스와 같은 저속 시스템에 적합하다. 비동기식 버스의 제어 신호는 모두 가변 길이, 따라서 버스 제어 신호가 무작정 늘어나는 것을 방지하기 위해 타임아웃(timeout)메커니즘을 사용.



## 5 버스 중재

여러 개의 버스 마스터를 가진 버스 시스템이라도 한 번에 하나의 버스 마스터만 버스를 제어할 수 있다. 만약 동시에 다수의 버스 마스터가 버스 사용을 요구하면 버스 경합이 발생하기 때문에 정상적인 버스 동작을 수행하기 위해 중재가 필요!  
버스 중재란? 우선순위와 균형성을 고려하여 버스 마스터를 선택하는 메커니즈밍다. 우선순위는 높은 우선순위를 가진 장치부터 버스를 사용할 수 있도록 해주고, 균형성은 어떤 장치라도 궁극적으로 버스를 사용할 수 있도록 해준다. 이때 우선순위를 강조하면 우선순위가 매우 낮은 주변장치는 버스를 사용할 수 없으므로 공평성에 위배되며, 반대로 공평성을 강조하면 우선순위가 제대로 적용되지 않는다.

- 정적 버스 중재와 동적 버스 중재
- 동적버스 중재 방식과 버스 할당 및 반환

### 1 중앙 집중식 중재 방식

- 데이지 체인 방식
  : 데이지 체인 방식은 가장 간단한 중앙 집중식 중재 방식으로, 입출력장치를 체인처럼 연결하여 하드웨어 폴링이라고도 한다.
- 중앙 집중식 병렬 중재 방식

### 2 분산식 중재 방식

- 분산식 고정 우선순위 중재 방식
- 분산식 가변 우선순위 중재 방식

## 6 IO버스 표준

시스템버스는 프로세서 구조에 종속적이기 때문에 표준화되기 어렵지만 IO버스는 제약 사항이 없으므로 많은 표준이 개발되었다.

초기에는 한번에 많은 데이터를 보내기 위해 병렬 버스 방식을 주로 사용했지만, 이 방법은 다수의 배선으로 구성된 두꺼운 케이블을 사용하기 떄문에 여러 문제점이 있었다. 따라서 최근 대다수 IO버스 표준은 직렬 버스(serial bus)방식을 사용한다.

### 1 PCI(Peripheral component interconnect)

과거 컴퓨터 확장 카드의 버스 표준이었던 ISA, EISA, MCA, VESA버스는 CPU에 과중한 부담을 줄 뿐만 아니라 64비트 컴퓨터를 위한 버스 사양도 없다. PCI는 이와 같은 문제점을 해결하기 위해 인텔을 중심으로 설계한 버스 표준 규격이다. 오늘날 비디오 카드와 같은 고속 주변장치에서 흔히 사용됨. PCI버스는 CPU와 독립적으로 작동하기 때문에 처리 속도가 빠르며, 슬롯의 크기가 작고 PnP기능을 제공하며, 하위 보환성을 보장.

### 2 SATA(Serial advanced technology attachment serial ATA)

하드디스크나 SSD와 같은 대용량 저장장치의 데이터 전송을 위한 버스 구조.

### 3 SAS(Serial attached SCSI)

### 4 USB(Universal serial bus) 범용 직렬 버스

### 5 IEEE 1394

차세대 홈 네트워크 인터페이스 기술로 주목받기 시작한 IEEE 1394는 새로운 직렬 버스 규격으로, 미국 애플에서 FireWire라는 코드명으로 개발한 규격.