# 가상기억장치

메모리 계층 구조의 주된 목적 중의 하나는 적은 비용으로 큰 용량의 메모리 공간을 사용자에게 제공하는 것.  
이를 위한 기법으로 가상 기억 장치를 먼저 살펴보고 가상기억장치에 필수적으로 수반되는 주소 변환 과정의 원리를 알아보자.

## 1 가상기억장치의 필요성?

- 다수의 프로세스가 동시에 실행될 수 있는 주소 공간을 제공해야 한다.
- 각 프로세스 고유의 메모리 자원을 보호해야 한다.
- 필요할 때 프로세스 사이의 주소 공간을 공유할 수 있어야 한다.
- 주소 공간을 프로그래머에게 투명하게 관리해야 한다.



가상기억장치는 위의 요구 상황을 모두 만족하는 효과적인 메모리 관리 방법이다. 가상기억장치는 다수의 프로세스를 위해 충분한 주소 공간을 비롯해 메모리 보호, 메모리 공유, 메모리 재배치를 위한 메커니즘도 제공한다.



## 2 메모리 중첩

초기 컴퓨터의 경우 프로그램의 크기가 메모리 용량보다 더욱 빠르게 증가, 따라서 부족한 메모리 공간 문제를 극복하기 위해 프로그래머는 메모리 중첩(memory overlay)이라는 방법을 활용

이 방법은 프로그램을 여러 개의 모듈로 분할 한 후 메모리와 보조기억장치 사이에서 모듈을 공간적으로 이동함으로써 메모리의 부족한 공간 문제를 해결한다.

예를 들어 34MB의 프로그램과 20MB의 메모리, 충분한 하드디스크를 가진 컴퓨터가 있다고 가정하면, 프로그램이 하나의 모듈로 구성된다면 14MB의 메모리 공간이 부족하기 때문에 프로그램을 실행  X, 그러나 다수의 모듈로 분할하여 프로그램을 실행한다면 부족한 메모리 공간 문제를 해결할 수 있다.

메모리 중첩은 분할된 프로그램 조각인 모듈의 필요 여부에 따라 메모리와 보조기억장치 사이에서 모듈을 스와핑한다. 다수의 분할된 모듈을 동일한 메모리 공간에 중첩적으로 사상시키는 것. 하지만 메모리 중첩 방법은 다음과 같은 문제점이 있다.

- 프로그램을 메모리 용량에 맞게 분할하고, 프로그래머가 메모리와 보조기억장치 사이의 프로그램 모듈에 대한 스와핑을 직접 수행해야 하므로 코딩하기가 어렵다.
- 메모리 용량이 다른 컴퓨터일 경우 프로그램을 다시 코딩해야 하므로 이식성이 낮다.
- 다중 사용자 시스템의 경우 각 사용자 사이의 보호 메커니즘이 필요하다.



# 가상기억장치와 주소 변환

앞에서 메모리 중첩이 얼마나 비효율적인지 파악했다.



## 1 가상기억장치의 의미

가상기억장치는 프로세스가 사용하는 주소 공간과 컴퓨터에 설치된 메모리가 제공하는 주소 공간을 분리함으로써 프로그래머가 효율적으로 메모리를 사용할 수 있도록 해준다.

실행되는 프로세스가 사용하는 주소는 메모리에 접근하기 위해 사용하는 주소와 다르기 때문에 가상 주소라고 한다. 가상기억장치를 제공하지 않는 시스템에서는 논리 주소라는 용어를 사용하지만, 대부분의 시스템이 가상기억장치를 제공하고 있기 때문에 가상 주소와 논리 주소를 혼용한다. 한편 메모리에 접근하기 위해 사용하는 주소는 실제 주소 또는 물리주소 라고한다. 대부분의 프로그램은 전체가 동시에 실행되지 않고 지역성이 있기 때문에 부분적으로 메모리에 적재하더라도 프로그램을 실행시킬 수 있다. 

*// 주소 공간은 무엇을 의미하는가?* 메인메모리에 있음

가상기억장치는 프로세스의 일부만 메모리에 적제하고 나머지는 보조기억장치에 둠으로써 실제 주소 공간보다 더 큰 주소 공간을 프로세스에 제공할 수 있다. 가상주소 공간과 실제 주소 공간에 2개의 프로세스가 흩어져 저장된 모습을 보여주는데, 즉 프로세스 1과 프로세스2는 각각 두 부분과 세 부분만 활성화되어 메모리에 적재하고 나머지 부분을 포함한 모든 프로그램은 보조기억장치에 있다.  


모든 프로그램은 가상 주소 공간에 있지만 실제 프로그램이 실행되려면 메모리에 적재되어야 한다. 이를 위해 메모리 중첩 기법처럼 메모리와 보조기억장치 사이에 프로그램이나 데이터 조작을 교체하거나 이동하는 과정이 필요하다. 이 과정은 전적으로 운영체제에 의해 수행되므로 프로그래머에게 투명하다. 따라서 가상기억장치를 사용하면 프로그래머는 충분한 가상 공간내에서 프로세스를 실행하기 때문에 메모리 관리에 대해 자유롭다.



메모리와 가상기억장치는 프로그램이나 데이터를 페이지나 세그먼트라는 전송 단위로 분할하여 서로 교환. 그런데 모든 프로세스에 대해 자신의 주소 공간만큼의 메모리를 할당하기가 어렵거니와 또한 할당하는 것이 매우 비효율적이다. 대부분의 프로세스가 자신의 전체 주소 공간을 한꺼번에 사용하지 않기 떄문. 따라서 메모리는 가상기억장치의 페이지나 세그먼트 복사본의 일부를 가진다.



CPU가 실제 주소의 프로그램이나 데이터를 참조하는 것은 메모리에 있는 보조기억장치의 복사본을 참조하는 것, 즉 메모리에 복사본이 있다면 메모리에서 CPU로 가져와서 사용하고, 메모리에 복사본이 없다면 보조기억장치에 있는 원본을 메모리에 복제한 후 동일한 방법으로 사용하면 된다. 메모리 용량이 제한적이기 때문에 프로그램이나 데이터의 일부가 메모리에 없고 보조기억장치에만 있을 수 있다. 이와같은 경우에는 디스크 주소를 명시함으로써 보조기억장치에서 메모리로 프로그램이나 데이터의 일부를 가져와야한다.



가상기억장치는 두 가지 주소공간, 즉, 가상주소공간과 실제주소공간을 사용한다. CPU는 가상주소공간을 사용하지만 프로그램은 실제주소공간에서실행된다. 따라서 가상기억장치를 사용하면 가상주소를 실제주소로 변환하는 주소변환이라는 과정이 필요하다.



주소를 변환하기 위해 사용하는 테이블에 페이지나 세그먼트의 접근 권한을 추가하면 메모리 보호와 공유같은 기능도 부수적으로 수행할 수 있다. 또한 메모리에 접근하기 전에 동적으로 주소를 변환하기 때문에 프로그램 조각이 항상 동일한 메모리 영역을 점령하지 않고 다른 영역에 재배치될 수 있다. 메모리 재배치 Memoy relocation는 동일한 프로그램을 물리적 메모리의 위치와 관계없이 실행할 수 있도록 허용. 이렇게 가상기억장치는 재배치 기능을 제공함으로써 수행될 프로그램의 메모리 적재과정을 단순화한다. 따라서 운영체제는 실행 중인 프로세스를 위해 연속적인 공간이 아니더라도 충분한 실제 주소 공간만 확보하면 된다.



## 2 가상기억장치의 종류

가상기억장치는 보조기억장치의 일부를 메모리처럼 사용함으로써 용량이 작은 메모리를 큰 용량처럼 보이게 하는 기법. 따라서 메모리 공간이 부족하면 일부 데이터를 보조기억장치로 옮겨 메모리공간을 확보하고, CPU가 요청하면 필요한 데이터를 보조기억장치에게 메모리로 전송해야 한다.

- 페이징 방식
  : 가상 주소 공간과 실제 주소 공간을 프로그램의 논리적인 의미와 관계없이 동일한 크기인 페이지로 분할하여 페이지 단위로 두 공간 사이에 데이터를 관리하는 방식. 내부 파편화 현상이 발생한다는 문제가 있지만 페이징 기반의 가상기억장치는 다음과 같은 장점이 있다.

  \- 연속적인 메모리 공간으로 할당할 필요가 없다.
  \- 페이지 단위로 공유와 보호 기능을 제공할 수 있다.

  \- 동일한 크기인 페이지를 사용하기 때문에 간단하고 다양한 알고리즘을 적용할 수 있다.

- 세그먼테이션 방식
  ​
  : 가상주소공간과 실제주소공간을 프로그램의 논리적인 단위인 세그먼트로 분할하여 관리하는 방식. 선형 주소 공간으로 구성된 메모리는 스택과 같은 데이터 구조나 모듈과 프로시저로 구성된 프로그램을 제대로 반영할 수 없다. 그러나 메모리 관리 시스템이 다수의 주소공간을 제공할 수 있다면 프로그램 모듈이나 데이터 구조를 다양한 크기의 세그먼트라는 독립적인 개체로 관리할 수 있다.  
  가장 간단한 세그멘테이션은 하나의 프로그램 세그먼트와 하나의 데이터 세그먼트로 구성하는 것이며, 가장 복잡한 세그먼테이션 방식은 모든 논리적 구조에 대해 별도의 세그먼트로 사용하는 것.  
  \- 세그먼트를 독립적으로 컴파일하고 독립적으로 적재할 수 있다.
  \- 각 세그먼트마다 고유의 접근 권한을 부여할 수 있다.
  \- 논리적인 단위인 세그먼트로 공유와 보호 기능을 제공할 수 있다.

- 페이지화된 세그멘테이션 방식

  : 페이징 방식과 세그멘테이션 방식의 장점을 절충한 방식. 오늘날의 컴퓨터는 순수한 세그멘테이션 방식의 가상기억장치를 사용하지 않고 대부분 페이징 방식이나 페이지화된 세그먼테이션 방식의 가상기억장치를 사용.
  ​

//TODO

## 3 가상기억장치의 구성과 관리 기법

가상기억장치는 메모리, 메모리관리장치(MMU memory management unit), 보조기억장치로 구성된다. 보조기억장치는 메모리의 백업용으로 사용되며 페이징 장치(Paging device), 스왑장치(swap device)라고도 한다. 프로세서 칩에 내장된 MMU는 가상주소를 실제 주소로 변환하며, 메모리를 보호하기 위해 메모리 접근 제어, 캐시 메모리 관리, 버스 중재등의 역할을 수행한다.



가상기억장치 역시 효율적으로 운영하기 위해 캐시 메모리와 유사한 전략을 사용할 수 있다. 그러나 캐시 메모리는 속도 향상이 주된 목적이지만 가상기억장치는 프로그래머에게 확장된 메모리 공간과 메모리 보호, 공유 등을 제공하는 것이 목적이다. 따라서 가상기억장치는 캐시 메모리에 적용되는 전략을 그대로 사용할 수 없다. 다음은 가상기억장치에 일반적으로 적용되는 각종 전략이다.

- 페이지 사상
  : 가상기억장치는 페이지 부재에 의한 페널티가 기계적인 장치인 하드디스크의 접근 시간과 관련되기 때문에 매우 크다. 따라서 페이지 부재가 발생하면 많은 지연 시간이 필요하므로 페이지 사상기법으로 페이지 적중률이 높은 완전 연관 사상이나 연관도가 높은 집합 연관 사상이 효과적이다.
- 페이지 교체
  : 페이지 부재에 의한 페널티를 줄이는 교체 기법이 효과적이므로 LRU또는 유사 LRU방식을 사용
- 페이지 갱신
  : 메모리 하위 계층인 하드디스크에 쓰기 연산을 수행하는 것은 수백만 사이클을 필요로 한다. CPU의 쓰기 연산에 대한 요구마다 메모리와 하드디스크에 동시에 접근하는 즉시쓰기는 바람직하지 않다.따라서 대부분의 컴퓨터는 나중쓰기를 사용하여 메모리와 보조기억장치에 대한 데이터를 일치시킨다.

## 4 주소 변환

모든 프로그램은 가상 주소 공간을 사용하지만 실제 프로그램이 실행되려면 메모리에 적재되어야 한다. 가상주소를 실제 주소로 사상해야 하는데, 이러한 과정을 주소변환 또는 주소사상이라고 한다. 운영체제는 프로그램이나 데이터를 페이지 단위로 분할하여 메모리의 어느 영역에 적재할지를 동적으로 결정, 메모리와 보조기억장치 사이에 페이지를 통째로 전송하기 때문에 페이지 오프셋은 변경되지 않는다. 따라서 주소 변환은 가상 페이지 번호를 실제 페이지 번호로 사상하고 페이지 오프셋은 그래도 사용하면된다.

![](https://ws1.sinaimg.cn/large/006tKfTcgy1fmnfstygpxj30la0fsgt8.jpg)



## 5 가상 주소 캐시

CPU는 가상 주소를 생성하지만 메모리는 실제 주소로 접근해야 한다. 따라서 CPU와 메모리사이에 주소변환을 수행하는 MMU가 위치한다.

메모리 계층 구조에서 하나의 구성원인 캐시 메모리는 위치에 따라 다음과 같이 두가지로 분류

- 실제 주소 캐시(real addressed cache)
  : MMU와 메모리 사이에 있는 일반적인 캐시 메모리를 의미하며, 물리 주소 캐시라고도 한다. 주소 변환 과정을 거친 후 캐시 블록에 접근할 수 있다.
- 가상 주소 캐시
  : CPU와 MMU사이에 있는 캐시 메모리를 의미하며, 주소 변환을 수행하기 전 캐시 블록에 접근하기 때문에 가상 주소를 사용한다.



대부분의 캐시 메모리는 실제 주소를 사용. 그러나 주소 변환은 프로세서의 클록사이클을 결정하는 임계 경로 위에 존재하므로 주소 변환 과정은 프로세서의 지연 시간에 매우 민감한 영향을 미친다. 따라서 가상 주소로 캐시 메모리에 접근하면 CPU가 요쳥한 데이터를 빠른 시간 내에 구할 수가 있다. 그러나 가상 주소 캐시는 2개의 가상 주소가 동일한 실제 주소로 사상되는 별명 또는 동의어 현상과 같은 다양한 문제를 유발한다.



# 기본적인 주소 변환 기법

동적 재배치에 필요한 주소변환은 다양한 방법으로 수행가능한데, 기본적으로 재배치 레지스터, 페이지 테이블, 세그먼트 테이블등을 이용한 주소변환메커니즘이 있다.

## 1 재배치 레지스터 방식

오래된 컴퓨터의 메모리 관리 시스템은 재배치 레지스터를 사용하여 동적 재배치를 수행. 이 방식의 프로세서는 실제 주소 공간보다 작거나 동일한 가상 주소 공간을 사용해야 한다.프로세스가 메모리에 적재되면 재배치 레지스터는 적제된 실제 주소 공간의 시작 주소를 가지고, 그 후에 메모리를 참조할 때마다 가상 주소가 재배채 레지스터의 내용과 합산됨으로써 실제 주소로 이용.

프로세스가 변경될 때마다 재배치 레지스터는 프로세스가 적제된 실제 주소 공간의 시작 주소로 갱신되며, 따라서 프로세스를 재배치하는 것은 재배치 레지스터를 갱신을 의미.



재배치 레지스터와 보호 레지스터가 쌍으로 활용되어 주소 변환 방식이 이루어진다.  
그러나 다음의 방식은 몃가지 문제가 있다.

- 각 프로세스가 연속된 공간의 메모리를 확보해야한다.
- 모든 프로세스를 위한 가상 주소 공간의 합이 메모리의 용량을 초과할 수 없다.

## 2 페이지 테이블 방식

 페이징 기법은 메모리와 가상기억장치를 페이지 단위로 분할. 메모리의 페이지를 보조기억장치의 페이지와 구분하기 위해 페이지 프레임또는 프레임이라고도 하는데, 페이지 프레임은 비어 있을 수도 있고 보조기억장치의 페이지 복사본일수도 있다.

페이지 테이블 방식은 페이지와 페이지 프레임을 사상시키는 테이블을 사용하여 주소 변환을 수행. 프로세스가 사용하는 페이지 테이블의 위치는 페이지 테이블 레지스터가 지시한다. 따라서 프로세스가 전환될 때마다 PTR은 활성화되는 프로세스의페이지 테이블을 가리킨다.

![](https://ws1.sinaimg.cn/large/006tKfTcgy1fmnfyqu8l2j30xk0g048p.jpg)

- **물리 페이지 번호** : 페이지 프레임 번호
- **제어 부분**: 페이지에 대한 접근 권한 필드와 페이지가 메모리에 존재하는지를 나타내는 유효비트등으로 구성된다.  
  유효비트를 점검해서 0이면 페이지 부재 시그널을 CPU에 보내어 보조기억장치에서 페이지를 메모리로 전송하고 PTE를 갱신.



오늘날의 컴퓨터의 페이징 시스템에서 일반적으로 사용하는 요구 페이징(demand paing)은 실행중인 프로그램의 필요한 페이지만 메모리에 확보하고 나머지 페이지는 보조기억장치에 둔다. 따라서 요구 페이징의 경우, 프로세스의 크기에 해당하는 모든 페이지 프레임을 한꺼번에 확보할 필요가 없으므로 재배치 레지스터를 이용한 주소 변환 기법의 두 번째 문제 해결 그러나 다음과 같은 문제가 있다.

- 명령어나 데이터를 참조하기 위해 메모리에 두번 이상 접근해야 한다.
- 페이지 테이블이 메모리 공간을 너무 많이 사용
- 페이지 내부 파편화가 발생

## 3 세그먼트 테이블 방식

세그먼테이션 기반의 가상기억장치는 프로그램을 프로시저, 모듈등과 같이 논리적 의미를 고현 세그먼트 단위로 분할하기 때문에 분할된 조각의 크기가 고정되어 있지 않다. 세그먼테이션 기반의 가상기억장치는 각 프로세스에 다수의 세그먼트를 제공하며, 세그먼트 테이블을 이용하여 주소를 변환한다. 그런데 세그먼트 테이블의 크기는 프로세스의 논리적 크기에 따라 달라지므로 필요한 용량을 가늠할 수 없다. 세그먼트 테이블 방식의 주소변환도 데이터를 참조하려면 두 번 이상 메모리에 접근해야 하는 등 페이지 테이블 방식과 유사한 문제가 발생한다.  

페이지화된 세그먼테이션 방식의 주소 변환은 페이지 테이블과 세그먼트 테이블을 모두 이용하여 주소 변환을 수행. 프로그램과 데이터를 논리적 단위인 세그먼트로 나누고, 세그먼트를 고정된 크기의 페이지로 나누어 관리한다. 그러므로 이 방식은 가상 주소를 세그먼트 번호(SN), 세그먼트 내의 페이지 번호(VPN), 페이지 오프셋과 같이 3개의 필드로 분해하여 주소 변환을 수행. 세그먼트 테이블 레지스터(STR)는 세그먼트 테이블의 시작 주소를 나타내고, 세그먼트 테이블의 각 엔트리는 대응하는 페이지 테이블을 가리킨다.

- 페이지 테이블 포인터(PTP)
  : 세그먼트를 구성하는 페이지 테이블의 시작주소를 명시
- 세그먼트 크기
  : 세그먼트는 프로그램과 데이터를 논리적으로 분할한 것으로 세그먼트마다 크기가 다르기 때문에 명시
- 제어 부분
  : 세그먼트에 대한 접근 권한을 명시. 유효비트가 없다. 왜냐? 

![](https://ws4.sinaimg.cn/large/006tKfTcgy1fmngf58lrmj318o0qawws.jpg)



# 향상된 주소변환 방식

## 1 역방향 페이지 테이블 방식

페이지 테이블 방식은 가상 페이지 마다 하나의 페이지 엔트리가 있다. 그러나 물리 페이지 번호를 포함하지 않는 페이지 엔트리는 실제 주소 공간으로 사상할 수 없으므로 주소 변환에 사용될 수 없다. 따라서 페이지 테이블에서 물리 페이지 번호를 포함한 엔트리만 유용하기 때문에 가상 페이지 번호 대신에 물리 페이지 번호를 기준으로 주소 변환테이블을 생성할 수 있다.



 일반적으로 링크 필드에 연결된 엔트리의 수는 1~2개 정도로 알려져 있지만 링크 필드에 연결된 엔트리가 많다면 주소를 변환하는 데 많은 시간이 걸릴 수 있다. 이를 극복하기 위해 테이블을 캐시 메모리에 저장하여 주소 변환 속도를 향상하지만 해시 함수는 캐시 메모리의 지역성, 특히 공간적 지연성이 매우 취약하다. 또한 해시 값에 의해 사상되는 엔트리가 테이블에 흩어져 있어서 주어진 테이블 공간을 효율적으로  사용하기 어렵다. 그리고 하나의 데이터를 참조하기위해 페이지 테이블 방식처럼 메모리에 두번 접근해야 한다.



## 2 변환 색인 버퍼 방식

페이지 테이블도 명렁어나 데이터처럼 지역성이 있으므로 접근 속도를 향상하고 저장 공간을 확대하기 위해 메모리 계층 구조 방식을 이용할 수 있다. 즉, 페이지 테이블 중 최근에 참조된 주소 변환 정보를 캐시 메모리에 저장함으로써 주소 변환을 위한 메모리 접근을 없애고, 또한 당장 이용하지 않는 페이지 테이블을 보조기억장치에 둠으로써 페이지 테이블이 메모리를 차지하는 비율을 줄일 수 있다.

페이지 테이블 방식의 문제를 극복하기 위해 도입된 특수한 캐시 메모리를 변환 색인 버퍼(TLB)라고 부르기 때문에 이 방식을 TLB(translation lookaside buffer)라고 부르기 때문에 이 방식을 TLB를 이용한 주소 변환 방식이라 한다. 그런데 이 방식에서 TLB는 최근에 참조된 주소 변환 테이블 엔트리를 보관하지만 주소 변환 테이블의 구성요소를 페이지 테이블 방식대로 사용하면 주소 변환을 수행할 수 없다. 페이지 테이블 전체가 없다면 페이지 테이블 VPN정보를 포함하지 않기 때문이다.



//TODO 그림만 그래서 이해해보기