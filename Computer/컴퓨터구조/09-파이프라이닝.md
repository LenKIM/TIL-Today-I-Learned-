

파이프라이닝?

오늘날의 컴퓨터에서 프로세서의 성능을 개선하는데 사용하는 가장 보편적인 구현 기술.
명령어를 읽어 순차적으로 실행하는 프로세서에 적용되는 기술로, 한 번에 하나의 명령어만 실행하는 것이 아니라 하나의 명령어가 실행되는 도중에 다른 명령어 실행을 시작하는 식으로 동시에 여러 개의 명령어를 실행하는 기법이다.


프로세서의 성능에 영향을 미치는 요소로

프로그램에 포함된 **명령어의 수**, 하나의 명령어 실행에 필요한 **평균 사이클의 수인 CPI**, **클록 사이클 시간**



- 명령어의 수 : 좋은 알고리즘 또는 컴파일러를 통한 최적화
- 클록 사이클 시간 : 최신 하드웨어 기술
- 평균 CPI : 병렬 처리, 파이프라이닝, 슈퍼스칼라 파이프라이닝, 슈퍼파이프라이닝, VLIW(very long instruction word)

#  #

**순차적 세탁 시스템**

**병행 세탁 시스템**

여기서 병행 세탁 시스템이 파이프라이닝 기법  


동기식 방식과 비동기식 방식의 차이와 유사  

컴퓨터 시스템에서도 데이터 경로를 여러 단게로 분할하여 명령어가 수행할 작업을 병행 처리한다면 성능이 향상 될 것이다. 이와 같은 기법을 파이프라이닝이라고 하며, 분할된 시스템의 각 파이프라인 단계를 파이프(pipe), 파이프의 수를 파이프라인의 깊이(depth)라고 한다.



더욱 성능을 극대화하기 위한 방법은?

- 강력하거나 복합적인 명령어는 데이터 경로의 일부 단계를 두번 이상 사용할 수 있다.
- 선행 명령어가 후행 명령어에 영향을 미칠 수 있다.
- 분기 명령어에 의해 명렁어의 실행 순서가 달라질 수 있다.



## 순차 처리와 병행 처리



- 순차 처리 : 클록 시간이 T라면 n개의 데이터를 처리하는 시간은 nT 
- 병렬 처리
- 병행 처리
  : n개의 데이터를 처리하는 시간은 약 nT/2이고, 평균 처리 시간은 T/2에 가까워 진다.
  ​

즉, 병렬 처리와 병행 처리는 순차 처리에 비해 약 2배 빠르다.

이때 병렬 처리는 또 다른 프로세서를 추가해야 할 뿐만 아니라 디멀티플렉서, 토글 스위치등과 같은 하드웨어 자원이 필요하므로 단일 프로세서를 사용하는 순차 처리에 비해 많은 비용이 든다. 그러나 병행 처리는 하나의 프로세서를 2개로 분할하고 래치(latch)만 추가할 뿐 추가 비용을 거의 들이지 않고 2배의 성능 향상을 도모할 수 있다. 이와같은 병형 처리 기법이 바로 파이프라인 방식이다.



### 파이프라이닝의 성능

- 클록 주기 T
- m단계로 균등하게 분할된 파이프라이닝
- 래치에 대한 지연 시간 L
- 처리할 데이터의 수 n


*래치는 무엇인가?*  
래치는 플립플롭으로  1 [비트](https://ko.wikipedia.org/wiki/%EB%B9%84%ED%8A%B8)의 [정보](https://ko.wikipedia.org/wiki/%EC%A0%95%EB%B3%B4)를 보관, 유지할 수 있는 회로이며 [순차 회로](https://ko.wikipedia.org/wiki/%EB%85%BC%EB%A6%AC_%ED%9A%8C%EB%A1%9C)의 기본요소이다


결론적으로 파이프라인 구조가 이상적인 성능 향상을 이루려면 래치 지연시간을 포함하여 다음과 같은 문제점을 해결해야한다.  

- 래치 지연시간이 파이프 지연 시간에 비해 무시할 수 있을 정도로 작아야 한다.
- 처리할 데이터가 충분해야 한다.
- 파이프라인의 각 단계를 균등하게 분할해야 한다. 즉, 각 파이프의 크기가 거의 동일해야 한다.
- 하나의 파이프에서 이웃한 파이프로 데이터를 이동할 때 동기화되어야 한다.
- 명령어나 데이터 사이의 의존성이 없어야 한다.

그러나 파이프라인의 깊이가 커지면 래치 지연시간과 파이프 지연 시간이 상태적으로 커진다. 또한 데이터가 충분하지 않을 수도 있다. 그리고 파이프라인의 클록 주기가 작아지면 **클룩스큐(Clock skew)**가 발생한다. 따라서 프로세서의 성능을 향상하기 위해 데이터 경로를 무한정 분할하기 어려울 뿐만 아니라, 7장과 8장에서 살펴보았듯이 명령어 실행의 작업을 균등하게 분할하기도 어렵다.



*클록스큐*  
일정한 간격의 전기적 신호를 의미하는 클록에서 클록 사이에서 존재하는 시간적인 편차를 의미한다!  
파이프 라인의 깊이가 얕을 때는 클록 스큐에 대한 영향이 미미하지만 파이프라인의 깊이가 깊어지면 심각한 영향을 줄 수 있다.





## 해저드

파이프라이닝 기법을 사용하면 명령어 실행이 중첩되기 때문에 프로세서의 성능이 향상된다. 이상적인 경우라면 m단계 파이프라이닝 기법을 도입했을 때 m배 성능이 향상되겠지만, 실제로는 다양한 이유로 성능이 크게 떨어진다. 이 절에서는 파이프라인 기법의 성능향상에 걸림돌인 해저드의 의미와 그 해결방안에 대해 살펴본다.



해저드?

- 구조적 해저드(자원 해저드)
  : 파이프라인에서 실행 중인 2개 이상의 명령어가 동일한 하드웨어 자원을 동시에 요구하기 때문에 파이프라인을 멈춰야 하는 상황을 구조적 해저드라고 한다.

  이를 해결하기 위해서는 어떻게? 충돌하는 자원을 추가로 제공하여 파이프라인을 재구성하거나, 예약표(Reservation table)을 이용하여 자원 충돌을 방지. 만약 레지스터 파일이나 메모리에서 충돌이 발생하면 읽기나 쓰기가 동시에 처리될 수 있도록 다중 포트화(multi-port)하거나 둘 이상으로 분할함으로써 구조적 해저드를 일부 해조, 그렇지 않을 경우에는 충돌되는 자원을 필요로 하는 명령어 사이에 파이프라인 버블, 즉NOP 명령어를 삽입해야 한다.

- 데이터 해저드
  : 연산할 데이터가 준비되지 않아 파이프라인을 멈춰야 하는 모든 상황이나 조건을 데이터 해저드. 데이터 해저드는 주로 선행 명령어가 사용하는 데이터와 후행 명령어가 사용하는 데이터 사이의 종속 관계로 인해 발생하므로 데이터 종속이라고도 한다.

  - 쓰기 후 읽기(RAW read after write)
  - 읽기 후 쓰기(WAR write after read)
  - 쓰기 후 쓰기(WAW write after write)

- 명령어 해저드
  : 실행할 명령어가 결정되지 않았거나 준비되지 않아서 파이프라인을 멈춰야하는 상황이나 조건을 명령어 해저드라고 한다. 이는 주로 분기 명령어에 의해 발생하기 때문에 분기 해저드 또는 제어 해저드라고도 한다. 데이터 해저드가 데이터의 가용성에 대한 지연으로 발생한다면, 명령어 해저드는 명령어의 가용성에 대한 지연으로 발생.



파이프라인 해저드는 해저드의 원인이 사라질 때까지 파이프라인에의 명령어 투입을 멈춰야 하는데 이를 파이프라인 중지(pipeline stall) 또는 파이프라인 버블 이라고 한다. 파이프라인 버블이 많아지면 성능향상에 방해가 되기 때문에 이를 위한 다양한 해결책이 필요하다. 소프트웨어적으로는 컴파일러의 도움으로 명령어의 순서를 변경하는 방법이 있고, 하드웨어적으로는 파이프라인을 다시 설계하거나 하드웨어 자원을 추가함으로써 파이프라인 버블을 해결할 수 있다.



## 해결방안

- 전방 전달과 지연 적재
  : 결과를 생성하는 파이프의 출력과 결과를 사용하는 파이프의 입력을 연결하는 별도의 경로를 추가하면 되는데, 이와같은 기법을 전방 전달 / 컴파일러의 도움으로 적재 명령어의 결과와 무관한 명령어의 순서를 바꾸는 기법을 지연적재라고 한다.

- 지연 분기와 분기 예측
  지연 슬롯을 분기 명령어와 관계없는 명령어로 채운다면 명령어 해저드의 영향을 줄일 수 있다. 지연 슬롯에 채워질 유용한 명령어를 찾는 것은 지연 적재와 마찬가지로 컴파일러의 몫이다. 무조건 분기 명령어의 경우에는 지연 슬롯을 채우기가 쉽지만 조건 분기 명령어의 경우에는 그렇지 않다.  지연 분기는 명령어 해저드를 줄이는 간단한 방법이지만 다음과 같은 문제가 있다.

  - 컴파일러가 2개 이상의 분기 지연 슬롯을 채우기 어렵다.
  - 지연 적재와 마찬가지로 지연 슬롯에 채워진 명령어는 실제 프로그램의 순서와 다르다. 따라서 인터럽트와 같은 돌박적인 상황이 발생할 경우 매우 복잡해진다.

  지연 분기는 반복문의 경우에 유용, 분기될 때는 반복문을 제어하기 위한 분기 명령어의 다음에 위치한 명령어를 실행하고, 분기되지 않을 때는 취소하면 되기 때문.

  분기 예측은 분기 명령어의 분기 여부를 예측함으로써 분기 명령어 다음에 수행될 명령어를 미리 파악하는 방법, 그러나 예측이 잘못되었을 때 투입된 명령어를 취소하여 원래대로 회복시키는 조치가 필요하므로 다소 복잡하다. 



*분기란 무슨말인가?*

*해저드 해결방안 이해가 잘 안됨.*

### 인터럽트와 공격적 파이프라이닝

#### 인터럽트

파이프라인 구조에서도 인터럽트가 발생하면 인터럽트를 처리하기 위한 마이크로 연산을 수행해야 한다. 모든 명령어의 동작은 명령어 사이클을 통해 수행되므로 인터럽트 요구를 처리할 수 있는 새로운 부사이클, 즉 인터럽트 사이클이 필요하다.  


만약 인터럽트 요구가 있다면 파이프라인에 투입된 다수의 명령어 중 어느 것이 언터럽트의 원인인지 찾아내고, 파이프라인에 있는 명령어를 파이프라인에서 제거.



정확한 인터럽트와 부정확한 인터럽트

오늘날 대부분의 파이프라인 구조는 인터럽트의 영향이 순차 모델과 동일한 정확한 인터럽트를 지원한다. 이를 위해 수행 중인 명령어가 취소되더라도 프로세서의 상태에 영향을 미치지 않도록 파이프라인 내부의 역사파일 또는 미래파일 등을 사용한다.



#### 공격적 파이프라이닝



IPC(Instruction per cycle) 는 CPI 의 역수이다.

IPC > 1을 만들기 위해 다음과 같은 기술 활용.

1. 슈퍼파이프라이닝
   \- 파이프라인에서 각 단계의 클록 주기를 절반 이하로 줄여서 명령어의 실행속도를 2배 이상 향상하는 기술. 즉 파이프라인의 각 파이프를 다시 파이프라인화하여 성능을 개선한다. 

2. 슈퍼스칼라 파이프라이닝
   \- 파이프라인닝과 병렬 처리를 혼합한 형태로, 줄여서 슈퍼스칼라. 이는 하나의 프로세서 내부에 다수의 파이프라인을 장착함으로써 사이클마다 상호 의존성이 없는 다수의 명령어를 투입하여 병행적으로 실행시키는 기술. 병행적으로 실행시키기 위해 동적 스케줄링을 활용하는데, 이 때문에 명령어 투입 로직이 매우 복잡하다.

   1. 다음에 실행할 여러 개의 명령어를 혼합하여 재정리해야한다.
   2. 데이터 의존성이나 자원 필요성등을 점검해야 한다.
   3. 병행적으로 실행할 수 있는 다수의 명령어를 파이프라인에 투입

    그러나 기존의 실행파일을 그대로 사용할수 있다는 장점 떄문에 오늘날 대부분의 컴퓨터는 슈퍼스칼라 방식을 도입.  그러나 파이프라인의 깊이를 크게하는데 한계가 다음과 같다.

   - 깊은 파이프라인은 클록스큐 현상에 민감해진다.
   - 데이터 혹은 명령어의 종속성에 의한 파이프라인 제거현상이나 캐시실패에 의한 파이프라인 중지 등과 같은 현상이 심화된다.
   - 파이프라인의 깊이가 증가하면 클록속도가 빨라지고, 클록 속도의 상승으로 발열이 심해 냉각 문제가 심각해진다.

3. VLIW
   하드웨어 대신에 컴파일러가 ILP(명령어 수준 병렬성 - instruction level parallelism)을 찾아주는 방식, 컴파일러가 ILP를미리 찾아서 명시적으로 병렬 처리할 수 있는 명령어 조합을 프로세서에 보내는 것, VLIW는 병렬로 실행할 수 있는 명령어 조합을 명시한 긴 명령어 워드를 의미한다. 이는 하드웨어 대신 소프트웨어를 활용하기 때문에 칩 공간을 덜 사용하고 발열량이 작지만, 다음과 같은 단점을 가진다.

   - 전통적 아키텍처와의 호환성이 없기 때문에 원시 코드를 다시 컴파일해야 한다.
   - 컴파일 단계에서 정적으로 동시에 수행할 수 있는 명령어 조합을 찾아야 하므로 컴파일러 설계가 어렵다.
   - 정적 스케줄링에 의존하므로 ILP의 활용이 제한적
   - 어셈블리 프로그래밍이 힘듬

   따라서 VLIW는 예측이 용이하고 복잡하지 않은 DSP(Digital signal processor)나 GPU와 같은 특수 목적용 또는 임베디드 시스템용 설계기술로 활용
   ​

4. 위 명령어보다 단위가 큰 스레드 수준 병렬성을 이용하는 동시 다중 스레딩(SMT)
   동시 다중 스레딩은 하이퍼스레딩이라도 불리며, 레지스터 파일 등을 복제함으로써 논리적으로 프로세서의 수를 확장하는 기술이다.





*이상적인 파이프라이닝이란? 무엇을 말하는 걸까?*

\- 무시할 수 있을 정도로 작은 래치 지연시간, 충분한 데이터, 동일한 크기의 파이프라는 조건을 만족해야 하며, 명령어나 데이터 사이의 의존성에 의한 해저드가 없어야 한다.



*슈퍼파이프라이닝과 슈퍼스칼라 파이프라이닝은 무엇을 말하는 것인가?*

\- 슈퍼파이프라이닝은 파이프라이닝의 깊이를 증가시켜 더욱 많은 명령어를 중첩시키는 것, 슈퍼스칼라 파이프라이닝은 파이프라인을 여러 개 복제하여 사이클마다 다수의 명령어를 파이프라인에 투입하는 것.



