데이터베이스 트랜잭션 이해하기

출처 : [http://blog.sapzil.org/2017/04/01/do-not-trust-sql-transaction/](http://blog.sapzil.org/2017/04/01/do-not-trust-sql-transaction/)

트랜잭션이란? 조작단위를 말하는 것으로, 연관된 일련의 조작을 의미합니다.

```sql
# CREATE TABLE account (id integer, money integer, state text);
# INSERT INTO account (id, money, state) VALUES (1, 10, 'poor');

tx = begin()
state = tx.query("SELECT state FROM account WHERE id = 1")
if state == "poor":
    tx.query("UPDATE account SET state = 'rich', money = money * 1000 WHERE id = 1")
tx.commit()
```

이런 코드가 동시에 다음 순서로 실행되면 어떤 일이 벌어질까?

| trx1                                                         | Trx2                                                         |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| BEGIN                                                        |                                                              |
| SELECT state FROM account WHERE id = 1                       |                                                              |
|                                                              | BEGIN                                                        |
|                                                              | SELECT state FROM account WHERE id = 1                       |
|                                                              | UPDATE account SET state = 'rich', money = money  * 1000 WHERE id =1; |
|                                                              | COMMIT                                                       |
| UPDATE account SET state = 'rich', money = money * 1000 WHERE id = 1 |                                                              |
| COMMIT                                                       |                                                              |

money는 10,000,000이 됩니다.



SQL 표준에서 isolation level은
READ UNCOMMITTED  
READ COMMITTED  
REPEATABLE READ  
SERIALIZABLE  

이렇게 총 4 가지가 존재합니다. SERIALIZABLE이 가장 높은 격리수준이지만 성능 상의 이유로 MySQL에서는 REPEATABLE READ, PostgreSQL은 READ COMMITTED가 기본값입니다.

이러한 기본 isolation level에서 `UPDATE` 쿼리는 대상 레코드를 다른 트랜잭션이 먼저 업데이트한 뒤 커밋된 경우 업데이트 된 데이터를 보게 됩니다.

> … a target row might have already been updated (or deleted or locked) by another concurrent transaction by the time it is found. In this case, the would-be updater will wait for the first updating transaction to commit or roll back (if it is still in progress). … If the first updater commits, the second updater … **will attempt to apply its operation to the updated version of the row.** [(Postgres 문서)](https://www.postgresql.org/docs/current/static/transaction-iso.html#XACT-READ-COMMITTED)

> The snapshot of the database state applies to SELECT statements within a transaction, not necessarily to DML statements. If you insert or modify some rows and then commit that transaction, a DELETE or UPDATE statement issued from another concurrent REPEATABLE READ transaction could affect those just-committed rows, even though the session could not query them. [(MySQL 문서)](https://dev.mysql.com/doc/refman/5.7/en/innodb-consistent-read.html)



해결책

### Isolation level 높이기

MySQL에서는 SERIALIZABLE 밖에 답이 없는데 이 경우에 항상 락이 걸리므로 현실적으로 사용하기 힘듬.

Postgres는 REPEATABLE READ로 올리면 이러한 문제가 없습니다. 대신 트랜잭션 A가 `UPDATE`를 시도할 때 트랜잭션이 중단되어 버리므로 애플리케이션 단에서 전체 트랜잭션을 처음부터 재시도해야 합니다.

> a target row might have already been updated (or deleted or locked) by another concurrent transaction by the time it is found. In this case, the repeatable read transaction will wait for the first updating transaction to commit or roll back (if it is still in progress). … if the first updater commits (and actually updated or deleted the row, not just locked it) then the repeatable read transaction **will be rolled back** with the message `ERROR: could not serialize access due to concurrent update` because a repeatable read transaction cannot modify or lock rows changed by other transactions after the repeatable read transaction began. [(Postgres 문서)](https://www.postgresql.org/docs/current/static/transaction-iso.html#XACT-REPEATABLE-READ)

### `SELECT FOR UPDATE` 사용

업데이트 할 레코드를 가져올 때 `SELECT` 쿼리 대신 `SELECT FOR UPDATE` 문을 사용하면 락이 걸립니다. 그러면 트랜잭션 B가 읽기를 시도할 때 트랜잭션 A가 커밋 (또는 롤백)되기까지 기다리게 되므로 문제가 발생하지 않습니다.

### `UPDATE` 한번에 모든 것을 처리

`SELECT`를 하지 말고 `UPDATE account SET state = 'rich', money = money * 1000 WHERE id = 1 AND state = 'poor'`와 같이 처리할 수도 있습니다. 이렇게 하면 로직이 애플리케이션 코드에서 SQL로 옮겨가기는 하지만 마지막으로 커밋된 데이터를 기준으로 작동해서 문제가 발생하지 않습니다.



### 낙관적(optimistic) 락

테이블에 버전 필드를 추가해서 `SELECT`할 때 가져옵니다. 그리고 `UPDATE`할 때 WHERE 절에 기존 버전을 추가하고 +1된 버전으로 업데이트를 시도합니다. 업데이트 된 레코드 수를 검사해서 0개라면 다른 트랜잭션에서 버전이 변경된 것을 알 수 있습니다. 이렇게 **충돌**을 감지한 경우 애플리케이션 단에서 전체 트랜잭션을 처음부터 재시도해야 할 수도 있습니다.

[http://feco.tistory.com/45](http://feco.tistory.com/45)

## 1. 트랜잭션이 보장해야 하는 ACID

- 원자성 (Atomicity) : 한 트랜잭션 내에서 실행한 작업들은 하나의 작업으로 간주한다. 모두 성공 또는 모두 실패되어야 한다. 
- 일관성 (Consistency) : 모든 트랜잭션은 일관성 있는 데이타베이스 상태를 유지한다. 이를테면 DB에서 정한 무결성 조건을 항상 만족.
- 격리성 (Isolation) : 동시에 실행되는 트랜잭션들이 서로 영향을 미치지 않도록 격리 해야한다.
- 지속성 (Durability) : 트랜잭션을 성공적으로 마치면 그 결과가 항상 저장되어야 한다.

이 중 격리성(Isolation)에 대한 이슈가 있다.

> 격리성을 완벽히 보장하기 위해 모든 트랜잭션을 순차적으로 실행한다면 동시성 처리 이슈가 발생한다. 반대로 동시성을 높이기 위해 여러 트랜잭션을 병렬처리하게 되면 데이터의 무결성이 깨질 수 있다.

격리성과 동시성으로 부터 파생되는 문제점부터 살펴 보자.

## 2. 격리성 관련 문제점 

### (1) Dirty Read

한 트랜잭션(T1)이 데이터에 접근하여 값을 'A에서' 'B'로 변경했고, 아직 커밋을 하지 않았을때, 다른 트랜잭션(T2)이 해당 데이터를 Read하면?
T2가 읽은 데이터는 B가 될 것, 하지만 T1이 최종 커밋을 하지 않고 종료된다면, T2가 가진 데이터는 꼬이게 된다.

### (2) Non-Repeatable Read

한 트랜잭션(T1)이 데이터를 **Read**하고 있다. 이때 다른 트랜잭션(T2)가 데이터에 접근하여 값을 변경 또는, 데이터를 삭제하고 커밋을 시도하게 된다면? 그 후 T1이 다시 해당 데이터를 Read하고자 하면 변경된 데이터 혹은 사라진 데이터를 찾게 된다.

### (3) Phantom Read

트랜잭션(T1)중에 특정 조건으로 데이터를 검색하여 결과를 얻었다. 이때 다른 트랜잭션이 접근해 해당 조건의 데이터 일부를 삭제 또는 추가했을때, 아직 끝나지 않은 T1이 다시 한번 해당 조건으로 데이터를 조회하면 T2에서 추가/삭제된 데이터와 함께 조회/누락 된다. 그리고 T2가 롤백을 하면? 데이터가 꼬인다.



## 3. 트랜잭션 격리수준

위와 같은 문제들 때문에, ANSI표준에서 트랜잭션의 격리성과 동시 처리 성능 사이의 Trade-off를 두고 4단계 격리수준을 나누었다. 내려갈수록 격리 수준이 높아져서 언급된 이슈는 적게 발생하지만, 동시 처리 성능이 떨어진다.

참고로, 트랜잭션이 발생하면 락(Lock)이 걸리는데, SELECT시에는 **공유 락**, CREATE/INSERT/DELETE/ 시에는 **배타적 락**이 걸린다.

### (1) Read Uncommitted

**한 트랜잭션에서 커밋되지 않은 데이터에 다른 트랜잭션이 접근 가능하다. 즉, 커밋하지 않은 데이터를 읽을 수 있다.**

> 이 수준은 당연히 위에서 언급한 모든 문제에 대해 발생가능성이 존재한다. 대신, 동시 처리 성능이 가장 높다.

- 발생 문제점 : Dirty Read, Non-Repeatable Read, Phantom Read

### (2) Read committed

**커밋이 완료된 데이터만 읽을 수 있다.**

> Dirty Read가 발생할 여지는 없으나, Read Uncommitted 수준보다 동시 처리 성능은 떨어진다. 대신 Non-Repeatable Read 및 Phantom Read는 발생 가능하다. 데이터베이스들은 보통 Read Committed를 디폴트 수준으로 지정한다.

- 발생 가능성 : Non-Repeatable Read, Phantom Read

### (3) Repeatable Read (MySQL 기본 값)

트랜잭션 내에서 한번 조회한 데이터를 반복해서 조회해도 같은 데이터가 조회된다.

> 이는 개별 데이터 이슈인 Dirty Read나 Non-Repeatable Read는 발생하지 않지만, 결과 집합 자체가 달라지는 Phantom Read는 발생가능하다.

- 발생 문제점 : Phantom Read

### (4) Serializable

**가장 엄격한 격리 수준**

**위 3가지 문제점을 모두 커버 가능하다.** 하지만 동시 처리 성능은 급격히 떨어질 수 있다.