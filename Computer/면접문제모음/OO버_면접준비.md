1. ​

2. **프로젝트 질문**

4. **Android 생명주기**

   onCreate()
   onStart()
   onResume()

   onPause()
   onStop()
   onDestory()

   그리고 onStop에서 onStart() 갈 경우 중간에 onRestart()가 존재

   만약 홈버튼을 눌렀을 때는 onPause 상태에서 onResume으로 간다.
   화면을 뒤집을 경우 onPause => onStop => onDestroy => onReInstance() => onStart() => onResume() //TODO

   ​

5. 정렬의 복잡도

   선택정렬 / 버블 정렬 / 삽입 정렬 - worse O(n^2) 
   퀵 정렬 / 병합 정렬 - 가장 워스트한 것이 O(nLogn)

   //TODO 힙정렬과 기수 정렬 구현

   ​

6.  대규모의 문자열을 탐색 할때 어떻게 하겠는가?
   일반적으로 그냥 쭈욱 탐색하면서 하는 방법이 일반적인 방법이라면 이러한 방법은 O(N*M) 이것보다 효율적인 방법은?  
   KMP알고리즘을 활용해 시간복잡도를 O(N+M)으로 줄이겠습니다. http://bowbowbow.tistory.com/6  
   //TODO 구현 백준 1786 접두사와 접미사를 활용, pi배열

6. 사용하는 IDE는 IntelliJ, androidStudio. 

   왜 이걸 쓰는가? 처음에는 안드로이드 스튜디오의 단축키에 익숙해져서 인텔리제이를 쓰게 되었지만 이클립스와 비교해 인텔리제이가 좋은 이유는 Code Assist가 안정적이고, 프로그램이 무거워졌을 때 이클립스에서 발생하던 문제를 해결해준다. 왜 Code Assist가 좋은 이유는 자바의 경우 C와 달리 작성해야 클래스부터 new, 키워드 등 입력해야 되는 것이 많다. 그래나 Code Assist를 활용하면 개발시간을 단축시킬 수 있어서 좋다. 그러나 유료라는 단점이 있어 아쉬운 부분이다.

8. Async / sync의 차이점은?

   비동기적인 방식과 동기적 방식의 차이는 예를 들어 설명해 볼 수 있다. 비동기의 방식의 경우 내가 은행도 가야되고 세탁소도 들려야 되고 과일가게도 들려야 한다면 심부름꾼을 통해 각각의 업체에 한명씩 보내고 돌아오는 것만 확인하면 된다. 그러나 동기적 방식의 경우에는 내가 직접 은행을 가서 볼일을 해결하고, 세탁소에가서 볼일을 해결하고, 과일가게에 가서 직접 해결해야 한다. 

9. Search 알고리즘 손코딩

10. 정렬되지 않은 알고리즘에 대한 효율적인 방법은 무엇일까?

    어떤 데이터냐 따라 다르겠지만 엄청나게 많은 데이터라면 최악의 상황에서도 nLogn을 보장해주는 쿽정렬을 활용하고, 일정부분 정렬된 데이터라면 삽입정렬을 통해 O(n)속도로 정렬을 실행합니다.

    // 책보고 다시한번 정리하기.

11. Http와 Https의 차이점을 말해주시오.

    HTTP는 일반적으로 응용계층에서 평문으로 데이터를 주고받는 것을 말합니다. 그러나 HTTP에는 여러 문제점을 안고 있어 이를 해결하기 위해 HTTPS가 나왔다고 할 수 있습니다.  
    HTTP의 문제점은 평문으로 데이터를 주고받기 때문에 도청이 가능합니다.  
    또한 통신 상대를 확인하지 않기 때문에 위장이 가능합니다. 그리고 마지막으로  
    완전성을 증명할 수 없기 때문에 변조가 가능합니다.

    이러한 문제점을 해결하기 위해 헤더와 바디로 구성된 HTTP 구조에 SSL(시큐어리티 소켓 레이어)라는 층을 추가해 위 문제점을 해결합니다. HTTP의 메시지를 해쉬를 통해 암호화하여 중간에 가로채지 못하도록 하며, 또한 통신 상대가 누구인지 인증된 사람만이 수신할 수 있도록 해줍니다. 이렇게 해서 HTTPS는 HTTP의 보안을 더한 프로토콜이라고 말할 수 있습니다.

    그럼 왜 HTTPS을 쓰지 않는가?  
    이유는 HTTPS를 활용하면 통신할 때마다 암호화방식을 활용하는데 이는 CPU나 메모리의 리소스를 많이 소모하게 됩니다. 그렇게 되면 서버 한 대당 처리할 수 있는 리퀘스트의 수가 들어들어 효율성이 떨어집니다. 때문에 민간한 정보를 다룰때만 HTTPS를 활용합니다.

12. Blocking과 Non-blocking의 차이는?  
    I/O작업에서 Blocking으로 동작할 경우 해당 I/O가 끝날 때까지 대기해야하고 (I/O가 끝나기 전에는 함수가 반환되지 않는다.), Non-blocking으로 동작할 경우 작업을 완료할 수 있다면 완료하고 그렇지 못한 상황이라면 대기하지 않고 리턴해 버린다.

    ## method api call 또는 thread 개념

    - synchronous와 blocking은 같은 개념이다.
    - synchronous(또는 blocking)는 api call을 보낸 후 응답을 받을 때까지 대기 상태에 있다 응답을 받은 후 종료, asynchronous는 api call을 보낸 후 실행 여부와 관계없이 바로 응답을 받는다.

    ## 애플리케이션에서 운영체제로의 system call

    - 이 내용은 [Sync async-blocking-nonblocking-io](http://www.slideshare.net/unitimes/sync-asyncblockingnonblockingio) 문서 기반으로 정리했다.

    ### blocking vs non-blocking

    - 애플리케이션 실행 시 운영체제 대기 큐에 들어가면서 요청에 대한 system call이 완료된 후에 응답을 보낼 경우 blocking
    - 애플리케이션 실행 시 운영체제 대기 큐에 들어가지 않고, 실행 여부와 관계없이 바로 응답을 보낼 경우 non-blocking

    ### non-blocking vs asynchronous

    - system call이 반환될 때 실행된 결과와 함께 반환될 경우 non-blocking

    - system call이 반횐될 때 실행된 결과와 함께 반환되지 않는 경우 asynchronous

    - asynchronous는 요청에 대해 처리 완료의 여부와 관계없이 바로 응답한다. 이후 운영체제에서 응답할 준비가 완료되는 시점(예를 들어 네트워크로부터 데이터를 받는 요청의 경우 데이터가 준비되는 경우)에 응답한다.

    - non-blocking은 요청에 대해 바로 응답할 수 있는 경우 응답을 하고, 바로 응답하기 힘든 경우 에러를 반환한다. 에러를 받을 경우 데이터를 정상적으로 받을 때까지 계속해서 요청을 다시 보낸다. 우리들이 흔히 이야기하는 polling 방식의 구조를 생각하면 된다. 이와 관련해 [Blocking / Non-Blocking](http://ozt88.tistory.com/20) 글의 Non-blocking I/O Model 그림을 보면 좀 더 명확하게 이해할 수 있다.

    - [Blocking / Non-Blocking](http://ozt88.tistory.com/20) 글을 보면 asynchronous에 대해 다음과 같이 설명하고 있다.

      > 이와 반대로 비동기형 통지모델은 일단 커널에게 I/O작업을 맡기면 커널의 작업 진행사항에 대해서 프로세스가 인지할 필요가 없는 상황을 말한다. 유저의 프로세스가 I/O 동기화를 신경쓸 필요가 없기에 비동기형이라고 부를 수 있다. 따라서 비동기형 통지모델에서 Notify의 적극적인 주체는 커널이 되며, 유저 프로세스는 수동적인 입장에서 자신이 할일을 하다가 통지가 오면 그때 I/O 처리를 하게 된다. 

    ### synchronous vs asynchronous

    - system call의 완료를 기다리면 synchronous
    - system call의 완료를 기다리지 않으면 asynchronous

    ### synchronous vs blocking

    - 시스템의 반환을 기다리는 동안 대기 큐에 머무는 것이 필수가 아니면 synchronous
    - 시스템의 반환을 기다리는 동안 대기 큐에 머무는 것이 필수이면 blocking

    [Blocking / Non-Blocking](http://ozt88.tistory.com/20) 글을 보면 Blocking vs Non-Blocking I/O Model에 대해 설명하고 있으며 synchronous vs asynchronous는 Non-Blocking I/O Model에서의 통지 모델로 설명하고 있다. 통지 모델 관련해 인용해 보면 다음과 같다.

    > 이벤트 통지 모델은 Non-Blocking에서 제기된 문제를 해결하기 위해서 고안되었다. I/O처리를 할 수 있는 소켓(혹은 파일 디스크립터)을 가려내서 가르쳐준다면, 다시말해 입력 버퍼에 데이터가 수신되어서 데이터의 수신이 필요하거나, 출력버퍼가 비어서 데이터의 전송이 가능한 상황을 알려준다면, 위에서 이야기한 구조보다 더 단순하고 효과적으로 다중 I/O모델을 처리할 수 있을 것이다. I/O 이벤트를 통지하는 방법은 크게 동기형 통지모델과 비동기형 통지모델로 나눌 수 있다. 

    [Blocking / Non-Blocking](http://ozt88.tistory.com/20) 글도 이 개념들을 이해하는데 많은 도움이 된다.

    위와 같이 정리할 수 있다. 단, 위 내용들을 이해하려면 애플리케이션 실행과 운영체제에 대한 지식과 I/O에 대한 지식이 필요하다. 이와 관련한 지식이 없는 상태에서 이해하려 하는 경우 이해하는데 어려움이 있다.

13. 트랜잭션이란 무엇인가?

14. 데드락이란 무엇인가?

15. DNS이란 무엇인가?

16. String과 String 버퍼의 차이, 그리고 StringBuffer와 StringBuilder의 차이점을 말하세요.

17. MVC패턴에 대한 설명

18. 스택, 큐 구현

19. 주소창에 주소입력후 일어날 수 있는 일은?

    두가지 DNS를 통한 방식과, OSI7계층을 통한 답

19. 퀴리의 반응속도를 빠르게 하려면 어떻게 해야 될까?

    http://www.itworld.co.kr/print/105792
    ​

21. 멀티스레드 환경에서 신경써야줘야하는 것은 무엇이 있을까?

22. 쉐도우 IT란 무엇인가?

23. OSI 7계층

24. 소팅알고리즘에 대한 슈도코드 작성

24. 64비트와 32비트의 차이점?

    32비트와 64비트는 애플리케이션에서 쓸 수 있는 메모리 주소와 일반 레지스터의 크기를 나타낸다. 64비트 애플리케이션을 돌리려면 64비트 프로세서와 64비트 운영체제가 필요하다. 대부분의 64비트 시스템에서는 호환모드로 32비트 애플리케이션을 실행시킬 수 있다.

    메모리 주소 크기의 차이가 크다. 이론적으로는 32비트 2^32비트, 64비트 애플은 2^64바이트

    메모리주소가 크기 때문에 한번에 처리할 수 있는 데이터가 64비트가 더 커서 빠를수 있다.

    그러나 64비트 메모리 주소를 쓰면 모든 포인터를 저장할 때 메모리가 두배 필요하다. 포인터를 사용하는 자료구조의 경우 똑같은 자료구조를 써도 64비트 애플에서는 32비트 애플에 비해 메모리가 두 배 필요하다. 더 중요한 건, 32비트 애플이든 64비트 애플이든 프로세서 캐시 크기는 똑같다는 점이다. 

    64비트 자료구조는 더 용량이 많이 차지하기 때문에 캐시에 조금밖에 못넣는다. 따라서 액세스 할 값을 메인 메모리에서 가져올 때까지 기다려야 하는 캐시 미스가 발생할 확률이 높아진다.

    ​