1. **자기소개**
   단 몃줄의 코드가 세상을 변화시킬 수 있다라고 믿는 집념의 사나이 김정규입니다. 최근에 진행했던 프로젝트들 중 단순히 구현에 그치지않고 더 뛰어난 성능을 만들내기 위해 노력했습니다. 그 노력의 결과로 완성도 높은 프로젝트를 창출해내 K-스타트업의 재창업지원패키지을 받을 수있는 성과를 이뤘습니다. 또다른 저만의 경쟁력은 외향적인 성향을 활용한 소통입니다. 학부생 시절, 스타트업에서 인턴으로 근무하며 직접 발로 뛰며 고객과 소통하고 소통을 통해 받은 피드백을 앱에 적용시켜 고객의 충성도를 높였던 경험이 있었습니다. 

   이러한 경험을 바탕으로 끈기와 소통이 저만의 경쟁력이라고 판단했습니다. 그러므로 제가 가진 경쟁력을 활용해 웍스 모바일에서 핵심적인 인재가 될 것임을 자부합니다.

   감사합니다.

2. **지원동기** / **윅스모바일에서 하고싶은게 있다면 어떤거?**

   //TODO

3. **프로젝트 질문**

   RecyclerView  
   3-1 어탭터 패턴에 대해 말하시오.

   3-2 동기와 비동기 방식의 차이를 설명하세요.

   3-3 postman을 통해 크롤링 방식 이해

   3-4 저전력 블루투스의 동작방식에 대한 이해

   ---

   3-5 네이버 개인화 서비스를 이용해야 하는 명분

   3-6 글로벌하게 사용될 수 있는 기술력의 근거는?

   3-7 웹 페이지의 언어가 일원화 되어 있지 않다.

   3-8 영문판 클라우드 안드로이드 앱에서 글자의 띄어쓰기 등 마이너이슈가 존재한다. 이는 완성도의 아쉬움을 떨어 뜨린다.

   3-9 메일에 대한 프로토콜 이해 ( POP3 / ICMP 프로토콜 / SMTP / MIME - 비정형 데이터를 아스키코드로 변환시켜주는 것)

   3-10 크롤링했던 데이터가 갑자기 변경되면 어떻게 다시 구현할건지 여쭤보심==
   조금 생각하다가, DB 칼럼에 최신 갱신시간을 추가하고 메모이제이션 될때 같이 캐싱하다가 유저가 요청한 시간과 비교하여 일정 시간이 지나면 다시 갱신할거라고 말함.
   3-11 다른 방법도 또 있는지?

   크롤링 하는 프로세스를 주기적으로 돌려서 만약 데이터가 변경된것을 알게된다면 이벤트 방식으로 서비스하고 있는 서버에 알려줄거라고 말함. 뭔가 다른 방법을 듣길 원하는지 다른거 또 있냐고 물어보셔서 고민하고 있었는데 옆 면접관이 너무 들어간거 같다고 끊어줌.
   이번 면접 끝나고 고민해서 다음번에 말씀드리겠다고 답함

   3- 12 ORS (크로스 도메인) 에 대해 알고있는지? 어떻게 해결했는지?
   크로스 도메인 개념과 발생하는 원인에 대해 설명함. 해결방법은 http header 부분을 변환하는 걸로 알고있는데 정확한 내용은 몰라서 모듈을 사용해 해결했다고 함.
   3- 13 왜 Node.js를 활용했는가? 
   Node.js이고 Node.js 특징 말하면서 비동기 I/O 를 강조함. 바로 이어서 비동기와 동기의 차이에 대해 물어봐서 OS 관련된 내용으로 설명함. 그 후 Node.js 사용하면서 발생할 수 있는 문제점(콜 스택이 하나이기 때문에 CPU 바운드 작업이 길면 콜백이 실행안됨)에 대해 물어보면서 해결방안 물어봄.
   CPU 바운드 작업이 긴게 있다면 내부적으로 분할해서 콜백으로 실행해서 테스트 큐에 작업들이 오랜시간 대기하지 않고 바로 실행될 수 있도록 하겠다 했더니 약간 감탄하심.
   이후에 추가적으로 Node.js는 싱글 스레드인걸 강조하면서 오픈소스에 참여해본적은 없지만 napa.js라는 멀티스레드로 자바스크립트를 실행할 수 있는 런타임 환경에 관심을 가지고 보고 있음을 어필함.

   3- 14 그럼 멀티스레드에서 동기화 문제는 어떻게 해결할 것인지?
   뮤텍스, 세마포어, 모니터에 대해 이야기하면서 자바의 싱크로나이즈 키워드가 모니터를 구현한 것임을 말함.

   3- 15 애자일 방법 / 폭포수 모델이란? 

4. **Android 생명주기**

   onCreate()
   onStart()
   onResume()

   onPause()
   onStop()
   onDestory()

   그리고 onStop에서 onStart() 갈 경우 중간에 onRestart()가 존재

   만약 홈버튼을 눌렀을 때는 onPause 상태에서 onResume으로 간다.
   화면을 뒤집을 경우 onPause => onStop => onDestroy => onReInstance() => onStart() => onResume() //TODO

   ​

5. 정렬의 복잡도

   선택정렬 / 버블 정렬 / 삽입 정렬 - worse O(n^2) 
   퀵 정렬 / 병합 정렬 - 가장 워스트한 것이 O(nLogn)

   //TODO 힙정렬과 기수 정렬 구현

   ​

6.  대규모의 문자열을 탐색 할때 어떻게 하겠는가?
   일반적으로 그냥 쭈욱 탐색하면서 하는 방법이 일반적인 방법이라면 이러한 방법은 O(N*M) 이것보다 효율적인 방법은?  
   KMP알고리즘을 활용해 시간복잡도를 O(N+M)으로 줄이겠습니다. http://bowbowbow.tistory.com/6  
   //TODO 구현 백준 1786 접두사와 접미사를 활용, pi배열

7. 사용하는 IDE는 IntelliJ, androidStudio. 왜 이걸 쓰는가? 처음에는 안드로이드 스튜디오의 단축키에 익숙해져서 인텔리제이를 쓰게 되었지만 이클립스와 비교해 인텔리제이가 좋은 이유는 Code Assist가 안정적이고, 프로그램이 무거워졌을 때 이클립스에서 발생하던 문제를 해결해준다. 왜 Code Assist가 좋은 이유는 자바의 경우 C와 달리 작성해야 클래스부터 new, 키워드 등 입력해야 되는 것이 많다. 그래나 Code Assist를 활용하면 개발시간을 단축시킬 수 있어서 좋다. 그러나 유료라는 단점이 있어 아쉬운 부분이다.

8. Async / sync의 차이점은?

   비동기적인 방식과 동기적 방식의 차이는 예를 들어 설명해 볼 수 있다. 비동기의 방식의 경우 내가 은행도 가야되고 세탁소도 들려야 되고 과일가게도 들려야 한다면 심부름꾼을 통해 각각의 업체에 한명씩 보내고 돌아오는 것만 확인하면 된다. 그러나 동기적 방식의 경우에는 내가 직접 은행을 가서 볼일을 해결하고, 세탁소에가서 볼일을 해결하고, 과일가게에 가서 직접 해결해야 한다. 

9. Search 알고리즘 손코딩

10. 정렬되지 않은 알고리즘에 대한 효율적인 방법은 무엇일까?

    어떤 데이터냐 따라 다르겠지만 엄청나게 많은 데이터라면 최악의 상황에서도 nLogn을 보장해주는 쿽정렬을 활용하고, 일정부분 정렬된 데이터라면 삽입정렬을 통해 O(n)속도로 정렬을 실행합니다.

    // 책보고 다시한번 정리하기.

11. Http와 Https의 차이점을 말해주시오.

    HTTP는 일반적으로 응용계층에서 평문으로 데이터를 주고받는 것을 말합니다. 그러나 HTTP에는 여러 문제점을 안고 있어 이를 해결하기 위해 HTTPS가 나왔다고 할 수 있습니다.  
    HTTP의 문제점은 평문으로 데이터를 주고받기 때문에 도청이 가능합니다.  
    또한 통신 상대를 확인하지 않기 때문에 위장이 가능합니다. 그리고 마지막으로  
    완전성을 증명할 수 없기 때문에 변조가 가능합니다.

    이러한 문제점을 해결하기 위해 헤더와 바디로 구성된 HTTP 구조에 SSL(시큐어리티 소켓 레이어)라는 층을 추가해 위 문제점을 해결합니다. HTTP의 메시지를 해쉬를 통해 암호화하여 중간에 가로채지 못하도록 하며, 또한 통신 상대가 누구인지 인증된 사람만이 수신할 수 있도록 해줍니다. 이렇게 해서 HTTPS는 HTTP의 보안을 더한 프로토콜이라고 말할 수 있습니다.

    그럼 왜 HTTPS을 쓰지 않는가?  
    이유는 HTTPS를 활용하면 통신할 때마다 암호화방식을 활용하는데 이는 CPU나 메모리의 리소스를 많이 소모하게 됩니다. 그렇게 되면 서버 한 대당 처리할 수 있는 리퀘스트의 수가 들어들어 효율성이 떨어집니다. 때문에 민간한 정보를 다룰때만 HTTPS를 활용합니다.

12. Blocking과 Non-blocking의 차이는?  
    I/O작업에서 Blocking으로 동작할 경우 해당 I/O가 끝날 때까지 대기해야하고 (I/O가 끝나기 전에는 함수가 반환되지 않는다.), Non-blocking으로 동작할 경우 작업을 완료할 수 있다면 완료하고 그렇지 못한 상황이라면 대기하지 않고 리턴해 버린다.

    ## method api call 또는 thread 개념

    - synchronous와 blocking은 같은 개념이다.
    - synchronous(또는 blocking)는 api call을 보낸 후 응답을 받을 때까지 대기 상태에 있다 응답을 받은 후 종료, asynchronous는 api call을 보낸 후 실행 여부와 관계없이 바로 응답을 받는다.

    ## 애플리케이션에서 운영체제로의 system call

    - 이 내용은 [Sync async-blocking-nonblocking-io](http://www.slideshare.net/unitimes/sync-asyncblockingnonblockingio) 문서 기반으로 정리했다.

    ### blocking vs non-blocking

    - 애플리케이션 실행 시 운영체제 대기 큐에 들어가면서 요청에 대한 system call이 완료된 후에 응답을 보낼 경우 blocking
    - 애플리케이션 실행 시 운영체제 대기 큐에 들어가지 않고, 실행 여부와 관계없이 바로 응답을 보낼 경우 non-blocking

    ### non-blocking vs asynchronous

    - system call이 반환될 때 실행된 결과와 함께 반환될 경우 non-blocking

    - system call이 반횐될 때 실행된 결과와 함께 반환되지 않는 경우 asynchronous

    - asynchronous는 요청에 대해 처리 완료의 여부와 관계없이 바로 응답한다. 이후 운영체제에서 응답할 준비가 완료되는 시점(예를 들어 네트워크로부터 데이터를 받는 요청의 경우 데이터가 준비되는 경우)에 응답한다.

    - non-blocking은 요청에 대해 바로 응답할 수 있는 경우 응답을 하고, 바로 응답하기 힘든 경우 에러를 반환한다. 에러를 받을 경우 데이터를 정상적으로 받을 때까지 계속해서 요청을 다시 보낸다. 우리들이 흔히 이야기하는 polling 방식의 구조를 생각하면 된다. 이와 관련해 [Blocking / Non-Blocking](http://ozt88.tistory.com/20) 글의 Non-blocking I/O Model 그림을 보면 좀 더 명확하게 이해할 수 있다.

    - [Blocking / Non-Blocking](http://ozt88.tistory.com/20) 글을 보면 asynchronous에 대해 다음과 같이 설명하고 있다.

      > 이와 반대로 비동기형 통지모델은 일단 커널에게 I/O작업을 맡기면 커널의 작업 진행사항에 대해서 프로세스가 인지할 필요가 없는 상황을 말한다. 유저의 프로세스가 I/O 동기화를 신경쓸 필요가 없기에 비동기형이라고 부를 수 있다. 따라서 비동기형 통지모델에서 Notify의 적극적인 주체는 커널이 되며, 유저 프로세스는 수동적인 입장에서 자신이 할일을 하다가 통지가 오면 그때 I/O 처리를 하게 된다. 

    ### synchronous vs asynchronous

    - system call의 완료를 기다리면 synchronous
    - system call의 완료를 기다리지 않으면 asynchronous

    ### synchronous vs blocking

    - 시스템의 반환을 기다리는 동안 대기 큐에 머무는 것이 필수가 아니면 synchronous
    - 시스템의 반환을 기다리는 동안 대기 큐에 머무는 것이 필수이면 blocking

    [Blocking / Non-Blocking](http://ozt88.tistory.com/20) 글을 보면 Blocking vs Non-Blocking I/O Model에 대해 설명하고 있으며 synchronous vs asynchronous는 Non-Blocking I/O Model에서의 통지 모델로 설명하고 있다. 통지 모델 관련해 인용해 보면 다음과 같다.

    > 이벤트 통지 모델은 Non-Blocking에서 제기된 문제를 해결하기 위해서 고안되었다. I/O처리를 할 수 있는 소켓(혹은 파일 디스크립터)을 가려내서 가르쳐준다면, 다시말해 입력 버퍼에 데이터가 수신되어서 데이터의 수신이 필요하거나, 출력버퍼가 비어서 데이터의 전송이 가능한 상황을 알려준다면, 위에서 이야기한 구조보다 더 단순하고 효과적으로 다중 I/O모델을 처리할 수 있을 것이다. I/O 이벤트를 통지하는 방법은 크게 동기형 통지모델과 비동기형 통지모델로 나눌 수 있다. 

    [Blocking / Non-Blocking](http://ozt88.tistory.com/20) 글도 이 개념들을 이해하는데 많은 도움이 된다.

    위와 같이 정리할 수 있다. 단, 위 내용들을 이해하려면 애플리케이션 실행과 운영체제에 대한 지식과 I/O에 대한 지식이 필요하다. 이와 관련한 지식이 없는 상태에서 이해하려 하는 경우 이해하는데 어려움이 있다.

13. 트랜잭션이란 무엇인가?

14. 데드락이란 무엇인가?

15. DNS이란 무엇인가?

16. String과 String 버퍼의 차이, 그리고 StringBuffer와 StringBuilder의 차이점을 말하세요.

17. MVC패턴에 대한 설명

18. 스택, 큐 구현

19. 주소창에 주소입력후 일어날 수 있는 일은?

    두가지 DNS를 통한 방식과, OSI7계층을 통한 답

20. 퀴리의 반응속도를 빠르게 하려면 어떻게 해야 될까?

21. 멀티스레드 환경에서 신경써야줘야하는 것은 무엇이 있을까?

22. 쉐도우 IT란 무엇인가?

23. OSI 7계층

24. 소팅알고리즘에 대한 슈도코드 작성

25. 64비트와 32비트의 차이점?

    32비트와 64비트는 애플리케이션에서 쓸 수 있는 메모리 주소와 일반 레지스터의 크기를 나타낸다. 64비트 애플리케이션을 돌리려면 64비트 프로세서와 64비트 운영체제가 필요하다. 대부분의 64비트 시스템에서는 호환모드로 32비트 애플리케이션을 실행시킬 수 있다.

    메모리 주소 크기의 차이가 크다. 이론적으로는 32비트 2^32비트, 64비트 애플은 2^64바이트

    메모리주소가 크기 때문에 한번에 처리할 수 있는 데이터가 64비트가 더 커서 빠를수 있다.

    그러나 64비트 메모리 주소를 쓰면 모든 포인터를 저장할 때 메모리가 두배 필요하다. 포인터를 사용하는 자료구조의 경우 똑같은 자료구조를 써도 64비트 애플에서는 32비트 애플에 비해 메모리가 두 배 필요하다. 더 중요한 건, 32비트 애플이든 64비트 애플이든 프로세서 캐시 크기는 똑같다는 점이다. 

    64비트 자료구조는 더 용량이 많이 차지하기 때문에 캐시에 조금밖에 못넣는다. 따라서 액세스 할 값을 메인 메모리에서 가져올 때까지 기다려야 하는 캐시 미스가 발생할 확률이 높아진다.

    ​

26. 크롤링이란 무엇인지?

27. 프로토콜이란 무엇인지?

28. HTTP와 TCP 차이점

29. REST API란 무엇인지?

30. HTTP와 REST API 비교 설명

31. GET POST 비교 설명

32. 쓰레드란 무엇인지?

33. 쓰레드 사용시 유의점

34. 쓰레드와 async await 방식의 차이점

35. js에서 promiss 와 async의 차이점

36. 휴대용미세먼지 측정기에서 완성한 프로토콜이 무엇인지?

37. RDBMS가 무엇인지

38. functional programming의 장단점

39. functional programming과 oop 비교 설명

40. 크롤링으로 서비스를 만들경우 발생할 수 있는 문제점과 해결방안