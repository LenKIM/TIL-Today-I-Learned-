이력서 질문 내용 예상

1. 저전력 블루투스 동작 원리

   기존의 배터리가 빨리소모되는 문제점을 해결하기 위해서 저전력이 나왔음.
   저전력블루투스는 Advertise방법과, Connection방법으로 통신하는데, 이는 TCP, UDP와 유사하게, 어드벌타이즈는 일대 다 통신으 가능케하고, 컨넥션방식은 일대일 통신을 한다.

   컨넥션 방식으로 통신할때, GAP GATT를 기억해야 합니다.
   GAP의 경우 서로 다른 블루투스의 기계들을 호환할 수 있도록 해주는 주줏돌 역할을 하며
   GATT의 경우 서비스와 캐릭터리스틱을 정의해 인풋 아웃풋의 데이터를 담당합니다.

   ​

2. 고객의 충성도를 높였던 경험

   인턴으로 근무하면서 펌웨어업데이트 기능을 구현한 경험이 있습니다. 그러나 해당 기능의 용어가 아이를 가진 젊은여성층에서는 익숙치 않은 용어였기에 오해를 갖고 문의 전화를 많이 주셨습니다. 고객의 피드백을 받고 빠르게 대처하기 위해 관련 펌웨어 업데이트 가이드를 만들어 배포했습니다. 이러한 방식은 고객의 충성도를 높일 수 있었던 계기가 되었습니다.
   ​

3. RxJava, Kotiln 기본 개념

   왜 RxJAVA인가???

   자바를 활용해 같은 네트워크 나아가 비동기식의 HTTP통신까지 다루다보면 복잡해지고 통제하기가 힘들어진다. 그러나 RxJAVA를 활용해 간편하게 통제할 수 있다.
   간단한 예로 연말 매출액을 계산하는 함수가 있다고 가정합니다.
   명령형 프로그래밍 방식은 변경이 발생했다는 통지를 받아서 연말 매출액을 새로 계산하는 당겨오는 (Pull) 방식이지만,
   리액티브 프로그래밍은 데이터 소스가 변경된 데이터를 밀어주는(Push)방식입니다.

   다시말해 데이터의 변화가 발생했을 때 변경이 발생한 곳에서 새로운 데이터를 보내 줍니다.
   데드락과 동기화 문제를 해결 해줌.

   ​

   ​

4. CRUD ( Create, Read, Update, Delete)

   POST / GET / PUT / DELETE/ HEADER / TRACE 클라이언트 측에서 송신한 Request을 반환하는 메소드입니다. 

   ​

5. REST API(Representational State Transfer API)

   **어떤 자원을 보낼 것인가?(URI) , 어떤 행위를 할 것인가?(HTTP METHOD), 표현(Representaions)**

   특징

   1. Uniform(유니폼 인터페이스) - Uniform Interface는 URI로 지정한 리소스에 대한 조작을 통일되고 한정적인 인터페이스로 수행하는 아키텍처 스타일을 말합니다.
   2. Stateless(무상태성) - 무상태성 성격을 가진다. 이말의 뜻은 작업을 위한 상태정보를 따로 저장하고 관리하지 않습니다. 세션 정보나 쿠키정보를 별도로 저장하고 관리하지 않기 때문에 API서버는 들어오는 요청만을 단순히 처리하면 됩니다. 때문에 서비스의 자유도가 높아지고 서버에서 불필요한 정보를 관리하지 않음으로써 구현이 단순합니다.
   3. Cacheable(캐시 가능) - REST의 가장 큰 특징은 HTTP라는 기존 웹표준을 그대로 사용하기 때문에, 웹에서 사용하는 기존 인프라를 그대로 활용이 가능합니다.따라서 HTTP가 가진 캐싱 기능이 적용가능합니다.
   4. 자체 표현 구조
   5. 서버 클라 구조
   6. 계층형 구조 - 로드밸렁싱, 암호화계층을 추가해 구조상의 유연성을 둘 수 있다.


2. Java Parsing 방법
3.  LocalDB SQLite 개념
4. 자기소개 

## 정렬 차이

**선택 정렬** - 배열의 첫 번째 원소에서 시작하여 배열 전체를 훑으면서 가장 작은 키를 가지는 원소를 찾아서 첫 번째 원소와 맞바꾼다. 두 번째 원소로 넘어가면서 마지막 원소에 이르기까지 같은 작업을 반복

최선, 최악 평균 모두 $N^2$



**삽입 정렬** - 한 번에 한 원소씩 이미 정렬된 다른 원소들과 비교하여 새 원소를 제 위치에 삽입하는 식으로 정렬된 배열을 만듬

최선이 n 그나 평균 및 최악이 $n^2$

그러나 삽입 정렬의 경우 안정적이면서 제자리 정렬 알고리즘으로, 소량의 데이터 집합을 처리할 때 강점을 발휘하기 때문에 다른 더 복잡한 정렬 알고리즘을 만드는 기본 단위로 많이 쓰임



**쿽 정렬** - 데이터 집합 내에서 한 피벗 값을 고른 다음 그걸 기준으로 집합을 두 개의 부분집합으로 나눈다. 한 쪽 부분집하에서 피벗 값보다 작은 것만, 다른 부분집합에서 큰 것만 넣는다. 더 이상 쪼갤 부분집합이 없을 때까지 각각의 부분집합에 대해 피벗/쪼개기 작업을 재귀적으로 적용한다. 그렇게 하고나면 최종적으로 정렬된 데이터 집합이 만들어 진다.

어떤 피벗을 고르냐에 따라 성능 좌우됨. 가장 작은 값을 고를경우 $N^2$ 

완전히 무작위적인 데이터의 경우  피벗 값이 위치와 무관하기 때문에 어떤 피벗값을 선택하든 차이가 없고, 결과적으로 어떤 위치에 있는 값을 피벗으로 골라도 무방하다. 하지만 데이터가 이미 완전히, 또는 거의 정렬되어 있다면 데이터 집합 중앙에 있는 값을 선택하면 각 부분집합에 각각 절반씩의 데이터가 들어가므로 정렬된 데이터의 경우 nlongn 복잡도를 보장한다. **퀵 정렬은 대부분 불안정하다.**



**합 정렬** - 데이터 집합을 둘 이상의 부분집합으로 가르고, 각 부분집합을 정렬한 다음 부분집합들을 다시 정렬된 형태로 합치는 방식으로 정렬을 하는 분할정복형 알고리즘.

다른 대부분의 정렬 알고리즘과 달리 합치기 정렬은 데이터 집합이 메모리에 한번에 올리기에 너무 클 때 쓰기 좋은 방법이다. 보통은 큰파일에 있는 내용을 여러 개의 더 작은 파일로 나눈다. 각각의 작은 파일을 메모리로 읽어들여서 적당한 알고리즘으로 정렬한 다음 다시 파일로 저장한다. 그리고 정렬된 파일을 입력 받아서 바로 최종 출력 파일에 결과를 기록하는 식으로 합치기 작업을 처리한다. 

합치기 정렬의 최고, 최저, 평군 실행시간 모두 $nlong$이기 때문에 정렬 시간의 상한을 철저하게 지켜야 할 때 매우 좋다. 하지만 다른 알고리즘 대비 O(n) 수준의 메모리가 추가로 필요하다는 단점을 지닌다. 일반적인 합치기 정렬 구현법은 안정적이긴 하지만 제자리 정렬 알고리즘은 아니다.



`정렬할 때 가장 적합한 알고리즘은 무엇인가??`

 조심해야됨

- 어떤 데이터인가? 정렬 조건이 어떻게 되나요? 어떤 시스템인지 알 수 있을까요? 라는 식의 질문을 해서 적절한 정렬방법을 말해야 한다.

`마스터 디렉터리 서버에서는 여러 부서별 디렉터리 서버로부터 사용자 ID를 기준으로 정렬된 계정 목록을 수신한다. 이 서버에서 모든 계정을 사용자 ID를 기준으로 정렬된 상태로 합쳐두고 마스터 목록을 만들 때 가장 좋은 접근법은?`

- 가장 단순한 방법은 모든 하위 목록을 쭉 이어 붙인 다음 퀵 정렬 같은 일반적인 정렬 알고리즘을 적용해서 합쳐진 목록을 만드는 방법
- 만약 충분한 공간이 제공된다면 이미 정렬된 공간을 활용하여 합치기 정렬을 활용할 수 있을 것입니다.

`어떤 제조공장을 모니터하는 시스템에서 품질 관리를 할 때 불량이 난 모든 항목의 일련번호를 목록으로 저장해 둔다고 하자. 근무 시간 동안 공장이 가동되는 중에는 새 일련번호를 목록 맨 뒤에 덧붙인다. 그리고 매일 밤 배치 작업을 돌려서 목록을 다시 정렬한다. 이때 쓸 수 있는 가장 좋은 정렬 알고리즘은?`

- 전날 정돈된 일련번호까지 이미 정렬이 되어있고, 그 날 새로 추가된 일련번호만 정렬이 안되어 있다. 보통 일련번호는 순차적으로 매기는 걸 감안하면 새로 추가된 일련번호도 어느 정도는 정렬이 되어 있을 가능성이 높다. 고장을 몃 주 정도 가동하고 나면 목록 전체 크기에 비해 매일 추가되는 데이터양이 휠씬 적을 것이라고 가정해야 전혀 문제없다.
- 정리해 보자면, 이 문제는 소수의 정렬되지 않은 항목들은 커다란 정렬된 목록에 추가하는 문제라고 할 수 있다. 그리고 이런 문제에는 삽입 정렬이 제격이다. 왜? 삽입 정렬이 최선의 속도인 O(n)이 나오는 상황과 거의 비슷해 보인다. 하지만 잠시 멈추고 삽입 정렬의 다른 성질을 따져 보자.



` 여러 종류의 데이터를 정렬해야 하는데, 그 데이터에 대해 아는 게 거의 없다. 데이터 집합이 크진 않아서 메모리에 전부 들어갈 수 있지만 각각의 크기는 많이 다를 수 있다. 어떤 정렬 알고리즘을 쓰는 게 좋을까?`

이 문제가 쿽 정렬로 하기 좋다. 정렬할 데이터에 대해 아는 게 거의 없이 그냥 정렬해야 하는 상황이 매우 흔하게 발생하곤 하는데, 이런 경우에는 일반적인 속도만 생각해서 정렬할 수 밖에 없다. 주어진 문제가 그냥 일반적인 정렬 문제인지 확실히 따져보고, 혹시 조금 더 특화된 정렬 알고리즘을 선택할 만한 근거가 있는데 놓치고 있는 건 아닌지 다시 한번 살펴봐야한다. 



정리하면, 일반적인 데이터 집합의 경우 합치기정렬(안정성이 중요한 경우)이나 퀵 정렬(안전성이 중요하지 않은 경우)을 쓰는 편이고, 데이터 집합이 아주 작은 경우(n값이 10미만 경우)에는 삽입 정렬을 쓰기도 한다.



## 안정적인 선택 정렬

`안정적인 버전의 선택 정렬을 구현하라`

안정적인 선택 정렬을 구현하라는 건 무슨 말일까?? 선택정렬은 아직 정렬되지 않은 값을 쭉 훑어서 가장 낮은 키값을 찾은 다음 그 가장 낮은 키와 이미 정렬된 값들 바로 다음에 있는 값을 맞바꾸는 방식이다.

이걸 안정적으로 만들려면? 안정적이란? 키가 같은 원소의 순서를 입력된 순서 그대로 유지시켜주는 정렬 알고리즘이다.





## 스레드?

스레드는 프로세스를 실행하는 작업 단위입니다. 각 스레드마다 별도의 스택이 있으며, 각 스레드는 같은 애플리케이션에 있는 다른 스레드와 독립적으로 돌아간다. 기본적으로 스레드끼리는 파일 핸들이나 메모리 같은 자원을 공유한다. 따라서 공유자원에 대한 접근을 제대로 제어하지 못하면 문제가 생길수 있다. 예를 들어,  두 스레드에서 같은 메모리 블록에 동시에 쓰기 작업을 할 때 흔히 데이터 손실 같은 부작용이 생길 수 있다.

스레드는 여러 방식으로 구현할 수 있다. 대부분 시스템에서 스레드는 운영체제에서 생성하고 관리한다. 이런 스레드를 네이티브 스레드 또는 커널 수준 스레드라고 부른다. 스레드를 가상 머신 같이 운영체제위의 소프트웨어 계층에서 구현할 수도 있습니다, 이를 녹색스레드라고 부른다.

동시에 돌릴 수 있는 스레드 수는 컴퓨터에 있는 코어 개수로 제한되기 때문에 운영체제에서는 각 스레드에 조금씩 시간을 나눠주면서 여러 스레드를 돌려가면서 실행시킨다. 운영체제에서 아무 때나 스레드 실행을 멈추고 다른 스레드를 실행시킬 수 있기 때문에 이런 방법을 선점형 스레딩이라고 부른다.

## 시스템 스레드와 사용자 스래드



1. 커널모드와 유저 모드
   \- 메모리 영역은 사용자에 의해서 할당되는 메모리 공간인 유저 영역과 운영체제라는 하나의 소프트웨어를 실행시키기 위해서 필요한 메모리 공간인 커널 영역으로 나누다.  
   \- 기본적으로 유저 모드로 동작하다가 Windows 커널이 실행되어야 하는 경우에 커널모드로의 전환이 일어난다.  
   \- 커널보드와 유저 모드의 차이는 유저모드에서 동작할 때 커널 영역으로의 접근이 금지된다. 커널 모드일 때는 모든 영역의 접근이 허용된다.
   \- 운영체제 차원에서 제공되는 시스템 함수들 중 일부는 호출시 커널모드로 동작한다.  
   \- 주의할 점은 모드의 전환은 시스템에 부담을 준다.  
   \- 커널 모드와 유저 모드를 제공하는 대상은 Windows운영체제가 아닌 프로세스(Process)이다. 즉 메모리 보호 기능이 CPU에 달려있다.

2. 커널레벨 쓰레드와 유저레벨 쓰레드

   커널레벨 쓰레드와 유저레벨 쓰레드는 생성 주체가 누구냐에 따라 구분된다.
   \- 프로그래머 요청에 따라 쓰레드를 생성하고 스케줄링하는 주체가 커널이면 커널 레벨 쓰레드라고 한다.

   \- 커널이 쓰레드 모델을 지원하지 않거나 제공하는 쓰레드 모델이 마음에 들지 않을 경우, 커널에 의존적이지 않은 형태로 쓰레드의 기능을 제공하는 라이브러리를 활용할 수 있는데 이러한 방식으로 제공되는 쓰레드가 유저레벨 쓰레드이다.

   ​

   **커널레벨스레드**

   장점 - 커널이 직접 제공해 주기 때문에 안정성과 다양한 기능이 제공됩니다.  
   단점 - 그러나 유저 모드에서 커널 모드로의 전환이 빈번하게 이뤄져 성능 저하가 발생합니다.

   **유저레벨스레드**

   장점 - 커널이 쓰레드의 존재조차 모르기 때문에 모드 간의 전환이 없고 성능 이득이 발생합니다.  
   단점 - 그러나 하나의 스레드가 커널에 의해 블로킹 되면 프로세스 전체가 블로킹되고(왜? 커널 쓰레드 입장에서 유저레벨쓰레드를 하나의 프로세스라고 간주해, 접근하지 못하게 하기 위해서 블록한다.), 이를 해결하려면 프로그래밍이 어려워지고 커널 레벨 스레드에 비해 결과 예측이 어려워집니다.

   ​

## 모니터와 세미포어

스레드와 공유자원 사이의 상호작용을 제어할 때는 스레드 동기화 매커니즘을 써야한다. 스레드 동기화는 모니터와 세마포어로 구성된다. 어느 쪽을 쓰는지는 시스템이나 언어에서 어느 쪽을 지원하는지에 따라 달라진다.

상호 배제 자물쇠로 보호되는 루틴의 집합을 모니터라고 부른다. 스레드는 자물쇠를 획득하기 전까지는 모니터에 속하는 루틴을 하나도 실행할 수 없다. 한 모니터 내에서는 한 스레드씩 실행된다. 다른 스레드는 전부 지금 실행중인 스레드에서 그 자물쇠를 놓아줄 때까지 기다려야만 한다. 모니터에 속하는 어떤 스레드가 다른 어떤 이벤트가 발생할 떄까지 기다리기 위해 스스로 멈추면 다른 스레드가 모니터에 진입할 수 있다. 그렇게 대기중이던 스레드에 이벤트가 발생했다는 연락을 받으면 그 스레드는 다시 깨어나고 최대한 빨리 자물쇠를 재획득해야 한다.

스레드 동기화를 위해서는 대가를 치러야 한다. 공유 자원에 접근하기 위해 자물쇠를 획득하고 해제하는 데 시간이 걸리기 때문이다. 이런 이유로 라이브러리에서 스레드용과 비스레드용클래스를 별도로 제공하기도 하는데 이게 StringBuffer와 StringBuiler이다.



## 바쁜대기

`바쁜 대기란 용어를 설명해 보고 어떻게 하면 바쁜 대기를 피할 수 있는지 말하라`

작업을 완료하기 위해 다른 스레드를 파생시켜야만 하는 스레드가 있다고 해보자. 첫 번째 스레드에서는 두 번째 스레드가 작업을 마칠 때까지 기다려야 하고, 두 번째 스레드는 자기가 할 일을 마치고 나면 바로 종료된다고 하자. 가장 간단한 접근법은 첫 번째 스레드에서 두 번째 스레드가 죽을 떄까지 기다리도록 하는 방법이다.

```Java
Thread task = new TheTask();
task.start();
while(task.isAlive()){
  //아무 일도 하지 않음
}
```

이렇게 대기 중인 스레드가 여전히 활성 상태긴 하지만 실제로는 아무 일도 하지 않는 것을 바쁜 대기라고 부른다. 스레드에서 두 번째 스레드가 끝날 때까지 대기하는 것 외에는 아무 일도 하지 않음에도 불구하고 프로세서에서는 여전히 이 스레드를 실행시키기 떄문에 '바쁜대기' 라고 부르는 것.

'바쁜 대기'는 모니터나 세마포어를 써서 피할 수 있으며, 어느 쪽을 사용하는지는 프로그래머가 처한 상황에 따라 달라질 수 있다. 다른 스레드에서 작업이 끝났음을 알려줄 때까지 대기하는 스레드를 휴지상태로 전환해주면 된다. (Wait())



## 객체지향

### 상속과 다형성

`객체지향 프로그래밍에서 인터페이스와 추상 클래스 사이의 차이점을 설명하라`

- 인터페이스에서는 클래스와 별도로 일련의 연관된 메소드를 선언한다.
- 추상 클래스는 메소드를 선언하기는 하지만 모든 메소르를 정의하지는 않는 불완전하게 정의된 클래스이다.

`가상 메소드가 무엇인지 기술하고 어떻게 활용할 수 있는지 설명하라.`

- 가상 메소드는 그 메소드를 실제로 호출하는 객체가 어떤 클래스인지에 따라 구현이 결정되는 메소드를 뜻한다. 정적 메소드를 제외한 모든 자바 메소드는 가상 메소드이므로 자바 프로그래머라면 이런 질문에 대답하기 어렵다. C++와 C는 Virtual 키워드를 써서 선언하는 경우에만 그 메소드가 가상 메소드가 되며, 기본적으로는 비가상 메소드로 선언.

`자바에서 클래스의 다중 상속을 허용하지 않는 이유는?`

단일 상속만이 가능하다. 왜냐하면 한 클래스가 두 개의 서로 다른 클래스를 상속하는데, 그 두 부모 클래스가 한 클래스로부터 파생된 클래스인 경우를 들 수 있다.

클래스와 인스턴스는 설계도와 제품이라고 설명했다. 그럼 객체는 클래스일까 인스턴스일까? 다소 논란이 있지만 일반적으로 설계도인 클래스가 구체적인 실체인 인스턴스가 되었을 때 객체라고 부른다. 보통은 구체적인 코드 상에서 나타는 객체를 인스턴스라고 부르고, 로직을 설계 할 때 나타나는 인스턴스를 객체라고 부른다. 또는 클래스, 인스턴스의 구분없이 포괄적으로 객체라는 말을 쓰기도 한다.



## 데이터베이스

**트랜잭션**

- 원자성(Atomicity), 일관성(consistency), 고립성(isolation), 영속성(durability)



`C++ 와 자바의 차이점에 대해 설명하라.`

C++와 자바는 매우 유사하지만, 이렇게 유사성도 있지만 사실 여러 차이점이 있다. 이는 설계 목표의 차이점에 기인한다.자바를 설계할 때는 보안, 이식성과 빠르게 개발할 수 있어야 한다는 점에 매우 큰 비중을 뒀지만, C++는 개발 과정에서 속도 및 C와의 하위 호환성에 중점을 뒸다. 자바는 가상 머신 바이트 코드로 컴파일하며, 실행시키려면 가상 머신이 필요하지만 C++는 그냥 각 머신에 맞는 기계어로 컴파일 로 동작된다. 그래서 일반적으로 C++가 빠르긴 하지만 자바는 이식성과 보안면에서 더 나은 편이다.

C++은 C를 그대로 포함하며 하위 호환성을 유지하기 위해 프로그래머에 의한 메모리 관리 제어, 포인터, 전처리기 같은 기능을 전부 유지하고 있다. 하지만 자바에서는 그런 기능 외에는 여러 가지 버그를 일으키기 쉬운 기능들을 없애버렸다. 자바에서는 프로그래머가 손수 메모리를 비우는 방법 대신 가지비켈럭션을 사용한다.



## 인자 전달

```c++
Fruit클래스의 객체를 인자로 받아들이는 foo라는 C++함수 원형이 다름과 같이 선언된다.

Void foo(Fruit bar);
Void foo(Fruit* bar);
Void foo(Fruit& bar);
Void foo(const Fruit* bar);
Void foo(Fruit*& bar);

각 원형에 대한 인자가 어떻게 전달되는지 파악하기.
```

첫번째 원형에서는 객체 인자가 값으로 전달된다. 즉 Fruit의 복사 생성자가 호출되면서 스택에 그 객체의 복사본이 만들어진다. 컴파일러에서는 Fruit에 별도의 복사 생성자가 정의되어 있지 않으면 멤버 복사 생성자로 기본 멤버를 생성한다. 따라서 Fruit에 동적으로 할당된 메모리나 파일 핸들과 같은 별도의 자원에 대한 포인터가 포함되어 있다면 버그가 생길 수 있다. 그 함수 내에서 bar는 Fruit클래스의 객체로 취급된다. bar는 함수에 전달된 객체의 복사본이므로 bar를 어떻게 바꾸든 그 내용은 원래 객체에는 반영되지 않는다. 객체에 있는 모든 데이터 멤버를 객체의 새 복사본에 일일이 복사해 넣어야 하므로 객체를 전달하는 가장 비효율적인 방법이라고 할 수 있다.

두번째 원형에서는 bar가 Fruit 객체에 대한 포인터다. 객체 자체가 아닌 객체의 주소가 스택에 복사되기 때문에 값으로 전달되는 경우에 비해 더 효율적이다. bar는 foo에 전달된 객체를 가리키기 때문에 bar변수를 통해 객체를 건드린 부분은 원래 객체에도 그대로 반영된다.

세 번째 원형에서는 bar를 레퍼런스로 전달한다. 이 경우는 두 번째 원형과 비슷하다. 객체가 복사되지 않으며, foo에서 호출하는 함수에 있는 객체를 직접 건드릴 수 있다. 레퍼런스를 사용하는 함수와 포인터를 사용하는 함수 사이의 가장 큰 차이는 문법적인 부분에 있다.
포인터를 쓸 때는 멤버 변수와 함수를 쓰려면 명시적으로 디레퍼런스를 해야 하지만 레퍼런스를 쓸 때는 멤버를 직접 액세스할 수 있다. 따라서 포인터를 쓸 떄는 화상표 연산자를 가지고 멤버를 액세스하고, 레퍼런스를 쓸 때는 점연산자를 사용한다. 조금 미묘하긴 하지만 더 중요한 차이점이 있는데, 바로 포인터는 Fruit를 가리키지 않을 수도 있다. 포인터를 사용하는 버전의 foo에는 널 포인터를 넘겨줄 수도 있다. 그러나 레퍼런스를 사용하는 구현에서는 bar가 반드시 Fruit에 대한 레퍼런스여야만 한다.

네 번째 원형에서는 bar가 객체에 대한 상수 포인터로 넘어간다. 포인터를 인자로 전달할 때와 마찬가지로 성능 면에서 유리하면서도 bar를 변경하는 일은 방지할 수 있다. foo안에서는 const로 선언된 메소드만 호출할 수 있기 때문에 foo에서 bar를 간접적으로 변경할 수가 없다.

마지막 원형에서는 bar가 Fruit객체에 대한 포인터에 대한 레퍼런스로 전달된다. 두번째 경우와 마찬가지로 객체를 바꿨을 때 호출하는 함수 쪽에서도 그 변경 내역을 그대로 볼 수 있다. 추가로 bar가 그냥 포인터가 아니라 포인터에 대한 레퍼런스이므로 bar를 다른 Fruit객체를 가리키도록 수정하면 호출하는 함 쪽의 포인터도 변경된다.



## 매크로와 인라인 함수

## 가비지 컬렉션

가비지 컬렉션이란 프로그램에서 더 이상 쓰지 않는 메모리를 자동으로 찾아서 가져가는 것을 뜻한다.  

## 32비트 vs 64비트 애플리케이션의 차이점은?

32비트와 64비트는 애플리케이션에서 쓸 수 있는 메모리 주소와 일반 레지스터의 크기를 나타낸다. 64비트 애플리케이션을 돌리려면 64비트 프로세서와 64비트 운영체제가 필요하다. 대부분의 64비트 시스템에서는 호환모드로 32비트 애플리케이션을 실행시킬 수 있다.

메모리 주소 크기의 차이가 크다. 이론적으로는 32비트 2^32 비트, 64비트 어플리케이션은 2^64바이트

메모리주소가 크기 때문에 한번에 처리할 수 있는 데이터가 64비트가 더 커서 빠를수 있다.

**그러나 64비트 메모리 주소를 쓰면 모든 포인터를 저장할 때 메모리가 두배 필요하다.** 포인터를 사용하는 자료구조의 경우 똑같은 자료구조를 써도 64비트 애플에서는 32비트 애플에 비해 메모리가 두 배 필요하다. 더 중요한 건, 32비트 애플이든 64비트 애플이든 프로세서 캐시 크기는 똑같다는 점이다. 

64비트 자료구조는 더 용량이 많이 차지하기 때문에 캐시에 조금밖에 못넣는다. 따라서 액세스 할 값을 메인 메모리에서 가져올 때까지 기다려야 하는 캐시 미스가 발생할 확률이 높아진다.



## 해시테이블과 이진 검색트리

`해시 테이블과 이진 검색 트리를 비교해 보고 각각의 장단점을 논해보라. 메모리가 제한된 모바일 기기용 주소록에 사용할 자료구조를 설계한다면 어느 쪽을 쓰는 것이 좋을까?`

해시테이블은 데이터를 저장하거나 가져오는 면에서는 매우 빠르다. (평균적으로 O(1))하지만 그 외의 용도로는 제약이 많다.

이진 검색트리를 쓰면 O(log(n))으로 자료를 집어넣거나 찾아낼 수 있다. 해시 테이블의 O(1)에 비하면 느리지만 그래도 빠른 것이다. 게다가 이진 검색 트리에서는 자료가 정렬된 순서 그래도 유지된다. 모바일 기기에서는 자료저장에 쓰이는 메모리를 최대한 아껴야 한다. 해시 테이블처럼 정렬되지 않은 자료구조를 사용하면 값들을 알파벳 순서대로 화면에 표시한다거나 하는 경우에 값들을 정렬하기 위해 메모리를 추가로 사용해야만 한다. 따라서 해시 테이블을 사용하면 자료를 저장할 용도로 써야할 소중한 메모리를 정렬용으로 남겨둬야 하는 문제가 생긴다.

이진 검색트리를 사용하면 레코드를 화면에 표시할 때 정렬을 하기 위해 따로 연산을 처리하지 않아도 되고, 그런 작업을 위해 메모리를 낭비할 필요도 없다. 이진 검색 트리가 해시 테이블에 비해 느리긴 하지만 모바일 기기에서는 주소가 웬만큼 많아도 10000개를 넘어가진 않는 수준이기 때문에 이진 검색 트리의 O($logN$)룩업 속도 정도면 충분히 빠르다. 따라서 이런 용도로는 해시 테이블보다는 이진 검색 트리를 쓰는 쪽이 더 낫다.



