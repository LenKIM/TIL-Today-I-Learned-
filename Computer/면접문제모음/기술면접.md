# #기술면접 대비

#### 지식기반 질문 ( 필기시험 뿐만 아니라 기술 면접에서도 전반적으로 물어보는 추세입니다. )

: 기본 자질을 알아보기 위함. 때로는 경험한 프로젝트 관련 심층 지식을 물어보는 경우도 존재. 임계치를 넘지 못하면 좋은 결과를 기대할 수 없습니다.

` 브라우저에서 주소를 요청해서 결과를 받을 때까지의 과정`

브라우저에서 주소를 요청할 때 가장 먼저 자신의 PC에 저장된 HOST파일을 확인합니다. 해당 파일에 이전에 기록해둔 주소가 있다면 해당 요청에 대한 결과를 받고 그것이 아니라면, 브라우저와 컴퓨터 내부 DNS 캐쉬를 확인합니다. 여기까지가 컴부터 내부에서 주소를 요청했을 때 결과가 있나 없나 체크하는 방식입니다. 만약 여기까지 없다면, 주소의 URL 중 .(닷)으로 구분된 루트 DNS부터 차례로 요청한 주소에 대한 IP주소를 찾습니다. www 까지 확인해 IP주소를 브라우저가 알게되면 이를 요청당하는 서버에 IP와 함께 웹 어플리케이션 서버에 요청합니다. 이후 웹 어플리케이션 서버에서 그에 대한 리스폰스를 받아 화면에 보여줍니다. 만약 요청이 성공적으로 되었다면 요청했던 주소를 컴퓨터 내부의 DNS 캐쉬에 저장해 둡니다.

`자신 있는 기술`
아무래도 Android 와 Javascript를 활용한 기술에 자신있습니다.


`OSI 7 계층에 대한 질문`

물리계층 - 흔히 아는 랜카드일수도 있고, 물리적신호를 논리적신호로 변환해주는 계층입니다. (비트)
데이터링크계층 - 데이터링크계층에서는 비트를 통해 받은 내용에 흐름제어, 오류검출등을 수행하며 미들웨어에 전송합니다. (프레임)
네트워크계층 - 어떤 경로로 데이터를 주고받아야하는 지를 정해줍니다. 이때 병목현상등을 방지하는 혼잡제어 기능도 함께합니다.(패킷)
전송계층 - 데이터링크와 유사하게 흐름제어와 오류검출을 하는데, 이때 윈도우프로토콜이라는 방식으로 수행됩니다. 데이터링크와 다른점은 미들웨어가 아닌 End To End 방식으로 동작됩니다.(세그먼트, 데이터그램)
세션계층 - 세션은 동기점을 설정하여 데이터를 받았다 못받았다를 보장해주는 계층입니다. 만약 특정 데이터를 받지 못했다면 전체를 다시 받는 것이 아닌 확실히 받은 동기점 다음부터 다시 전송을 시도합니다.
표현계층 - 데이터을 암호화하거나 또는 암축, 그리고 데이터 표현의 일관성을 보장해주는 계층입니다.
응용계층 - HTTP, SMTP, POP, IMAP 등의 프로토콜에 이에 해당하는데요. 사용자 인터페이스 프로그램이 해당 계층에 포함됩니다.



`싱글 톤 패턴을 화이트보드에 구현하기`

```java
class WorkMoblie{
	
	private static WorkMobile instance = new WorkMobile;
	
	void WorkMolie(){

	}

	public static WorkMobile getIntance(){
        return instance;
	}	

	public static void Main(String ... arg){
    
	}
}
```

```java
class WorkMobile {
    
    private static WorkMobile instance;
    
	public static WorkMobile getInstance(){
            if(instnace == null){
                instance = new WorkMobile();
            }
            return instance;
    }
}
```

`안드로이드 액티비티 생명주기`





`스레드와 프로세스의 차이`

`데이터베이스 정규화`

`해시 테이블`

`TDD란`

`대용량 트랜잭션 처리에 대한 문제`

`지원한 분야의 가장 기본이 되는 몇가지 API에 대해 어떻게 만들어졌고, 어떻게 구현할 것이고, 어떤 구조인지`

`스프링이나 대용량 DB구조, 인덱스`

`Java와 JavaScript차이`

`Linked List와 Array 차이`

2.     알고리즘관련 질문 ( 주로 개발업무를 직접적으로 맡아 하는 회사 및 직무에서 집중적으로 물어봅니다. )

: 실제 코딩 능력 및 문제해결 능력을 가졌는지 알아보기 위함입니다. 이것 하나만으로 당락이 결정되는 기업도 심심치 않게 볼 수 있습니다.

: 손 코딩의 경우 주로 입출력을 직접 받기보다는 메모리에 존재한다고 가정하고, 함수 단위로 작성하는 경우가 많음. 단계별로 진행하게 되는데, ‘아이디어 도출 -> 코드 작성 -> 코드 설명’ 단계로 이루어지며, 감독관은 화이트보드에 적힌 코드를 핸드폰으로 찍는 경우 , 실시간으로 IDE에 따라 작성하여 디버깅하는 경우가 있음. 

n  공이 9개 있다. 무게가 가벼운 공 하나를 찾는데 최소한의 횟수.

3개씩 나눈 다음에 그 중에서 두 묶음만 저울로 잽니다. 수평이면 안 잰 묶음에 무거운 게 있을 것이고 기울면 그쪽에 있을 것이니 그렇게 한 묶으로 추려지구요. 남은 3개를 같은 방식으로 재면 저울에 올리지 않은 것이 무거운 것이면 수평일테고, 저울에 올린 것 중에 무거운 것이 있으면 기울테니 알 수 있습니다.


n  하노이 탑 손 코딩

//TODO

n  1~1000 까지 숫자가 무작위로 1000개가 있는데 이에 대한 평균값을 알아내는 알고리즘 설계

이건 CountingSort로 풀어야 합니다. Logn

1~1000라는 범위가 정해져있기 때문에, 1000개의 배열을 만들고 랜덤값이 나올때 해당 인덱스의 숫자를 올려줍니다. 1000개의 호출이 끝났을때. 앞에서부터 하나씩더하다가 500이 나오는 순간의 인덱스를 보여주면 됩니다.



n  디버깅 능력, 오류색출능력

n  토폴로지 소트 관련 손 코딩 : <https://algospot.com/judge/problem/read/DICTIONARY>

n  다이내믹 프로그래밍 관련 손 코딩 : <https://www.acmicpc.net/problem/1912>



3.     프로젝트관련 질문 ( 기술면접의 메인 디쉬 )

: 전문성과 협업 능력을 알아보기 위함입니다. 꼬리 물기 질문으로 진위여부를 가장 예민하게 탐색하는 부분입니다.

n  이전에 담당했던 프로젝트에 대한 구조 설명

n  기존 업무를 진행하면서, 디자이너들과 협업해본적은 있는지, 프로젝트 매니지먼트는 어떻게 했는지

n  기억에 남는 trouble shooting.

n  가장 창의적인, 도전적인, 끈기를 다한, 실패한 ‘직무관련’ 경험

4.     인성 질문 ( 기술면접 파트에서도 드물게 물어볼 때가 있습니다. )

: 조직 및 기업 친화적 성향을 가졌는지, 자기자신 및 기업의 미래 청사진은 가지고 있는지 알아보기 위함입니다. 원한다면 프로젝트 관련 답변으로 방향을 돌릴 수 있는 질문도 출제됩니다.

n  자기소개서와 관련된 내용, 앞으로 하고 싶은 일이 무엇인지, 지금까지 무엇을 경험했는지

n  살면서 가장 큰 성공을 거두었던 경험

n  하고 싶은 것 좋아하는 분야가 어떤 분야인가

n  왜 ~ 것들을 했는지

n  최근 사회 이슈 ex) 대기업의 사회적 의무, 정년 연장, 명예퇴직 권고 등에 대한 자신의 견해

5.     기타

: 지원자가 얼마나 공학적으로 현실 문제를 생각할 수 있는지 알아보기 위함입니다. 최대한 SW개발자 답게 문제를 풀어내는 능력을 보이는 것이 좋습니다.

n  창의성 문제 : 경험상 알고리즘 풀이법을 적용해 보는 것이 좋을 듯 하다. 문제는 항상 불완전하다고 가정하고 문제를 논리적으로 재정의해가면서 푸는 능력이 필요하다. 

u  문제정의 (problem space n이 몇일까) -> 해결방안 모색 (time complexity는 얼마나 될 것 인가) -> 오차 값 추산(어느 정도의 error rate를 예상할 수 있을까)

n  프로젝트 설계 문제 : 관련 주제에 적합한 지식을 가지고있으면 유용하다. 기술은 항상 trade off 관계가 있기 때문에, 설계한 방식의 장단점을 미리 예측하여 정리하는 것이 필요하다.

u  Ex) 광고성, 악성 블로그 활동을 저지하기 위한 시스템 설계 -> 구글 페이지랭크 알고리즘





### `REST API란 무엇인가?`

REST란 하나의 컴퓨터에서 사용되는 아키텍처를 말합니다. 또 다른 표현으로 REST는 Resource Oriented Archture라고 말할 수 있습니다. 이것의 의미는 설계를 할 때 Resource를 중심에 두고 HTTP Method를 활용하여 서버와 클라언트같의 프로토콜을 설계하는 것을 말합니다.

REST API를 설계하기 위해서는 6가지의 원칙있습니다.

첫번째로, Uniform interface입니다. URI라는 리소스를 활용해 서버와 클라이언트간의 조작을 통일시킵니다.

두번째는, Stateless 입니다.  REST는 상태정보를 따로 저장하지 않고 관리하지 않습니다. 때문에 서비스의 자유도가 높아지고 서버에서 불필요한 정보를 관리하지 않음으로써 구현이 단순합니다.

세번째는 Cacheable(캐시 가능) HTTP라는 기존 웹표준을 그대로 사용하기 때문에, 웹에서 사용하는 인프라를 그대로 활용이 가능해 HTTP가 가진 캐싱 기능이 적용가능합니다.

네번째로 자체표현구조가 가능합니다. URL을 통해 가독성있는 URL을 만들어 자체적으로 표현구조가 가능하게 만듭니다.

다섯번째로 서버-클라의 구조를 유지합니다.

마지막으로 계층형 구조를 이루고 있어, 로드밸런싱이나 암호화 계층을 추가해 유연성을 둘 수 있습니다.



### `정렬 차이`

정렬에는 선택 정렬, 삽입 정렬, 버블 정렬, 쿽 정렬, 합 정렬이 있습니다.

**선택정렬**은 배열의 첫 번째 원소에서 시작하여 배열 전체를 흝으면서 가장 작은 키를 가지는 원소를 찾아서 첫 번째 원소와 맞바꾼다. 

```java
class SelectionSort{
    
    public static void Main(String ... args){
     int [] input = {2,4,1,5,6};
     int size = input.length()
     for(int i = 0; i < size; i++;){
         int MAX = i;
         for(int j = i; j < size; j++){
             if(input[MAX] < input[j]){
                 MAX = j;
             }
         }
         swap(input, i, MAX);
     	}   
}
```



**삽입정렬**은 한 번에 한 원소씩 이미 정렬된 다른 원소들과 비교하여 새 원소를 제 위치에 삽입하는 식으로 정렬된 배열을 만듭니다. 최선의 경우 O(n) 최악의 경우 O(n^2)

```java
class InsertionSort{
    
    public static void Main(String... args){
        int [] input = {2,4,1,5,6};
        int size = input.length;
        int i;
        for(i = 1; i < size; i++){
        	int key = i;
         	for(int j = 0; j < i; j++){
                if(input[key] < input[j]){
                    swap(input, key, j);
                }
         	}
        } 
    }
}
```



**버블정렬**은 인접한 두개의 값을 비교합니다. 비교했을 때 큰 값을 오른쪽으로 둡니다.

```java
class bubbleSort{
    
    public static void Main(String ... args){
    	int [] input = {2,4,1,5,6};
        for(int i = 0; i<input.length-1; i++){
            for(int j = 0; j < input.length-1-i; j++){
                if(index[j] > index[j+1]){
                    swap(input, j, j+1);
                }
            }
        }
    }
}
```



**쿽정렬**의 경우에는 정렬된 데이터에서는 비효율적이므로 그럴때는 차라리 삽입 정렬을 쓰는 편이 좋다. 그러나 많은 데이터들에 대한 정보가 없고 정렬되있는 모른다면 최악의 경우에도 nlongn을 보장하는 쿽정렬을 쓰는 것이 좋다.

```java
class QuickSort{
    
    public static void Main(String ... args){
        int[] input = {2,4,1,5,6};
       	quickSort(input, 0, input.length-1);
        
    }
    static void quickSort(int [] input, int p, int r){
        if(p < r) {
            q = partition(input, p, r);
            quickSort(input, p, q-1);
            quickSort(input, q+1, r);
        }
    }
    
    static int partition(int [] input, int p, in r){
        
        int pivot = input[r];
        int i = p-1;
        for(int j = p; j <= r-1; j++){
            if(input[j] <= pivot){
                i = i +1;
                swap(input, i, j);
            }
        }
        swap(input, i+1, j);
        return i+1;
    }
}
```

비재귀

```java
class QuickSort{
    
    public static void Main(String ... args){
        int[] input = {2,4,1,5,6};
       	quickSort(input, 0, input.length-1);
        
    }
    static void quickSort(int [] input, int p, int r){
        
        int stack[] = new int[r-p+1];
        int top = -1;
        stack[++top] = p;
        stack[++top] = r;
        
        while(top >= 0){
            r = stack[top--];
            p = stack[top--];
            
            int q= partition(arr, p, r);
            
            if(q-1 > p){
                stack[++top] = p;
                stack[++top] = q-1;
            }
            
            if(q+1 < r) {
                stack[++top] = q+1;
                stack[++top] = r;
            }
        }
    }
    
    static int partition(int [] input, int p, in r){
        
        int pivot = input[r];
        int i = p-1;
        for(int j = p; j <= r-1; j++){
            if(input[j] <= pivot){
                i = i +1;
                swap(input, i, j);
            }
        }
        swap(input, i+1, r);
        return i+1;
    }
}
```



**병합정렬**은 데이터 집합은 둘 이상의 부분집합으로 가르고, 각 부분집합을 정렬한 다음 부분집합들을 다시 정렬된 형태로 합치는 방식의 정렬을 하는 분할정복형 알고리즘.

**합치기 정렬**은, 최고, 최저, 평균 실행시간 모두 nlong이기 때문에 정렬 시간의 상한을 철저하게 지켜야할 때 좋다. 하지만 다른 알고리즘 대비 공간복잡도 O(n) 메모리가 추가로 필요하다는 단점이 있다.



```java
class MergeSort{
   
    public static void Main(String ... args){
     	int [] input = {3,2,1,4,5};
        int size = input.length;
        mergeSort(input, 0, size -1);
    } 
    static void mergeSort(int [] input, int start, int end){
        int [] temp = new int[input.length];
        
        if(start < end){
            int mid = (start + end)/2;
            mergeSort(input, start, mid);
            mergeSort(input, mid+1, end);
            merger(input, temp, start, mid, end);
        }
    }
    
    static void merge(int [] input, int[] temp, int start, int mid, int end){
        
        int i = start;
        int j = mid + 1;
        int k = start;
        
        while(i <= mid && j <= end){
            if(input[i] <= input[j])
                temp[k++] = input[i++];
            else
                temp[k++] = input[j++];
        }
        
        while(i <= mid)
            temp[k++] = input[i++];
        
        while(j <= end)
            temp[k++] = input[j++];
        
        for(int z = start; z <= end; z++){
            input[z] = temp[z];
        }
    }
}
```

힙소트의 경우에는 최악의 경우에도 NlongN이 되는 빠른 정렬이다. 정렬할때의 시간 복잡도는 nlongn
힙소트의 공간복잡도는 O(1)이 걸린다.

```java
public static void main(String ... args){
    int [] input = {3,10,4,5,1};
    heapSort(input, input.length);
}

static void buildMaxHeap(int [] input, indt index){ // input, length가 들어옴
    for(int i = index/2; i >= 0; i--){
        maxHeapify(input, index, i);
    }
}

static void maxHeapify(int[] input, int size, int idx){
    int left = idx * 2;
    int right = idx * 2 + 1;
    int largestK = idx;
    int temp = 0;
    
    //왼쪽 오른쪽 자식이 없을 경우
    if((left > size || rigth > size)
      			|| (input[left] == null && input[right] == null))
        return;
    
    //왼쪽 자식 노드와 비교
    if(left< size && input[left] > input[largestK])
        largestK = left;
    
    if(right < size && input[right] > input[largestK])
        largestK = right;
    
    if(idx != largestK){
        swap(input, idx, largestK);
        maxHeapify(input, size, largestK)
    }
}

static void heapSort(int[] input, int length){
    
    int temp = 0;
    buildMaxHeap(input, length);
    
    for(int count = length-1; count >0; count--){
        swap(input, count, 0);
        maxHeapify(input, count, 0);        
    }
}
```

##### `1. 정렬할 때 가장 적합한 알고리즘은 무엇인가?`

데이터에 따라 다르다고 말해야 함.

##### `2.마스터 디렉터리 서버에서는 여러 부서별 디렉터리 서버로부터 사용자 ID를 기준으로 정렬된 계정 목록을 수신한다. 이 서버에서 모든 계정을 사용자 ID를 기준으로 정렬된 상태로 합쳐두고 마스터 목록을 만들 때 가장 좋은 접근법은? `

- 가장 단순한 방법은 모든 하위 목록을 쭉 이어 붙인 다음 퀵 정렬 같은 일반적인 정렬 알고리즘을 적용해서 합쳐진 목록을 만드는 방법
- 만약 충분한 공간이 제공된다면 이미 정렬된 공간을 활용하여 합치기 정렬을 활용할 수 있을 것입니다.

##### `3. 어떤 제조공장을 모니터하는 시스템에서 품질 관리를 할 때 불량이 난 모든 항목의 일련번호를 목록으로 저장해 둔다고 하자. 근무 시간 동안 공장이 가동되는 중에는 새 일련번호를 목록 맨 뒤에 덧붙인다. 그리고 매일 밤 배치 작업을 돌려서 목록을 다시 정렬한다. 이때 쓸 수 있는 가장 좋은 정렬 알고리즘은?`

- 전날 정돈된 일련번호까지 이미 정렬이 되어있고, 그 날 새로 추가된 일련번호만 정렬이 안되어 있다. 보통 일련번호는 순차적으로 매기는 걸 감안하면 새로 추가된 일련번호도 어느 정도는 정렬이 되어 있을 가능성이 높다. 고장을 몃 주 정도 가동하고 나면 목록 전체 크기에 비해 매일 추가되는 데이터양이 휠씬 적을 것이라고 가정해야 전혀 문제없다.
- 정리해 보자면, 이 문제는 소수의 정렬되지 않은 항목들은 커다란 정렬된 목록에 추가하는 문제라고 할 수 있다. 그리고 이런 문제에는 삽입 정렬이 제격이다. 왜? 삽입 정렬이 최선의 속도인 O(n)이 나오는 상황과 거의 비슷해 보인다. 하지만 잠시 멈추고 삽입 정렬의 다른 성질을 따져 보자.

##### `4.여러 종류의 데이터를 정렬해야 하는데, 그 데이터에 대해 아는 게 거의 없다. 데이터 집합이 크진 않아서 메모리에 전부 들어갈 수 있지만 각각의 크기는 많이 다를 수 있다. 어떤 정렬 알고리즘을 쓰는 게 좋을까? `

이 문제가 쿽 정렬로 하기 좋다. 정렬할 데이터에 대해 아는 게 거의 없이 그냥 정렬해야 하는 상황이 매우 흔하게 발생하곤 하는데, 이런 경우에는 일반적인 속도만 생각해서 정렬할 수 밖에 없다. 주어진 문제가 그냥 일반적인 정렬 문제인지 확실히 따져보고, 혹시 조금 더 특화된 정렬 알고리즘을 선택할 만한 근거가 있는데 놓치고 있는 건 아닌지 다시 한번 살펴봐야한다. 

정리하면, 일반적인 데이터 집합의 경우 합치기정렬(안정성이 중요한 경우)이나 퀵 정렬(안전성이 중요하지 않은 경우)을 쓰는 편이고, 데이터 집합이 아주 작은 경우(n값이 10미만 경우)에는 삽입 정렬을 쓰기도 한다.



##### `5. 프로세스와 스레드의 차이점은?`

프로세스란 특정 Process State(상태) 위에서 수행되는 **execution Stream **입니다. 프로세스는 메모리위에서 상주하면서 CPU를 통해 프로세스가 작동됩니다.
이 떄 프로세서는 코드 데이터 스택 힙으로 나눠지고, 여기서 스레드의 개념이 나타납니다. 스레드는 프로세스의 작업단위라고 말할 수 있습니다. 또한 스레드는 프로세스의 자원을 공유할 수 있으면서, 스레드 자체에 스택과 PC레지스터를 할당받아 동작하게 됩니다.

그럼 스레드에서 스택은 무엇이고, PC레지스터는 무엇이냐면, 스택은 스레드에서 함수호출이 되었을 때 현재의 작업을 저장하는 공간이고, PC 레지스터는 작업이 스텍에 저장되면서 되돌아갈 주소를 저장하는 레지스터입니다.

##### `6. 시스템 스레드와 사용자 스레드의 차이는 무엇인가요?`

스레드를 생성한 주체가 누구인가에 따라 다릅니다. 기본적으로 애플리케이션의 첫번쨰 스레드는 시스템 스레드이고, 사용자가 생성한 스레드는 사용자 스레드가 됩니다.

##### `7. 모니터와 세마포어`

멀티스레딩을 구현하면 가장 문제가 되는 것이 동기화 문제입니다. 각각의 스레드는 프로세스의 자원을 공유하고 있기 때문에 간혹 엉뚱한 값을 읽을 수 있어 이를 제어하기 위해 모니터와 세마포어가 있습니다.
세마포어는 P연산과 V연산으로 이루어져 있으며, 자물쇠 역할을 하는 추상형 오브젝트입니다. 반면에 모니터는 세마포어의 단점을 극복하기 위해서 나온것으로 자물쇠 역할에 루틴의 집합을 추가 한 것입니다.

앞서 말씀드린 세마포어의 단점이란, 코딩하기가 어렵고 한번의 실수가 모든 시스템에 치명적인 영향을 줄수 있다는 것이 단점입니다. 이러한 문제를 모니터는 자바의 메소드처럼 루틴을 만들어 오직 한개의 프로세스만 존재할 수 있도록 만들어 줍니다.

##### `8.바쁜대기란 무엇이고 어떻게 하면 바쁜 대기를 피할 수 있는지 말해보라 `

 하나의 작업을 완료하기 위해 다른 스레드는 작업을 마칠 때까지 기다려야하는데, 이 때 첫번째 스레드가 여전히 활성 상태로 남아 있기 때문에 이를 바쁜대기라고 말할 수 있습니다.

이를 해결하기 위해 세마포어나 모니터를 써서 피할 수 있으며, 어느 쪽을 활용하든 상황에 따라 달라질 수 있습니다. 또는 스레드에서 작업이 끝났음을 알려줄 때까지 대기하는 wait()같은 명령어를 통해 스레드를 휴지상태로 전환해주면됩니다.



##### `9. 교착 상태의 4가지 조건은 무엇인가요?`

상호배제 - 매 순간 하나의 프로세스만이 자원을 사용할 수 있음  
비선점 - 프로세스는 자원을 스스로 내어놓을 뿐 강제로 빼앗기지 않음  
보유대기 - 자원을 가진 프로세스가 다른 자원을 기다릴 때 보유 자원을 놓지않고 계속 가지고 있음  
순환대기 - 자원을 기다리는 프로세스간에 사이클이 형성되어야 함.

##### `10. 메모리 계층 구조는? `

CPU, 캐시, 메인메모리, 보조디스크

##### `11. 메모리 할당 알고리즘 First Fit, Next Fit, Best Fit, worst fit`

기억장치 배치전략은 새로 적재되어야 할 프로그램과 데이터를 주기억장치 영역 중 어느 곳에 배치할지를 결정하는 전략이다.

first fit은 충분한 공간이 발견되면 바로 적재하는 것이고,

next fit은 first fit과 유사하지만, 시작할 인덱스가 저번에 참조한 공간이다.

best fit은 전체중에 가장 최적인 공간에 적재하는 것이다. 모두다 탐색해야 하기때문에 느리다.

worst-fit사용 가능한 공간들 중에서 가장 큰 것을 선택하는 방식이다. 할당해주고 남는 공간을 크게 하여 다른 프로세스들이 그 공간을 사용할 수 있도록 하는 전략이다. 이 방법 역시 최적 적합과 마찬가지로, 가용 공간들에 대한 목록이 그 공간들의 크기 순서대로 정렬되어 있지 않다면 최적인 곳을 찾기 위해 전체를 검색해야 한다.


##### `11. 페이지 교체 알고리즘에 따른 페이지 폴트 횟구 구하기? `

Optimal은 페이지 폴트가 최소화 하는 방법으로

Lru는 마지막 참조한 것을 우선순위

Lfu는 많이 참조한 것을 우선순위

Fifo는 순서대로 출력 (페이지를 크기를 늘려도 교체가 많이 일어남( Badly의 이상?))



##### `12. 외부 단편화 와 내부 단편화란 무엇인가? `

일단 단편화라는 것은 메모리안에서 사용할 수있는 공간이 있음에도 불구하고 사용하지 못하는 현상을 말합니다.

내부 단편화의 경우에는 가상메모리를 물리메모리로 변환시키기 위한 기법중에 하나로 페이징 기법을 활용하는데, 페이징 기법은 일정한 크기로 나누기 때문에, 예를 들어 4kb로 나눴는데, 프로세스의 크기가 3kb라면 1kb의 내부 단편화가 일어나는 것입니다.

외부 단편화의 경우에는 동일하게 가상메모리를 물리메모리로 변환시키 위한 기법 중 세그멘테이션 기법을 활용하는데, 이때 논리적 성질이 유사한 거끼리 그룹을 만들어 메모리를 할당하면서 가변적인 메모리 때문에 애초부터 메모리가 적재할 수 없는 현상을 외부 단편화라고 합니다.



##### `13. RISK방식과 CISK 방식의 차이는?`



##### `14. Context Switching이란?`

CPU를 한 프로세스에서 다른 프로세스로 넘겨주는 과정을 문맥 교환이라고 합니다. CPU를 내어주고 프로세스의 상태를 그 프로세스의 PCB에 저장합니다. CPU를 새롭게 얻은 프로세스의 상태를 PCB에서 읽어옯니다.

##### `15. 인터럽트 발생했을 때 그 과정을 아는가?`

키보드와 같은  I/O 장치에서 인터럽트가 발생되면, 가장 인터럽트 신호를 검출한 뒤, CPU는 인터럽트 처리 루틴을 확인합니다. 그리고 난 뒤 현재 프로세스 주소를 프로그램 카운터에 보관한 뒤 모드비트를 0으로 변경하고 I/O 인터럽트를 처리한 뒤 다시 프로그램에 카운터에 저장되었던 주소를 불러와 이전 작업을 계속 실행합니다.

##### `15. 운영체제란 무엇인가?`

컴퓨터 하드웨어 바로 위에 설치되어 사용자 및 다른 모든 소프트웨어와 하드웨어를 연결하는 소프트웨어 계층

##### `16. 스레싱(Thashing)이란 무엇인가? 해결은?`

기억장치의 페이지 부재가 비정상적으로 많이 발생하여 CPU가 프로그램 처리보다 페이지 교체에 더 많은 시간을 보내 성능히 급격히 줄어드는 현상 멀티 프로세싱 기능을 갖춘 시스템에서 가상 메모리의 페이지 부재(Page Fault)가 너무 많이 발생하여 프로세스 실행보다 페이지 교체에 더 많은 시간을 소모하는 현상

이를 해결하기 위해서는 

1. 다중 프로그래밍 정도를 낮춤으로써 조절합니다.
2. 또는 지역 참조성을 활용하거나, 자주사용되는 페이지들로 구성된 Working Set 을 구성하여 스레싱을 방지합니다.

#####`17. 멀티 프로세싱(Multi Processing), 멀티 프로그래밍(Multi-Programming), 멀티 태스킹(Multi-tasking), 멀티 스레딩(Multi-threading)?`

멀티 프로세싱이란, 다수의 프로세서가 협력적으로 작업을 동시에 처리하는 것을 말합니다.  
멀티 프로그래밍이란, 특정 프로세스에 대해 프로세서가 작업을 처리할 때 낭비되는 시간동안 다른 프로세스를 처리하도록 하는 것을 말합니다.  
멀티 테스킹이란, 다수의 TASK를 운영체제의 스케쥴링에 의해 번갈아가면서 수행하는 것을 말합니다.  
멀티 스레딩은, 하나의 프로세스내에서 여러개의 스레드가 존재하는 것을 말합니다.

##### `18. 캐싱의 갱신 기법중에 Write-Through 와 Write-Back이 있는데 이 둘의 차이는 무엇일까요?`

Write-through는 캐시와 메모리를 동기화시키는 것을 말합니다. CPU가 주기억장치 또는 디스크로 데이터를 기입하고자 할 때 그 데이터는 먼저 캐시로 기입됩니다. 동시에 주기억장치또는 디스크로 기입되는 방식을 write-through 라고 합니다. 장점은 싱크가 되기때문에 불일치현상은 없지만 갱신하는 동안 속도가 느립니다.

Write-back은 일단 캐시로 먼저 기록하는데, 일시적으로 저장된 후에 블록 단위로 유휴 머신 주기동안에 캐시로부터 해제될 때 주기억장치 또는 디스크로 기록되는 방식입니다.



//TODO 은행가 알고리즘 과 식사하는 철학자 문제 해결하기.







## # 네트워크

##### `1.네트워크 계층 설명하시오. 7계층`

##### `2.IPv4 에서 IPv6으로 변경된 이유와 장단점`

##### `3. HTTP와 프로토콜에 대해서 설명하시오.`

HTTP 프로토콜은 웹 브라우저와 웹 서버 사이의 데이터 통신 규칙입니다.  
\- 웹 페이지의 링크를 클릭하면, 웹 브라우저는 HTTP요청 형식에 따라 웹 서버에 데이터를 전송, 웹 서버는 웹 브라우저가 보낸 데이터를 분석하여 요청 받을 일을 처리하여 응답.  
\- 프로토콜은 통신에서 통신규약 및 약속을 의미합니다. 사용목적은 서로 다른 시스템간의 정보통신을 원할히 하기 위해서이다. 대표적으로 TCP/IP

##### `4. POST, GET 방식의 대해서 설명하시오`

##### `5. 비동기통신과 동기통신의 차이점에 대해서 설명하시오.`

##### `6. CGI에 대해서 설명하시오. (Common Gateway Interface)`



웹 어플리케이션의 실행은 웹 브라우저가 웹 서버에게 실행을 요청하면서 발생한다. 웹 서버는 클라이언트가 요청한 프로그램을 찾아서 실행하고, 해당 프로그램은 작업을 수행한 후 그 결과를 웹 서버에게 돌려줍니다.  
그러면 웹 서버는 그 결과를 HTTP형식에 맞추어 웹 브라우저에게 보냅니다. 이때, 웹 서버와 프로그램 사이의 데이터를 주고받는 규칙을 CGI라고 합니다.



**WWW서버와  서버 상에서 등장하는 다른 프로그램이나 스크립트와의 인터페이스.**
폼으 사용한 메일의 송신이나 게임 등, HTMㅣ에서는 불가능한 인터랙티브한 요소를 홈페이지에 받아들여 쓸 수 있다.

CGI는 [웹 서버](http://terms.naver.com/entry.nhn?docId=855038&ref=y)를 운영하는 사람이 사용자들로부터 특정 정보를 얻어 자신의 프로그램에 사용하려고 할 때 필요한 인터페이스이다.



![http://dthumb.phinf.naver.net/?src=%22http%3A%2F%2Fdbscthumb.phinf.naver.net%2F0805_000_1%2F20111121125204187_IK5ETHFQV.jpg%2FC511_i1.jpg%3Ftype%3Dm4500_4500_fst_n%26wm%3DY%22&twidth=1055&theight=722&opts=17](http://dthumb.phinf.naver.net/?src=%22http%3A%2F%2Fdbscthumb.phinf.naver.net%2F0805_000_1%2F20111121125204187_IK5ETHFQV.jpg%2FC511_i1.jpg%3Ftype%3Dm4500_4500_fst_n%26wm%3DY%22&twidth=1055&theight=722&opts=17)



##### `7. HTTP의 Method는? `

Get : 정보를 요청하기 위해 사용

Post : 정보를 삽입하기 위해 사용 

Put : 정보를 업데이트하기 위해 사용 

Delete : 정보를 삭제하기 위해 사용 

Head : 헤더정보만 요청한다. 해당 자원이 존재하는지 혹은 서버에 문제가 없는지를 확인 

Trace : 클라이언트의 요청을 그대로 반환한다. echo서비스로 서버상태를 사용하기 위한 목적으로 사용함 

Options : 서버가 지원하는 메소드 종류를 요청한다.

##### `8. http1과 http2 의 차이점을 설명해봐라`

http/1.1 기본적으로 Connection당 하나의 요청을 처리하도록 설계되어있다. 그래서 동시전송이 불가능하고 요청과 응답이 순차적으로 이루어 지게된다. 

http/2.0은 http/1.1이 느려서 버전을 개선한 것

http/1.1이 느린 이유

(1)클라이언트가 서버에게 요청을 보내면 서버가 클라이언트에 대한 응답을 보냄

(2)양방향(round trip) 지연 

(3)헤더가 크다(특히 쿠키 때문)

. http/1.1의 헤더에는 많은 메타 정보들이 저장되어 있음.

사용자가 방문한 웹페이지는 다수의 http 요청이 발생하게 되는데 이 경우 매 요청시 마다 주복된 헤더 값을 전송하게 되며 

각 도메인에 설정된 쿠키정보도 매 요청시 마다 헤더에 포함되어 전송, 

http/2.0의 등장 : SDPY(구글 제안 프로토콜) 기반으로 http/2 등장

http/2.0이 빠른 이유

(1)헤더 압축

(2)클라이언트에서 요청을 하지 않아도 서버가 리소스를 마음대로 보냄

(3)한 커넥션으로 동시에 여러 메시지를 주고받을 수 있음

##### `대칭키 암호 방식(DES, AES)`

##### `비대칭키 암호(공개키 암호 RSA)`

공개키로 암호화를 하는 경우, 상대방의 공개키로 데이터를 암호화하고 데이터를 전달하면, 데이터를 전달받은 사람은 자신의 개인키로 데이터를 복호화 된다. 

##### `전자 서명`

반대로 개인키로 암호화를 하는 경우가 이에 해당된다. 개인키의 소유자가 개인키로 데이터를 암호화하고 공개키와 함께 전달된다. 이 과정에서 공개키와 데이터를 획득한 사람은 공개키를 이용하여 복호화가 가능하다. 이런 위험에도 불구하고 이 방법을 사용하는 이유는 데이터 보호의 목적보다는 공개키가 데이터 제공자의 신원을 보장해주기 때문이다. 암호화된 데이터가 공개키로 복호화된다는 것은 공개키와 쌍을 이루는 개인키에 의하여 암호화되었다는 것을 의미. 즉, 데이터의 제공자의 신원확인이 보장된다는 것이다. 





## # 데이터베이스



1. 데이터베이스 트랜잭션

   데이터베이스에 저장된 데이터의 무결성은 정말 중요하다. 데이터에 문제가 생기면 그 데이터베이스에 의존하는 모든 애플리케이션이 멎어버리거나 오류를 일으키기 때문이다. 참조 무결성도 데이터를 일관되게 유지하는 데 도움이 되긴 하지만, 데이터 무결성을 위해 가장 좋은 방법은 데이터베이스 트랜잭션을 사용하는 것  

   **트랜잭션은 한 단위를 이루는 일련의 연관된 데이터베이스 조작을 의미한다**. 한 트랜잭션에 속하는 작업 중 하나라도 실패하면 트랜잭션 전체가 실패한 것으로 간주하여 그 트랜잭션에서 데이터베이스를 변경한 내용을 전부 원래대로 되돌려 놓는다.(이를 롤백). 반대로 모든 작업이 성공적으로 처리되면 모든 변경 내용을 한꺼번에 반영시킨다(이를 커밋)

   **트랜잭션에는 다음과같은 네 가지 특성 ACID 라고 한다.**  
   ​
   \- 원자성(atomicity)  
   트랜잭션에 포함되는 모든 작업이 성공적으로 처리되지 않으면 트랜잭션에 들어있는 어떤 작업도 처리되지 않아야 한다.  

   \- 일관성(Consistency)  
   트랜잭션은 트랜잭션이 시작되기 전과 트랜잭션이 종료된 후에 데이터베이스가 올바르고 일관된 상태가 되도록 처리되어야 한다. 예를 들어, 참조 무결성이 깨지거나 하는 일이 일어나면 안된다.  

   \- 고립성(isolation)  
   한 트랜잭션에서 데이터베이스를 변경한 내용은 트랜잭션이 커밋될 때까지 다른 어떤 질의나 트랜잭션과도 고립되어야만 한다.

   \- 영속성(durability)  
   일단 커밋이 되고 나면 트랜잭션에 의해 변경된 내용은 영구적이어야 한다. 데이터베이스 시스템은 데이터베이스의 현재 상태가 유실되지 않도록 시스템 충돌 등의 문제로부터 복구할 수 있는 방법을 갖추고 있어야 한다.

   ​

2. **내부조인, 외부조인**

3. **집단 함수를 쓰지 않고 최댓값을 구하는 법**

   ````Sql
   Test {
       num INTEGER(4)
   };
   ````

   **집단 함수(MAX, MIN 등)를 쓰지 않고 num의 최댓값을 반환하는 SQL문을 작성?**
   ​

4. 간단한 SQL

   ```sql
   Olympics(
   	city CHAR(16),
   	year INTEGER(4)
   );
   ```

   Montreal과 1976을 데이터베이스를 입력

   **INSERT INTO Olympics VALUES( 'Montreal', 1976);**

5. 삼진논리

6. 정규화

   제 1정규화는 어떤 엔티티의 어트리뷰트가 오직 한개의 값만 갖는것을 말합니다.  
   제 2정규화는 어떤 릴레이션의 엔티티 관계가 완전 함수적 종속성을 만족하는 것을 말합니다.  
   이때 완전 함수적 종속성이란, x -> y일때, x엔티티의 어떤 어튜리뷰트가 제거될때 x->y가 성립되지 않는 조건을 말합니다.  
   제 3정규화는 이행적 함수적 종속성이 만족하지 않는 것을 말합니다.  
   이행적 함수적 종속성이란, x-> y, y-> z일때, x->z를 만족하는 것을 이행적 함수종속성이라고 합니다.
   그리고 BCNF이란 종속성을 발생시키는 결정자는 후보키이어야 한다.
   결정자이면서 후보키가 아닌 것을 제거하는 것을 말합니다.

7. DB의 무결성과 정합성에 대해서 설명.
   **무결성이란?**
   무결성이라 하면 결함이 없는 데이터를 말합니다. 즉 데이터의 정확성을 의미합니다.
   무결성의 종류로는 참조무결성이나 개체무결성, 도메인 무결성등있습니다.
   ​

   **정합성이란?**
   무모순성이란말입니다. 즉 모순이 없다라는 뜻입니다.
   ​

   무결성의 종류로 개체무결성, 참조무결성, 속성 무결성, 키 무결성이 있습니다.
   **개체무결성**은 기본키를 반드시 가져야하고, 기본키는 유일성을 보장하는 최소한의 집합이라는 뜻  
   **참조무결성**은 외래키 속성은 참조할 수 없는 값을 지닐수 없다.  
   **속성무결성**은 컬럼은 지정된 데이터 형식을 반드시 만족하는 값  
   **키 무결성**은 한 릴레이션에 같은 키 값을 가진 튜플들은 허용 하지 않는다.

   ​

   8. **데이터베이스 언어(DDL, DML, DCL, TCL)**

      DDL (Data Definition Language)
      CREATE, ALTER, DROP, TRUNCATE;

      DML (Data, Manipulation Lang)
      SELECT INSERT DELETE UPDATE;

      DCL
      COMMIT, ROLLBACK, GRANT, REVOKE

   9. **뷰의 특징과 장단점을 설명**
      허용된 데이터를 제한적으로 보여주기 위해 하나 이상의 테이블에서부터 유도된 가상 테이블

      \- 뷰가 정의된 기본 테이블이 변경되면, 뷰도 자동적으로 변경된다.  
      \- 외부 스키마는 뷰와 기본 테이블 정의로 구성  
      \- 뷰에 대한 검색은 기본테이블과 거의 동일하지만, 삽입, 삭제, 갱신은 제약을 받음  
      \- DBA는 보안측면에서 뷰를 활용

      ​

      장점
      \- 논리적인 독립성을 제공  
      \- 데이터 접근 제어로 보안이 가능  
      \- 사용자의 데이터 고나리를 간단하게  
      \- 하나의 테이블로 여러개의 상의한 뷰를 정의 

      단점  
      \- 독자적인 인덱스를 가질 수 없다.  
      \- 정의를 변경할 수 없음  
      \- 삽입, 삭제,갱신연산에 제약을 받음.  

   10. **조인(내부조인, 외부조인)에 대해서 설명해주세요**.

       가장 쉬운 설명방식은 벤다이어그램을 예로 들 수 있다고 생각합니다.
       내부조인의 경우 벤다이어그램의 A,B의 교집합
       그리고 외부조인의 경우에는 A,B의 합집합이라고 말하고 싶습니다.

       SELECT * FROM a INNER JOIN b on a.a = b.b;
       SELECT a.*, b.\* from a,b where a.a = b.b;
       ​

   11. **왼쪽 외부조인과 오른쪽 외부조인는 무엇인지 설명해주세요.**

       왼쪽 외부조인의 경우 A,B의 합집합을 나타내는데, 왼쪽열을 기준으로 공통된 부분만 찾는 것을 말합니다.
       때문에 왼쪽열에 해당하는 내용에는 null이 없을 것입니다.
       오른쪽 외부조인의 경우에도 마찬가지인데, 오른쪽 열을 기준으로 공통된 부분만 찾는 것을 말합니다.

   12. **union**  / having / group by

## #WEB

1. Session과 Cookie의 대해서 설명. 차이점과 사용용도.

2. **HTML과 XML에 대해서 설명하세요.** 

3. **프레임워크란?**

   "프레임워크는 라이브러리와 달리 애플리케이션의 틀과 구조를 결절할 뿐 아니라, 그 위에 개발된 개발자의 코드를 제어한다."

4. **세션과 쿠키의 를 설명**
   현재 우리가 인터넷에서 사용하고 있는 HTTP프로토콜은 연결지향적인 성격을 버렸기 때문에 새로운 페이지를 요청할 때마다 새로운 접속이 이루어지며 이전 페이지와 현재 페이지 간의 관계가 지속되지 않는다. 이에따라 HTTP프로토콜을 이용하게 되는데, 웹사이트에서는 웹페이지에 특정 방문자가 머무리고 있는 동안에 그 방문자의 상태를 지속시키기 위해 쿠키와 세션을 이용합니다.

   **세션이란 특정 웹페이지에 사용자가 머무르는 기간** 또는 **한 명의 사용자의 한번의 방문을 의미합니다.** 이때 Session에 관련된 데이터는 Server에 저장합니다. 웹 브라우저의 캐시에 저장되어 브라우저가 닫히거나 서버에서 삭제시 사라집니다. Cookie에 비해 보안성이 좋습니다.

   쿠키의 경우 HTTP가 상태를 저장할 수 없다라는 한계를 극복할 수 있는방법입니다. **특정 웹사이트의 방문 기록을 남겨 사용자와 웹 사이트 사이를 매개해 주는 정보입니다.** Cookie는 인터넷 사용자가 특정 웹 서버에 접속할 때, 생성되는 개인 아이디와 비빌먼호, 방문한 사이트의 정보를 담는 임시파일로써, Server아 아닌 클라이언트에 텍스트 파일로 저장되어 다음에 해당 웹 서버를 팢을 경우 웹서버에서는 그가 누구인지 어떤 정보를 주로 찾았는지등을 파악할 때 사용됩니다.

   자동로그인, 팝업에서 "오늘 더이상 이 창을 보지 않음"체크, 쇼핑몰의 장바구니
   그럼 왜 세션을 안쓰고 쿠키를 쓰는가? 모든 정보를 세션에 저장하면 Server의 메모리를 과도하게 사용되어 서버에 무리가 갑니다.



## # Java

1. **Heap Area와 Stack Area는 무엇?**
   자바에서 힙영역은 new 키워도 생성되는 객체들이 존재하는 공간입니다.
   런타임 시 동적으로 할당하여 사용하는 영역이며 GC의 대상이 되는 곳이라 할 수 있습니다.

   Stack Area의 경우에는 호출된 변수들이 나중에 사라질 수 있는 특성을 가진 변수 또는 함수등을 저장하는 공간을 말합니다. 지역변수와 static으로 선언되지 않은 메소드를 예로 말할 수 있습니다.

2. static으로 선언된 부분은 정정 메소드로서 런타임하면 가정 먼저 코드가 수행되고, 이 영역은 메모리에서 따로 (Static) Area로 저장 됩니다.

3. Java Virtual Machine

   왜 자바 가상머신을 알아야 하는가?

   **자바프로그램 실행과정**

   1. 프로그램이 실행되면 JVM은 OS로부터 이 프로그램이 필요로 하는 메모리를 할당받는다.
   2. 자바 컴파일러(javac)가 자바 소스코드(.java)를 읽어들여 자바 바이트코드(.class)로 변환시킨다.
   3. Class Loader를 통해 class파일들을 JVM으로 로딩된다.
   4. 로딩된 class파일들은 Execution engine을 통해 해석된다.
   5. 해석된 바이트코드는 Runtime Data Area에 배치되어 실질적인 수행이 이루어지게 된다.
   6. 이러한 실행과정 속에서 JVM은 필요에 따라 Thread Synchronication과 GC같은 관리작업을 수행한다.

   ​

   Execution Engine을 통해 해석된다?

   클래스를 실행시키는 역할, 클래스로더가 JVM내의 런타임 데이터 영역에 바이트 코드를 배치시키고, 이것은 실행엔진에 의해 실행된다. 실행엔진은 자바 바이트코드를 실제로 JVM내부에서 기계가 실행할 수 있는 형태로 변경합니다. 이때 두가지 방식을 사용하게 됩니다. 1) 인터프리터에 의해 명령어 단위로 읽어서 실행합니다. 2)는 JIT(Just in time) 인터프리터의 단점을 보완하기 위해 도입된 JIT컴파일러입니다. 인터프리터 방식으로 실행하다가 적절한 시점에 바이트코드전체를 컴파일하여 네이티브 코드로 변경하고, 이후에는 더 이상 인터프리팅하지 않고 네이티브 코드로 직접 실행하는 방식입니다. 

   ​

   ![http://cfile21.uf.tistory.com/image/275A103F576B85550D01E0](http://cfile21.uf.tistory.com/image/275A103F576B85550D01E0)

   #### Runtime Data Area 

   ​

   1)PC레지스터는 쓰레드가 시작될 때 생성되며 생성될 때마다 생성되는 공간으로 스레드마다 하나씩 존재합니다. Thrad가 어떤 부분을 어떤 명령을 실행해야할 지에 대한 기록을 하는 부분으로 현재 수행 중인 JVM 명령의 주소를 갖습니다.
   ​

   2) JVM스택 영역

   프로그램 실행과정에서 임시로 할당되었다가 메소드를 빠져나가면 바로 소멸되는 특성의 데이터를 저장하기 위한 영역입니다.  각종 형태의 변수나 임시데이터, 스레드나 메소드의 정보를 저장합니다. 메소드 호출시마다 각각의스택 프레임(그 메소드만을 위한 공간)이 생성됩니다. 메서드 수행이 끝나면 프레임 별로 삭제를 합니다. 메소드 안에서 사용되는 값들(Local 변수)을 저장합니다. 또 호출된 메소드의 매개변수, 지역변수, 리턴 값 및 연산시 일어나느값들을 임시로 저장합니다.

   3)Native method stack
   자바 프로그램이 컴파일되어 생성되는 바이트 코드가 아닌 실제 실행할 수 있는 기계어로 작성된 프로그램을 실행시키는 영역입니다. java가 아닌 다른 언어로 작성된 코드를 위한 공간입니다.

   4) Method Area(=static, class area)

   클래스 정보를 처음 메모리 공간에 올릴 때 **초기화되는 대상을 저장하기 위한 메모리 공간**입니다. 올라가게 되는 메소드의 바이트 코드는 프로그램의 흐름을 구성하는 바이트 코드입니다.  자바 프로그램은 main 메소드의 호출에서부터 계속된 메소드의 호출로 흐름을 이어가기 때문이다. 대부분 인스턴스의 생성도 메소드 내에서 명령하고 호출합니다. 사실상 컴파일 된 바이트코드의 대부분이 메소드 바이트코드이기 때문에 거의 모든 바이트코드가 올라간다고 봐도 상관없습니다. 이공간에는 Runtime Constant Pool이라는 별도의 관리 영역도 함께 존재합니다.

   ​

   #### 그럼 Heap 영역은 어떻게 구성되어있니?

   객체를 저장하는 가상 메모리 공간입니다. new 연산자로 생성된 객체와 배열을 저장합니다. 물론 class area영역에 올라온 클래스들만 객체로 생성할 수 있습니다. 힙은 크게 세 부분으로 나눌 수 있습니다.

   ![http://cfile29.uf.tistory.com/image/266E283B576B8E060B5A53](http://cfile29.uf.tistory.com/image/266E283B576B8E060B5A53)

   ​

   #### New/Young Generation

   - Eden : 객체들이 최초로 생성되는 공간
   - Survivor 0 / 1 : Eden에서 참조되는 객체들이 저장되는 공간

   ​          

   #### Old Generation

   - New Area에서 일정 시간 참조되고 있는, 살아남은 객체들이 저장되는 공간 Eden영역에 객체가 가득차게 되면 첫번째 GC(major gc)가 발생합니다. Eden영역에 있는 값들은 Survivor 1영역에 복사하고 이 영역을 제외한 나머지 영역의 객체를 삭제합니다.

   ​

   #### Permanent Generation

   - 생성된 객체들의 정보의 주소값이 저장된 공간입니다. class loader에 의해 load되는 Class, Method등에 대한 Meta 정보가 저장되는 영역이고 JVM에 의해 사용됩니다. Reflection을 사용하여 동적으로 클래스가 로딩되는 경우에 사용됩니다.

     ​

4. GC는 스레드인가? 네. 스레드입니다. 계속해서 뒤에서 동작하며 GC가 판단하길 더이상 사용되지 않는 객체를 소멸시킵니다.
   ​

5. 가비지 컬렉션은 어떤 원리로 소멸시킬 대상을 선정하는가?



### 가비지 컬렉션, GC(Garbage Collection) 

![http://cfile29.uf.tistory.com/image/266E283B576B8E060B5A53](http://cfile29.uf.tistory.com/image/266E283B576B8E060B5A53)

#### Minor GC

새로 생성된 대부분의 객체(Instance)는 Eden 영역에 위치합니다. Eden 영역에서 GC가 한 번 발생한 후 살아남은 객체는 Survivor영역 중 하나로 이동됩니다. 이 과정을 반복하다가 계속해서 살아남아 있는 객체는 일정시간 참조되고 있다는 뜻으로 old영역으로 이동시킵니다.

#### Major GC

old영역에 있는 모든 객체들을 검사하여 참조되지 않은 객체들을 한꺼번에 삭제한다. 시간이 오래 걸리고 실행 중 프로세스가 정지된다. 이것을 'stop-the-world'라고 하는데 Major GC가 발생하면 GC를 실행하는 스레드를 제외한 나머지스레드는 모두 작업을 멈춥니다. GC작업을 완료한 이후에야 중단했던 작업을 다시 시작합니다.



*가바지 컬렉션은 어떤 원리로 소멸시킬 대상을 선정하는가?*

알고리즘에 따라 동작방식이 매우 다양하지만 공통적인 원리가 있습니다. Gargabe Collector는 힙 내의 객체 중에서 가비지(Gargabe)를 찾아내고 찾아낸 가비지를 처리해서 힙의 메모리를 회수합니다. 참조되고 있지 않는 객체(instance)를 가비지라고 하며 객체가 가비지인지 아닌지 판단하기 위해서 **reachability**라는 개념을 사용합니다. 어떤 힙 영역에 할당된 객체가 유효한 참조가 있으면 **reachability**, 없다면 **unreachability**로 판단됩니다. 하나의 객체는 다른 객체를 참조하고, 다른 객체는 또 다른 객체를 참조할 수 있기 때문에 참조 사슬이 형성되는데, 이 참조 사슬 중 최초에 참조된 것을 Root Set이라고 칭합니다. 힙 영역에 있는 객체들은 총 4가지 경우에 대한 참조를 하게 됩니다.
![http://cfile7.uf.tistory.com/image/27134A4D576BD1F526DC8A](http://cfile7.uf.tistory.com/image/27134A4D576BD1F526DC8A)

*1= 힙 내의 다른 객체에 의한 참조*

*2= Java스택, 즉 Java 메서드 실행 시에 사용하는 지역변수와 파라미터들에 의한 참조*

*3= 네이티브 스택(JNI, Java Native interface)에 의해 생성된 객체에 대한 참조.*

*4= 메서드 영역의 정적 변수에 의한 참조*

2,3,4는 Root set이다.

즉 참조 사슬 중 최초로 참조한 것

인스턴스가 가비지 컬렉션의 대상이 되었다고 해서 바로 소멸이 되는 것은 아니다. 빈번한 가비지 컬렉션의 실행은 시스템에 부담이 될 수 있기에 성능에 영향을 미치지 않도록 가비지 컬렉션 실행 타이밍은 별도의 알고리즘을 기반으로 계산이 되며, 이 계산결과를 기반으로 가비지 컬렉션이 수행된다.



6. Collection Framework(컬렉션 프레임워크) http://asfirstalways.tistory.com/220?category=660807

   자료구조 알고리즘을 클래스로 구현해 놓은 것.

   Collection은 총 3개로 구성되어 있다. List, Set, Map으로 구성되는데,

   여기서 List와 Set의 공통부분을 다시 뽑아, Collection이라는 인터페이스를 정의하였습니다.
   **List** => 동일한 인스턴스의 중복을 허용합니다. 또한 인스턴스 저장 순서를 유지합니다.
   ex) ArrayList, LinkedList, Stack

   **Set** => 데이터의 중복저장을 허용하지 않습니다. 저장 순서를 유지하지 않습니다.
   => HashSet, TreeSet etc
   **Map** => 키와 값의 쌍으로 이루어진 테이터의 진합. 순서는 유지되지 않으며, 키는 중복을 허용하지 않고, 값은 중복을 허용합니다.

   ​

   #### ArrayList\<E> 단점

   1. 저장소의 용량을 늘리는 과정에서 많은 시간이 소요된다.
      용량을 늘린다는 것은 새로운 배열 인스턴스의 생성과 기존 데이터의 복사가 필요한 작업입니다. 즉, 기존의 ArrayList에 추가하는 것이 아닌, 확장된 크기의 ArrayList를 새로 생성하고, 새로 생성된 ArrayList의 값들을 복사해주는 과정인 것이다. (System.arraycopy() 메소드 호출 과정) 기존의 ArrayList는 가비지 컬렉션에 의해 메모리에서 제거됩니다. 용량이 부족할 경우, ArrayList는 자동적으로 기존의 크기보다 2배의크기로 증가합니다.
   2. 데이터의 삭제에 필요한 연산과정이 매우 길다..
      Worse case로 첫번째 워치에 저장되어 있는 데이터를 지우고자할 때, 모든 데이터가 한 칸씩 앞으로 당겨진다. 즉, 삭제하고자 하는 첫번째 값을 두번째 같이 덮어쓰고, 두번째 값은 세번째값에 의해 덮어쓰이게 되는 것이다. 그리고나서 마지막 값을 null로 바꿔준다.  
      이 때도 역시, 덮어쓰는 과정에서 System.arraycopy()메소드가 호출됩니다. 물론 배열의 맨 마지막의 값을 삭제하는 경우에는 빠른 성능을 보여줍니다.

   #### ArrayList\<E> 장점

   1. 인덱스 값만 알면 데이터에 바로 접근이 가능하다는 점이 있다. 즉, Index값을 통한 Random Access가 가능하다라는 것



#### 	LinkedList

​	저장소의 용량을 늘리는 과정이 간단하며(마지막 박스가 가리키는 것이 NULL이 아닌 박스로 바꿔주면 된다.) 데이터의 삭제가 매우 간단하다.(가리키는 박스의 종류만 다르게 해주면 된다.) 하지만 데이터의 참조가 다소 불편하다. 불연속적으로 위치한 각 요소들이 서로 연결된 것이라 처음부터 n번째 데이터까지 차례대로 따라가야만 원하는 값을 얻을 수 있다. 즉, 박스(Node)를 타고 이동하면서 하나씩 순차적으로 확인해줘야 한다. 이러한 문제점을 해결하기 위해 여러 기능들이 추가된 LinkedLIst가 존재한다.



7. **Reflection 이란 무엇인지 아나?**

   객체를 통해 클래스의 정보를 분석해 내는 프로그래밍 기법을 말합니다. 구체적인 클래스 타입을 알지 못해도, 컴파일된 바이트 코드를 통해 역으로 클래스의 정보를 알아내어 클래스를 사용할 수 있다는 것이다.

   ​

   리플렉션 기법을 통해서 형을 모르는 상태에서 객체의 메소드를 호출할 수 있다.  
   동적 바인딩이 되지 않던 자바에서 리플렉션이라는 프로그래밍 기법을 통해 동적 바인딩을 제공하는 것이다.
   \- 클래스 내부에서, 실행시간에, 메서드와 필드에 대한 정보를 얻을 수 있습니다.  
   \- 어떤 클래스로부터 객체를 생성할 수 있다.  
   \- 객체 필드의 유효 범위가 어떻게 선언되어 있느냐에 관계없이, 그 필드에 대한 참조를 얻어내어 값을 가져오거나 설정할 수 있다.

   ##### Why?

   Composition과 함께 사용되어 다형성을 구현하기 위해 사용된다.
   조합을 사용하여 교체할 수 있는 위임 클래스를 리플렉션을 통해 동적/정적으로 생성하고 교체하는 방식으로 사용된다. 프레임워크에서 유연성을 위해 자주 사용되는 방식이다.

   ```Java
   Class aClass = Test.class;
    
   Class myObjectClass = Class.forName(className);
   Package packageOfaClass = aClass.getPackage( );
   ```

   **왜 리플렉션이 유용한가?**

   1. 프로그램이 어떻게 동작하고 있는지에 대한 정보를 실행 시간에 관측하고 조정할 수 있도록 해준다.
   2. 메서드나 생성자, 필드를 직접 접근할 수 있기 떄문에 프로그램을 디버깅하거나 테스트할 때 유용
   3. 호출할 메서드를 미리 알고 있지 않더라도 그 이름을 사용하여 호출할수 있다. 가령, 사용자가 클래스 이름과 생성자에 전달할 인자와 메서드 이름을 주면 그 정보를 사용해 객체를 생성하고 메서드를 호출할 수 있다. 리플렉션 없이 그런절차를 구현하려면 if문을 복잡하게 엮어 사용해야한다.

   ​

8. 생성자를 private로 선언하면 계승 관점에서 어떤 영향을 주게 되나?

   생성자를 private로 선언하면 클래스 외부에서는 해당 클래스의 객체를 생성할 수 없게 됩니다. 따라서 객체를 생성하려면 해당 클래스는 객체를 생성 하려면 해당 클래스는 객체를 생성해 반환하는 static pulibc 메소드를 제공해야 합니다.

   ```java
   public class Test3 {

       static Test3 instance;

       private Test3() {
           instance = new Test3();
       }

       public static Test3 getIntance() {
           return instance;
       }
   ```


```java
 static public void staticMathod(int a, int b) {
       System.out.println("하하");
		   }
      }
```
9. **Java의 finally 블록은 try-catch-finnaly의 try블록안에 return문을 넣어도 설행되는나?**

   try안에서 아무 에러가 발생하지 않는 다는 가정에서 실행됩니다.finally 블록은 try블록이 종료되는 순간 실행됩니다. try블록에서 벗어나려고 해도 실행됩니다.
      그러나 다음과 같은 가정에서는 실행되지 않습니다.
      ​
      1)Try/catch 블록 수행 중에 가상 머신이 종료될 때  
      2)Try/Catch를 수행하고 있던 쓰레드가 죽어버릴 경우  

   ​

10.**final, finally, finalize의 차이는?**

비슷한 키워드이지만 용도가 완전 다르다.
final은 변수나, 메소드 또는 클래스가 '변경 블가능'하도록 만듭니다.  
Finally 키워드는 try/catch 블록이 종료될 때 항상 실행될 코드 블록을 정의하기 위해 사용도비니다.
finallize 메서드는 java의 쓰레기 수집기가 더이상의 참조가 존재하지 않는 객체를 메모리에서 삭제하겠다 결정하는 순간에 호출됩니다.

11. **배열과 유사하면서도 효율적으로 회전될 수 있는 CircularArray클래스를 구현하라. 이 클래스는 제네릭 타입을 사용해야 하며, 표준적인 for(Obj o:curcularArray) 문법을 사용하여 순환문을 작성할 수 있도록 구현되어야 한다.**

    이 문제는 사실 두 부분으로 구성된다. 우선 CircularArray클래스를 구현해야 한다.

   ```


    ```java
    import java.util.Iterator;

    public class CircularArray<T> implements Iterable<T> {

        @Override
        public Iterator<T> iterator() {
            return new CircularArrayIterator<>(this);
        }

        private T[] items;
        private int head = 0;

        public Test4(int size) {
            items = (T[]) new Object[size];
        }

        private int convert(int index) {
            if (index < 0) {
                index += items.length;
            }
            return (head + index) % items.length;
        }

        public void rotate(int shiftRight) {
            head = convert(shiftRight);
        }

        public T get(int i) {
            if (i < 0 || i >= items.length) {
                throw new java.lang.IndexOutOfBoundsException("...");
            }
            return items[convert(i)];
        }

        public void set(int i, T item) {
            items[convert(i)] = item;
        }

        private class CircularArrayIterator<TI> implements Iterator<TI> {
            private int _current = -1;
            private TI[] _items;

            public CircularArrayIterator(CircularArray<TI> array) {
                this._items = array.items;
            }

            @Override
            public void remove() {
                throw new UnsupportedOperationException("...");
            }

            @Override
            public boolean hasNext() {
                return _current < items.length - 1;
            }

            @Override
            public TI next() {
                _current++;
                TI item = _items[convert(_current)];
                return item;
            }
        }
    }

   ```

### 쓰레드와 락


12. java의 쓰레드를 생성하는 방법은 언게 있을까?
    1) java.lang.Runnable 인터페이스를 구현  
    2) java.lang.Thread 클래스를 계승

    ##### 1) java.lang.Runnable 인터페이스를 구현  

    ```java
    public interface Runnable {
        void run();
    }
    ```

    1. Runnale 인터페이스를 구현하는 클래스를 만든다. 이 클래스로 만든 객체는 Runnable 객체가 된다.
    2. Thread 타입의 객체를 만들 때, Runnable 객체를 생성자에 인자로 넘긴다. 이 Thread 객체는 이제 run() 메서드를 구현하는 Runnable 객체를 소유하게 된단.
    3. 이렇게 만든 Thread 객체의 start()메서드를 호출

    ##### 2) java.lang.Thread 클래스를 계승

    거의 항상 run() 오버라이드 해야하며, 하위 클래스의 생성자는 상위크래스의 생성자를 명시적으로 호출해야 한다.

    ​

    **그럼 이 둘의 차이점은 무엇인가?**
    쓰레드를 생성할 때 Runnable 인터페이스를 구현하는 쪽이 나은 경우가 두가지있습니다.
    \- Java는 다중 상속을 지원하지 않습니다. 따라서 Thread 클래스를 상속하게 되면 하위 클래스는 다른 클래스를 상속할 수가 없다. Run-able 인터페이스를 구현하는 클래스는 상속할 수가 없다.  
    \- Thread 클래스의 모든 것을 상속받는 것이 너무 부담되는 경우에는 Runnable을 구현하는 편이 나을지도 모른다.

13. **자바에서 동기화**

    1) synchronized와 lock 키워드
    2) 락(Lock)

    좀 더 세밀하게 동기화를 제어하고 싶다면, 락을 이용한다. 락(모니터라고 하기도 한다)을 공유자원에 붙이면 해당 자원에 대한접근을 동기화할 수 있다. 쓰레드가 해당 자원을 접근하려면 우선 그 자원에 붙어있는 락을 획득한다. 특정 시점에 락을 쥐고 있을 수 있는 쓰레드는 하나뿐이다. 따라서 해당 공유자원은 한 번에 한 쓰레드만이 사용할 수 있다.

     어떤 자원을 프로그램 내의 이곳저곳에서 사용하는데, 한 번에 한 쓰레드만 사용하도록 만들고자 할 때 락을 많이 이용한다.

    ```java
    import java.util.Iterator;
    import java.util.concurrent.locks.Lock;
    import java.util.concurrent.locks.ReentrantLock;

    public class Test4 {

        private Lock lock;
        private int balance = 100;

        public Test4() {
            this.lock = new ReentrantLock();
        }

        public int withdraw(int value) {
            lock.lock();
            int temp = balance;
            try {
                Thread.sleep(100);
                temp = temp - value;
                Thread.sleep(100);
                balance = temp;
            } catch (InterruptedException e) {
            }
            lock.unlock();
            return temp;
        }
        
        public int deposit(int value){
            lock.lock();
            int temp = balance;
            try {
                Thread.sleep(100);
                temp = temp + value;
                Thread.sleep(300);
                balance = temp;
            }catch (InterruptedException e){}
            lock.unlock();
            return temp;
        }
    }

    ```

    **교착상태와 교착상태 방지**

    교착상태로 어떤 스레드가 다른 쓰레드가 돌고 있는 락이 풀리기를 기다고 있는데, 두 번째 쓰레드는 자신을 기다리는 바로 그 쓰레드가 들고 있는 락이 풀리기를 기다리는 상황을 일컫는다.(여러 쓰레드가 관계되어 있더라도, 같은 상황이 발생할 수 있다.) 모든 쓰레드가 다른 쓰레드가 락을 풀기만 기다리기 떄문에, 결국 무한히 대기 상태에 빠지게 된다. 이런 쓰레드를 교착상태에 빠져다고 한다.

    교착상태가 발생하기 위해서는 다음 4가지 조건이 충족되어야 한다.

    1) 상호배재  
    : 한 번에 한 프로세스만 공유 자원을 사용할 수 있다.
    2)Hold and wait  
    : 공유자원에 대한 접근 권한을 갖고 있는 프로세스가 그 접근 권한을 양보하지 않은 상태에서 다른 자우너에 대한 접근 권한을 요구할 수 있다.
    3) 선점 불가능  
    : 강제로 다른 프로세스의 자원 접근원한을 최소할 수 없다.

    4) 대기 상태의 사이클(circular wait) \-> 두 개 이상의 프로세스가 다른 프로세스가 자원 접근 권한을 개방하기를 기다리는데, 그 관계에 사이클이 존재한다.

    ​

14. **쓰레드와 프로세스의 차이는?**

    ​

     프로세스는 실행되고 있는 프로그램 개체이다. 프로세스는 CPU시간이나 메모리 등이 시스템 자원이 할당되는 독립적인 개체이다. 각 프로세스는 별도의 주소공간에서 실행되며, 한 프로세스는 다른 프로세스의 변수나 자료구조에 접근할 수없다. 어떤 프로세스는 다른 프로세스의 자원을 접근하려면 프로세스간 통신을 사용해야 한다. 프로세스간 통신 방법으로는 파이프나 파일, 소켓등이있다.
     쓰레드는 프로세스 안에 존재하며 프로세스의 자원을 공유한다. 같은 프로세스 안에 있는 스레드들은 같은 힙공간을 사용하게 된다. 이는 다중 프로세스 환경과는 다른데, 프로세스는 다른 프로세스의 메모리에 직접 접근할 숭 ㅓㅂㅅ다. 각각의 쓰레드는 별도의 레지스터와 스택을 갖지만, 힙메모리는 서로 읽고 쓸 수 있다.

    ​

15. **문맥 교환에 소요되는 시간을 측정하려면?**
    ​

16. **유명한 철학자의 만찬 문제를 떠올려보자. 철학자들이 원형 테이블에 앉아 있는데, 젓가락 한 짝이 철학자들 사이에 놓여 있다. 음식을 먹으려면 젓가락 두짝이 전부 필요한데, 이 철학자들은 오른쪽 젓가락을 집기 전에 왼쪽 젓가락을 먼저 집는다. 모든 철학자들이 왼쪽에 있는 젓가락을 동시에 집으려고 하면, 교착상태에 빠질 수 있다. 쓰레드와 락을 사용하여, 교착상태에 빠지지 않도록 철학자들의 만찬 문제를 시뮬레이션하라.**

    ​

17. **동기화된 메서드 A와 일반 메소드B를 제공하는 클래스가 있다. 같은 프로그램 안에서 실행되는 두 개 쓰레드가 A를 동시에 실행할 수 있는가? A와 B는 동시에 실행할 수 있는가?**

18. 프리미티 타입과 레퍼런스 타입.
    프리미티브는 자바에서 기본 자룡형을 NUll을 가질수 없을 뿐만아니라 자료형의 길이가 변하지 않습니다.
    레퍼런스잡은 기본적으로 Object를 상속받으면 참조형이 됩니다.

    ​

19. 

## #알고리즘

1. n개의 정수로 구성된 정렬 상태의 배열을 임의 횟수 만큼 회전시켜 얻은 배열이 입력으로 주어진다고 하자. 이 배열에서 특정한 원소를 찾는 알고리즘을 고안하라. 회전시키 이전에 원래 배열은 오름차순으로 정렬되어 있었다고 가정한다.

   ​

2. 입력 : {15,16,19,20,25,1,3,4,5,6,7,10,14} 에서 5를 찾으면
   출력 : 5

   ```java
     public int search(int a[], int left, int right, int x) {
           int mid = (left + right) / 2;
           if (x == a[mid]) return mid;
           if (right < left) return -1;

           /**
            * 왼쪽 절반이 아니면 오른쪽 절반은 정상적으로 정렬된 상태.
            * 어느쪽이 정상 정렬상태인지를 알아낸다.
            * 그리고 그결과를 사용해서 어느쪽에서 x를 찾아야 하는지 알아낸다.
            */

           if (a[left] < a[mid]) { //왼쪽이 정상 정렬 상태
               if (x >= a[left] && x <= a[mid])
                   return search(a, left, mid - 1, x); // 왼쪽 탐색
               else
                   return search(a, mid + 1, right, x); //오른쪽 탐색
           } else if (a[mid] < a[left]) {

               if (x >= a[mid] && x <= a[right])
                   return search(a, mid + 1, right, x);
               else
                   return search(a, left, mid - 1, x);

           } else if (a[left] == a[mid])//왼쪽 절반은 전부 같은 값
           {
               if (a[mid] != a[right]) { //오른쪽이 다른 값이면, 그쪽 탐색
                   return search(a, mid + 1, right, x);
               } else { //아니면, 양쪽을 전부 탐색
                   int result = search(a, left, mid - 1, x); //왼쪽
                   if (result == -1) {
                       return search(a, mid + 1, right, x);// 오른쪽
                   } else {
                       return result;
                   }
               }
           }
           return -1;
       }
   ```

3. 줄당 하나의 문자열이 들어 있는 20GB짜리 파일이 있다고하자. 이 파일을 정렬하려면 어떻게 해야 하겠는지?

   20GB파일에서 나눈다음에 나눈파일을 정렬한다음 다시 파일에 넣는다. 외부 정렬이라고 한다.

4. 빈 문자열이 섞여 있는 정렬 상태의 배열이 주어졌을 때, 특정한 문자열의 위치를 찾는 메서드를 작성

   입력: {"at","","","ball","","","car","","","dad","",""} 배열에서 ball을 찾아라.

5. 수 하나를 이동 없이 바꾸는 함수를 작성하라.

   a = 9 , b = 4라면,

   a = 9 - 4 = 5  (a-b)
   b = a + b ( 5 + 4 )
   a = b - a ( 9 - 5 )

6. 주어진 두 수의 최댓값을 찾는 메서드를 작성하라. If-else 나 비교 연산 못씀

   ​

7. 두 수를 더하는 함수를 작성하라 . +를 비롯한 수학연산자는 사용 X

   예를 들어  759 + 674이면
   올림수를 제외한 값 323
   올림수 1110을 얻는다.

   이 둘을 더하면 값을 얻을 수이따.

   이를 비트로 해결한다.

   ```
   public static int add(int a, int b){
       if(b == 0) return a;
       int sum = a ^ b; //올림계산없이 더함
   	int carry = (a & b) << 1 // 올림수만 계산
   	return add(sum, carry)
   }
   ```

   ​



운영체제의 특징 왜 운영체제를 써야하는가?

스택으로 큐 어떻게?

하이브리드 스레드는 잘 모름.(사용자 스레드와 시스템 스레드).

사용자스레드는 사용자 영역에서 스레드를 생성합니다. 커널에서 사용자스레드 존재를 몰라서 문맥교환이 거의 일어나지 않아 오버헤드가 적다.

커널 수준 스레드 모든 스레드를 커널이 관리하는데, 하나가 정지하면 다른 스레드가 바로 교체되니까 프로세스가 정지되지않아 안정성을 확보하는 대신에 속도가 느림.

혼합형스레드가 

http://blog.naver.com/PostView.nhn?blogId=jk130694&logNo=220689655244

BCNF

BIOS / 무엇을초기화시키는가?

BIOS(basic input output system)
테스트하고 
CPU가 램, USB,입출력장치를 초기화 한다.(Power on Self test)

역정규화 왜? 

전위,중위,후위 코드 짜기.

**10만데이터의 픽셀에서 정렬을 하려면 어떻게?** 계수정렬을 활용해야 한다.

계수정렬.
 정렬한 원소의 키 값에 해당하는 버킷에 원소를 분배하였다가 버킷의 순서대로 원소를 꺼내는 방법을 반복해서 정렬하는 방법.

DNS 동작원리

재귀, 반복형 .com부터 해서 두가지 방식이 존재한다.

UDP/TCP 차이

데이터 전송을 통으로 보내면 지연시간이 걸리기 때문에 bandwise가 자체

데이터 전송을 쪼개서 보내면 지연시간을 줄이고, 쪼개부분만 데이터를 재전송하기 때문에 데이터 신뢰성이 높다.



##### `19.스케쥴러의 차이는? SJF, SRT 의 차이점은?  `

Shortest Job First / Shorest Ramining Time

SRT는 선점작업. SJF는 비선점 작업.


https://m.blog.naver.com/PostView.nhn?blogId=jjaiwook79&logNo=30069179687&proxyReferer=https%3A%2F%2Fwww.google.co.kr%2F



##### `20. 정렬된 이진트리에서 스왑된 데이터를 찾는 방법은?(이분 검색으로 찾는 것이 조건)`

바이너리서치 \- 바이너리 서치를 통해 찾다가 원본값과 인덱스를 먼저 찾고,
바이너리의 삽입과정을 통해서 틀린 부분을 찾느다.


데이터베이스의 트랜젹선이라고 하고, ACID이라고 한다.



Syncronized, volitile 차이점
변수 앞에 붙는 것이 volitile이고, Syncronized



생성자가 먼저 생성되나? 인스턴트 블록 팩토리

Final / finally / finalize

arrayList, Linked 리스트
arrayList의 단점



스레싱의 현상으 가상기억장치에서 요구 페이징에서 페이징을 교체하는 횟수가 빈번하게  
다중프로그래밍의 정도를 줄이는 줄인다.
스태틱 블록, 인스턴스 블록, 생성자.
분산처리와 병렬처리를 간단히 설명.

Grade

쿠키와 세션의 차이.

전화번호부가 7자리가 있다. 그게 10만개가 수록되어 있는데, 이걸 오름차순으로 정렬하려면 어떻게 해야곘는가? 버킷정렬