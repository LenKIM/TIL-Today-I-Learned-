1. **자기소개**
   단 몃줄의 코드가 세상을 변화시킬 수 있다라고 믿는 집념의 사나이 김정규입니다. 최근에 진행했던 프로젝트들 중 단순히 구현에 그치지않고 더 뛰어난 성능을 만들내기 위해 고진감래하며 노력했었습니다. 그 노력의 결과로 완성도 높은 프로젝트를 창출해내 K-스타트업의 재창업지원패키지을 받을 수있는 성과를 이뤘습니다. 

   또다른 저만의 경쟁력은 외향적인 성향을 활용한 소통입니다. 학부생 시절, 스타트업에서 인턴으로 근무하며 직접 발로 뛰며 고객과 소통하고 소통을 통해 받은 피드백을 앱에 적용시켜 고객의 충성도를 높였던 경험이 있었습니다. 

   이러한 경험을 바탕으로 끈기와 소통이 저만의 경쟁력이라고 판단했습니다. 그러므로 제가 가진 경쟁력을 활용해 웍스 모바일에서 핵심적인 인재가 될 것임을 자부합니다.

   감사합니다.

2. **지원동기** / **윅스모바일에서 하고싶은게 있다면 어떤거?**

   일단 저는 메일 개발 또는 오피스 문서를 작성하는 부분에서 개발을 하고 싶습니다. 왜냐하면 꼭 해보고 싶은 개발이 있기 때문입니다. 군대에서 행정병을 담당하며 공문서란 공문서는 매일 작성했습니다. 그러면서 생각했던 것이 왜 공문서와 같은 전자결제는 왜 메일로 할 수 없을까였습니다. 물론 대외비도 있을테고 공유할 수 없는 문서들이 있을 거라 생각합니다. 그렇지만 공문서를 쓰는 가장 큰 이유는 의사결정에 대한 근거와 기록을 남기기 위한 것이라고 알고 있습니다. 그래서 생각해본 것이 메일과 오피스에 블록체인을 적용하여 공공장부 시스템을 활용하면 오피스 문서에도 메일에도 신뢰성이 더욱 높아져 앞으로 그 실효성을 입증할 수 있을거라 생각합니다.




1. 주택담보대출 프로젝트는 몇명이서 진행했습니까?

> 꼬리질문 : 해당 프로젝트 하면서 생겼던 문제점이나 해결하기 위해 어떤 노력을 얼만큼 했는지?

>그정도면 집념의 사나이라고 본인 스스로 평가할만큼 집념있다고 생각하세요? 그보다 더 집념있게 해본일은 없으신가요?


2. 웹 크롤링 프로젝트 잘했다는 평가를 받았다고 하셨는데 구체적으로 무엇을 잘했다고 생각해서 그런 평가를 들었다고 생각하세요?

>그렇다면 부족한 부분에 대해서는 평가를 안해주던가요? 다들 잘했다고만 얘기하던가요?

3. 프로그래밍 스킬이 모두 초급 아니면 중급이라고 하셨는데 그중에서 가장 자신있는게 뭔가요?

>해당 스킬을 고급으로 올리기 위해서 구체적으로 현재 하고있는 노력과 앞으로의 계획이 뭔가요?

# 퍼센트

주택담보대출, 전세자금대출을 희망하는 대출고객과 대출상담사를 연결해주는 서비스입니다.
대출 고객은 간단한 입력을 통해 본인이 원하는 대출 견적을 의뢰할 수 있고 대출 상담사는 보다 손쉽게 대출 고객을 모집할 수 있습니다.

은행별 대출금리와 대출상담사 정보를 제공하여 최저금리로 대출을 받을 수 있게 안내해드리고, 정보 접근성의 향상을 통해 이자 부담을 경감시켜드립니다.



개발하면서 힘들었던점은 ?
크게 3가지가 있었습니다.
첫번째는 UX적인 문제로, 대출상담에 필요한 인적정보가 너무 많아 사용자 입장에서 한페이지내에 너무 많은 입력을 요구하면 부담을 느끼고 화면을 닫아버릴거라고 예상했어요. 그래서 이 문제는 챗봇형식으로 구현해서 해결했습니다.

두번째는 크롤링이였습니다. 얼만큼의 데이터를 저장해야되는지 모르고, 무엇보다 자동화된 크롤링을 개발했지만 한번 시작하면 8시간이 걸려서 중간에 멈쳐버리면 처음부터 다시해야됬습니다.

세번째는 앱이 2개였는데, 그 중에 하나를 1주일이라는 빠른 시일내에 개발을 완성해야했습니다. 때문에 이전에 개발 경험을 살려 이를 불러와 커스텀마이증을 수행해 해결했습니다. 

파이어베이스를 활용했다는데, 파이어베이스는? 

거기서 싸용된 기능은 어떤거? 푸쉬





3. **안드로이드 생명 주기**
   onCreate()
   onStart()
   onResume()
   onPause()
   onStop()
   onDestroy()

   \* onCreate : 초기화 처리, 뷰 생성 등

   \* onStart : 통신이나 센서 처리 시작

   \* onRestart : 보통 아무 작업 안 함.

   \* onResume : 필요한 애니메이션 실행 등의 화면 갱신 처리

   \* onPause : 애니메이션 등 화면 갱신 처리 정지 또는 일시 정지할 때 필요 없는 리소스 해체하거나 필요한 데이터 영속화

   \* onStop : 통신이나 센서 처리 정지

   \* onDestroy : 필요 없는 리소스 해제, 액티비티 참조 정리

   ​

   [http://programmingfbf7290.tistory.com/entry/안드로이드-액티비티Activity-생명주기-총정리](http://programmingfbf7290.tistory.com/entry/안드로이드-액티비티Activity-생명주기-총정리)
   ​

   다른 액티비티가 일부만 가리면 onPause()가 호출되고 전체를 가리면 onStop()이 호출된다. 디바이스의 메모리가 부족해 우선순위가 낮은 앱을 종료해야 한다면 앱은 onPause에서도 종료될 수 있다. 앱이 종료된다고 무조건 onStop()이나 onDestroy()가 호출된다는 보장이 없다. 그래서 주로 onPause() 메서드를 주로 오버라이드하지만 리소스를 안전하게 제거하기 위한 안전장치로 onStop()과 onDestroy()를 호출하는 것도 괜찮다. onDestroy() 메서드는 finish()를 호출할 때 말고 시스템에 의해서 제거될 때도 호출된다. 앱에서 하나의 태스크를 사용하면 메모리가 많아질 때 OutOfMemoryError가 발생하지만 여러 태스크를 사용한다면 가용 메모리의 3/4가 넘을 때 백그라운드 태스크의 액티비티를 제거한다. 시스템에 의해서 태스크의 액티비티 목록이 제거될 수 있으므로 액티비티 개수나 액티비티 목록을 메모리에 유지하는 방식은 사용 하지 않는 게 좋다. 주의해야할 생명주기 호출 시점이 있다. 먼저 onCreate()에서 finish 메서드가 호출되면 바로 onDestroy가 호출된다. 두 번째로 onActivityResult() 메서드는 onResume()보다 먼저 실행된다. 따라서 순서에 유의해 UI를 업데이트 해야 한다.

   ​

   만약 홈 버튼을 누르면 onPause()에서 onResume()으로
   화면을 옆으로 하면 onPause() onStop() onDestroy() onCreate() onStart() onResume()이 된다. 

   두개의 액티비티에서 1번 액티비티가 띄어져있는 상황에서 2번 액티비트를 띄을 경우 
   1번 액티비티는 onPause()로 진입하고, 2번 액티비가onCreate(), onStart(), onResume 그리고 난 뒤 1번액티비티가 onStop()으로 변합니다.

   여기서 2번 액티비티에서 백키를 누르면 2번에 대한 onPause()로 변하고, 1번 액티비티의 onRestart() onStart() onResume() 그리고 2번 액티비에 대해서는 onStop(), onDestroy()가 된다.

4. **화면이 전환되더라도 데이터가 변하지 않도록 하기 위해서는 어떻게 해야 될까?**

   첫번째로, onConfigurationChanged()를 이용합니다.
   함수를 오버라이드해서 화면이 전환됬을때 특정한 기능을 추가하거나 아니면 디폴트로 놓습니다.
   두번째로는 screenOrientation 속성을 이용합니다.
   이는 회전 이벤트를 아에 막는 방법입니다.



5. RecyclerView / 어탭터 패턴에 대해 말하시오.
   ​

6. 동기와 비동기 방식의 차이를 설명하세요.
   ​

7. postman을 통해 크롤링 방식 이해
   ​

8. 저전력 블루투스의 동작방식에 대한 이해
   ​

9. 네이버 개인화 서비스를 이용해야 하는 명분
   ​

10. 글로벌하게 사용될 수 있는 기술력의 근거는?
    ​

11. 웹 페이지의 언어가 일원화 되어 있지 않다.
    ​

12. 영문판 클라우드 안드로이드 앱에서 글자의 띄어쓰기 등 마이너이슈가 존재한다. 이는 완성도의 아쉬움을 떨어 뜨린다.
    ​

13. 메일에 대한 프로토콜 이해 ( POP3 / ICMP 프로토콜 / SMTP / MIME - 비정형 데이터를 아스키코드로 변환시켜주는 것)

14. **크롤링했던 데이터가 갑자기 변경되면 어떻게 다시 구현할건지 여쭤보심**==조금 생각하다가, DB 칼럼에 최신 갱신시간을 추가하고 메모이제이션 될때 같이 캐싱하다가 유저가 요청한 시간과 비교하여 일정 시간이 지나면 다시 갱신할거라고 말함.

15. 다른 방법도 또 있는지?

    크롤링 하는 프로세스를 주기적으로 돌려서 만약 데이터가 변경된것을 알게된다면 이벤트 방식으로 서비스하고 있는 서버에 알려줄거라고 말함. 뭔가 다른 방법을 듣길 원하는지 다른거 또 있냐고 물어보셔서 고민하고 있었는데 옆 면접관이 너무 들어간거 같다고 끊어줌.이번 면접 끝나고 고민해서 다음번에 말씀드리겠다고 답함

    ​

16. **CORS (크로스 도메인) 에 대해 알고있는지? 어떻게 해결했는지?**
    Cross-Origin Resource Sharing

    원래 보안상의 이유로, 브러우저들은 자신의 도메인이 아닌 다른 도메인에 요청을 보내는 것을 제안했습니다. 그러나 개발자들이 웹 애플리케이션을 개선시키기 위해, 브라우저 벤더사에게 cross-domain 요청을 할 수 있도록 요청해 지금은 가능한 것으로 알 고 있습니다.
    ​

    CORS는 웹 서버에게 보안 cross-domain 데이터 전송을 활성화하는 cross-domain 접근 제어권을 부여합니다. 모던 브라우저들은 cross-origin HTTP 요청의 위험성을 완화시키기 위해 ([XMLHttpRequest](https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest)와 같은) **API 컨테이너** 내에서 CORS를 사용합니다.

    동작 방식은 헤더에 origin이라는 헤더를 추가하여 어떤 도메인에서 보냈는지 같이 보내 허용된 웹 페이지에서 요청한가를 확인해서 동작되도록 구성되어 있다고 알고 있습니다.

    ​

크로스 도메인 개념과 발생하는 원인에 대해 설명함. 해결방법은 http header 부분을 변환하는 걸로 알고있는데 정확한 내용은 몰라서 모듈을 사용해 해결했다고 함.

17. 왜 Node.js를 활용했는가? 

Node.js이고 Node.js 특징 말하면서 비동기 I/O 를 강조함. 바로 이어서 비동기와 동기의 차이에 대해 물어봐서 OS 관련된 내용으로 설명함. 그 후 Node.js 사용하면서 발생할 수 있는 문제점(콜 스택이 하나이기 때문에 CPU 바운드 작업이 길면 콜백이 실행안됨)에 대해 물어보면서 해결방안 물어봄.
CPU 바운드 작업이 긴게 있다면 내부적으로 분할해서 콜백으로 실행해서 테스트 큐에 작업들이 오랜시간 대기하지 않고 바로 실행될 수 있도록 하겠다 했더니 약간 감탄하심.
이후에 추가적으로 Node.js는 싱글 스레드인걸 강조하면서 오픈소스에 참여해본적은 없지만 napa.js라는 멀티스레드로 자바스크립트를 실행할 수 있는 런타임 환경에 관심을 가지고 보고 있음을 어필함.

18.  그럼 멀티스레드에서 동기화 문제는 어떻게 해결할 것인지?

뮤텍스, 세마포어, 모니터에 대해 이야기하면서 자바의 싱크로나이즈 키워드가 모니터를 구현한 것임을 말함.

19. 애자일 방법 / 폭포수 모델이란? 
    ​

20. 웹 크롤링이란 무엇인지?  
    웹 페이지를 그대로 가져와서 거기서 데이터를 추출해 내는 행위를 말합니다. 크롤링하는 소프트웨어는 크롤러라고 부릅니다.
    20 -1 DOM 구조?

    **문서 객체 모델(The Document Object Model)이라 불리며, HTML, XML 문서의 프로그래밍 Interface입니다. DOM은 문서의 구조화된 표현(Structured represention)을 제공하여 프로그래밍언어가 DOM구조에 접근할 수 있는 방법을 제공하여 그들이 문서 구조, 스타일, 내용 등을 변경할 수 있게 돕습니다.**

21. 프로토콜이란 무엇인지?

    클라이언트와 서버간의 약속된 규칙으로 이루어진 메세지입니다.
    ​

22. **HTTP와 TCP 차이점**

    일단 HTTP는 OSI 7에서 응용계층이로 TCP의 경우에는 전송계층에 속합니다. 즉, HTTP는 TCP위에서 동작합니다. HTTP는 TCP위에서 어떤 형태로 웹에서 작동할지를 정해놓는 프로토콜일 뿐입니다.

    ​

23. **REST API란 무엇인지?**

    REST API란 소프트웨어의 아키텍처 중 하나로 좀 더 정확한 표현을 말하자면, REST는 Resource Oriented Architecture입니다. API 설계의 중심에  자원(Resource)가 있고 HTTP Method를 통해 자원을 처리하도록 설계하는 것을 말합니다.

    REST API에는 6가지 원칙이 있습니다.
    ​
    1.첫번째는 URI로 지정한 리소스에 대한 조작을 통일되고 한정적인 인터페이스로 수행하는 것을 Uniform interface라 하고

    2.작업을 위한 상태정보를 따로 저장하고 관리하지 않는다는 의미에서 Stateless 

    3.그리고 기존 웹표준을 그대로 사용하기 때문에 Cacheable하다고 할 수 습니다. 

    4.또한 REST API 메세지만 보고도 이를 쉽게 이해 할 수 있는 자체 표현 구조로 되어있다는 특징과

    5.REST는 Client와 Server로 역할이 확실히 구분 되어있다는 점과

    6.REST서버는 다중 계층으로 구성하여 로드벨렁싱, 암호화 계층을 추구하여 구조상의 유연성을 둘 수 있습니다

    ​

24. HTTP와 REST API 비교 설명

    ​

    ​

    ​

25. GET POST 비교 설명

    HTTP의 Method들로써 그 사용용도에 따라 달라집니다.
    GET의 경우에는 SQL의 Select과 유사한 성향을 가지고 있습니다. URL에 데이터를 담아 서버에 요청하면 그게 따른 결과를 리스폰스 해줍니다. 반면에 POST의 경우에는 GET방식보다는 보안적이며, 바디 부분에 원하고자하는 내용을 담아 서버에요청합니다. POST의 경우에는 SQL에 PUT과 같이 데이터를 업데이트하거나, 삭제등을 수행할 때 주로 사용됩니다.

    ​

26. 쓰레드란 무엇인지?
    프로세스의 작업단위를 말합니다.
    즉, 하나의 프로세스안에는 여러개의 쓰레드가 존재할 수 있습니다.
    또한 스레드는 자체 스택과 PC레스터를 개별로 보유 하고 있습니다. 있으면 하나의 스레드안에 존재하는 스레드들 끼리는 운영체제의 자원을 공유할 수 있습니다.

    **왜 스택이 필요할까요?**
    스택은 함수 호출시 전달되는 인자, 되돌아갈 주소값 및 함수 내에서 선언하는 변수 등을 저장하기 위해 사용되는 메모리 공간으로, 독립적인 함수 호출을 가능하게 해줍니다.
    **왜 PC 레지스터가 필요할까요?**

    쓰레드는 CPU를 할당받았다가 스켸줄러에 의해 다시 선점 당합니다. 이때 되돌아갈 주소값을 저장해 두어야할 필요가 있기 때문에 PC레지스터가 필요합니다.

27. 쓰레드 사용시 유의점

    ​

    ​

28. 쓰레드와 async await 방식의 차이점

    비동기 프로그래밍이란?

    쓰레드는 하나의 프로세스작업을 나누어서 실행해주는 것을 말합니다. 즉 하나의 작업을 쪼개서 쪼개서 병렬 처리하는 것이라고 말할 수 있습니다. 반면에 비동기 프로그래밍이란 하나의 요청 처리가 완료되기 전에 제어권을 다음 요청으로 넘기는 것을 말합니다. 즉, IO처리인 경우 Blocking 되지 않으며 다음 요청을 처리할 수 있는 것을 말합니다.

    ​

29. 휴대용미세먼지 측정기에서 완성한 프로토콜이 무엇인지?

30. 콜백지옥이란?

    Node.js는 기본적으로 비동기적인 I/O이다. 때문에 개발자는 비동기적인 프로그래밍에서 순차처리가 필요할 경우 콜백을 만들어 처리해야 한다. 이러한 콜백을 계속해서 만들다보면 들여쓰기가 많아지면서 가독성이 급격히 떨어진다. 이를 콜백지옥이라고 부른다.

    노드에서는 이러한 콜백지옥을 없애기 위해 Promise 또는 Async/Await와 같은 컴포넌트를 활용해 콜백지옥을 최대한 줄이는 프로그래밍을 지향하고 있습니다.

    ​

31. RDBMS가 무엇인지?

    관계형 데이터베이스를 관리하기 위한 소프트웨어입니다.
    테이블 기반의 DBMS로 데이터를 조건에 따라서 테이블의 행과 열로 나누어 관리하는 시스템입니다.

    ​

32. functional programming의 장단점?

    함수형프로그래밍의 가장 큰 장점은 부수효과가 없다는 것에 있습니다. 이는 곳 하나의 함수를 만들어놓으면 그에 따른 사이드이펙트가 발생이 없다는 것입니다.
    그러나 단점으로는 개발자가 컨트롤해야되는 것을 하드웨어가 컨트롤하게 하기 때문에 그만큼의 하드웨어 비용이 들어갑니다. 

    ​

33. functional programming과 oop 비교 설명
    ​

    만약 연말 매출액을 계산하는 프로그램을 개발합니다.
    1월부터 12월까지의 매출액을 계산해야될 것입니다.
    이때 자바와 같은 OOP는 1월부터 12까지의 값을 PUSH해서 값이 더합니다. 다시 말해 만약 2월의 매출액이 변경되었다면 1월 12월까지 모두다 푸쉬해서 값을 계산할 것입니다.
    그러나 FP의 경우는 2월의 매출액이 변경되었다면 2월 매출만 PULL하여 계산일 시도합니다. 이것이 가장 큰 차이라고 생각합니다.

    ​

34. 크롤링으로 서비스를 만들경우 발생할 수 있는 문제점과 해결방안
    ​

35. JNI란 무엇이고 활용해본 경험이 있는가?

    **Java와 자바 이외의 언어들 간에 서로 호출하고 호출될 수 있도록 인터페이스를 제공하는 것**

    **NDK는? 네이티브 코드언어를 사용할 수 있게 해주는 툴셋이다. C/C++언어를 사용할 필요가 있다면 NDK를 설치해야 한다.**

36. 프로젝트에서 자료구조 활용해본 경험이 있는가?

    ​

    ​

    ​

37. 덱스란 무엇인가?
    ​

    Android apk파일에는 DEX (Dalvik Executable)파일 형식의 실행 가능 바이트코드 파일이 포함되어, 단일 DEX파일 내에서 참조될 수 있는 메서드의 총 개수는 65,536으로 제한하여 여기에는 Android 프레임웤 메서드, 라이브러리 메서드, 코드에 있는 메서드를 포함합니다. 컴공 측면에서 64 * 1024와 동일하며, 이 제한을 64K 참조 제한이라고 부릅니다.

    21을 기준으로 이하일 경우와 이상의 경우로 나눠 호출을 달리한다.

38. 멀티덱스 들어봤는가?

    ​

39. DNS round robin 방식
    ​
    동일 기능을 가진 인터넷 서버들 사이의 부하를 조정하기 위한 기법. DNS요청에 대해 순환식으로 IP주소에 따라 대응하는 방법이다. 예를 들면, 동일한 서버가 10개 있을 때 첫 요청은 첫 번째 서버IP주소로, 두 번째 요청은 두 번째 서버 IP주소로 계속해서 순환 대응한다. 그러다 열한 번째 요청은 다시 첫번쨰 IP주소로, 열두 번쨰 요청은 두 번쨰 IP주소로 계속 순환 대응한다.

    ​

    그러나 이러한 방식의 문제점은 오토스케일과 같은 로드벨렁싱 역할을 하지만 확실히 차이가 있다.

    첫번째로, 서버의 수 만큼 공인 IP주소가 필요하다. 즉, 부하 분산을 위해 서버의 대수를 늘리기 위해서는 그 만큼의 공인 IP가 필요하다.

    두번째로, 균등하게 분산되지 않는다. 모바일 사이트 등에서 문제가 될 수 있는데, 스마트폰의 접속은 캐리어 게이트웨이라고 하는 프록시 서버에서는 이름 변환 결과가 일정 시간 동안 캐싱되므로 같은 프록시 서버를 경유하는 접속은 항상 같은 서버로 접속된다. 또한 PC용 웹 브라우저도 DNS 질의 경과를 캐싱하기 때문에 균등하게 부하분산 되지 않는다. DNS 레코드의 TTL값을 짧게 설정함으로써 어느 정도 해소가 되지만, TTL에 따라 캐시를 해제하는 것은 아니므로 반드시 주의가 필요하다.

    세번째로, 서버가 다운되도 확인이 불가하다. 즉 DNS서버는 웹 서버의 부하나 접속 수등의 상황에 따라 질의 결과를 제어할 수 없다. 웹 서버의 부하가 높파어 응답이 느려지거나 접속수가 꽉 차서 접속을 처리할 수 없는 상황 인지를 전혀 감지할 수 없기 때문에 어떤 원인으로 다운되더라도 이를 검출하지 못하고 유저들에게 제공한다.

    ​

    https://github.com/JaeYeopHan/Interview_Question_for_Beginner/tree/master/Network
    ​

40. 리눅스에서 그룹 그룹핑



41. 멀티스레딩 해본 경험
    ​
    : 프로그래스바의 대한 UI업데이트 할 때.

    IPC (Interprocess communication)  
    시그널, 파이프, 메시지 큐, 세마포어, 공유 메모리
    AIDL  (Android Interface Definition Language)
    안드로이드 인터페이스 정의 언어를 통해 프로세스 통신을 추상화한다.

    ​

    **멀티스레딩경험. 소프트웨어를 통해 펌웨어 업데이트를 실행하기 위해 멀티스레딩을 해본 경험이 있었습니다.**

    ​

42. 왜 UDP 썼는가?

    첫번째로 해당 프로젝트는 교수님의 컴퓨터에만 다중의 컴퓨터 정보가 보이고 나머지컴퓨터에서는 동작만 합니다.
    즉 1대 다 통신이여야하는데, TCP의 경우에는 이를 충족시켜주지 못합니다.
    두번째로는 UDP를 쓴 이유는 어뷰징을 방지하고 싶었습니다. UDP는 TCP에 비해 연결 과정이 단순한 만큼 속도적인 성능이 높아 학생이 혹시나 빠르게 보고 닫으면 못볼거같아 UDP로 했습니다.

43. 안드로이드에서 SQLite 관련 질문이 들어올 것으로 예상됨.

    어떻게 파싱 했는가?
    일단 성경 오픈 XML을 다운받아 이를 안드로이드 리소스에 xml에 저장했습니다. 그리고 자바 코드로 InputStram을 실행시켜 해당 xml을 읽어옵니다. 다음 Dom 파서를 xml을 이름을 입력해 SQLite로 모든 문자열을 저장했습니다.  
    그리고 안드로이드에서는 SQLite에 저장된 문자열들만 보고 사용자가 요청하는 부분을 보여주면 됩니다.

    ​

44. HTTP Method 종류

    1. get / post / put/ delete/ header / option/ trace/ Patch

45. 이벤트 루프의 동작 원리

    노드.js는 비동기 io를 지원하기 위해 libuv라이브러리를 활용하는데, 이 리보브가 이벤트 루프를 지원합니다.

    http://meetup.toast.com/posts/89

    이벤트 루프는 호출 스택, 백그라운드, 테스크 큐로 구성되어있습니다. 비동기 호출을 할 경우 메소드들은 처음에 호출스택에 저장됩니다. 그 뒤 백그라운드로 전송되어 작업을 처리하고 처리된 작업이 테스크 큐로 이동합니다. 여기서 이벤트 루프가 호출 스택이 비어질때까지 기다렸다가 테스크 큐를 호출합니다. 이런 방식으로 이벤트 루프가 동작됩니다.

46. **Q) XML 에 대해 설명해보아라. (JSON과 비교)**

    A) ==XML과 JSON은 모두 구조화된 문서를 전송가능하게 만든 **텍스트 포멧 형식**을 말한다.==

    > - XML의 장점
    >   - 작성하기가 간편하다(tag 구조)
    >   - XML 사람이 읽기가 쉽다.
    > - XML의 단점
    >   - 문서의 양이 필요이상으로 많아진다. (실 데이터가 아닌 tag 글자)
    >   - 배열형식이나 반복구조의 경우 불필요한 데이터가 계속해서 나타난다.
    >     ex) 
    >     \<string-array name="planets_array">
    >        \<item>Mercury\</item>
    >        \<item>Venus\</item>
    >        \<item>Earth\</item>
    >        \<item>Mars\</item>
    >     \</string-array>
    > - JSON의 장점
    >   - 내용이 함축적이므로 최소한의 정보만을 가지고 있다. (XML에 비해 용량이 적고 속도는 빠르다.)
    >   - 객체구조 {} 와 배열구조 [] 의 적절한 만남으로 아주 효율적인 데이터 구성이 가능하다.
    > - JSON의 단점
    >   - 내용이 함축적이다 보니 내용의 의미파악이 힘들 수 있다.

47. Q) Node에서 FTP는 어떻게 사용했는지? FTP에 대해 설명해보아라.**

    A) jsftp 모듈을 사용했다.
    ==FTP(파일 전송 프로토콜)는 TCP/IP 프로토콜 테이블의 응용 계층에 속하며, FTP 서버를 실행하는 원격 시스템 간에 파일을 전송하는 표준 프로토콜이다.== FTP 클라이언트는 파일 및 디렉토리 업로드, 파일 및 디렉토리 다운로드, 그리고 원격 및 로컬 파일 시스템의 디렉토리 탐색을 허용한다.
    ==FTP에는 2가지 종류의 연결이 있다.== **'명령(신호 제어용) 연결'** 은 제어 포트인 서버의 21번 포트로 사용자 인증, 명령을 위한 연결이 만들어지고, 여기를 통해 클라이언트에서 지시하는 명령어가 전달된다. **''데이터 전송용 연결'** 은 실제의 파일 전송이 필요할 때 만들어진다. 서버는 데이터 포트인 20번 포트에서부터 클라이언트가 지정한 지점으로의 데이터 연결을 만든다. 클라이언트는 주로 1023보다 큰 포트를 지정한다.

    > Passive 모드 vs Active 모드
    >
    > FTP 서비스는 기본적으로 능동(active) 모드와 수동(passive) 모드의 두 가지 데이터 접속 방법이 있다. active 모드와 passive 모드의 기본적인 차이는 포트 번호에 있다. 두 개의 모드는 처음에 데이터 제어용 포트는 21번을 사용하지만 그 뒤에 데이터 전송용 포트를 20번을 사용하지 않는다.
    >
    > Active 모드는 서버와 클라이언트 간 데이터 전송용 포트 20번, 신호 제어용 포트 21번을 사용한다.
    > Passive 모드는 서버와 클라이언트 간 데이터 전송용 포트는 서버에서 지정해주고, 신호 제어용 포트는 동일하게 21번 포트를 사용한다. Passive 모드는 데이터 전송용 포트를 20번이 아닌 다른 임의의 번호로 할당하여 사용하기 때문에 보안 장비의 포트 차단 설정을 확인해야 한다.

48. **Q) FTP와 SFTP의 차이점에 대해 설명해보아라.**

A) ==FTP는 암호화를 하지 않기 때문에 사용자 인증정보가 노출되기 때문에 보안에 취약하다.==
텔넷의 결함을 보완하기 위해 보안 셸, SSH가 등장했듯이, FTP 대신 SFTP를 사용해서 보안을 유지할 수 있다.
SFTP는 보통 22번 포트를 사용한다. 자료 전송 과정 전후로 사용자 인증을 SSH가 처리하고 자료를 암호화해서 전송하기 때문에 FTP보다 안전하다고 할 수 있다. SFTP는 보안 전송이라는 특성 상 FTP보다 파일 전송 속도가 느린편이다. 

> **SSH**
> SSH 또는 Secure Shell은 네트워크 상의 다른 컴퓨터에 로그인하거나 원격 시스템에서 명령을 실행하고 다른 시스템으로 파일을 복사할 수 있도록 해 주는 응용 프로그램 또는 그 프로토콜을 가리킨다. 기존의 텔넷을 대체하기 위해 설계되었으며, 강력한 인증 방법 및 안전하지 못한 네트워크에서 안전하게 통신을 할 수 있는 기능을 제공한다. SSH는 암호화 기법을 사용하기 때문에, 통신이 노출된다 하더라도 이해할 수 없는 암호화된 문자로 보인다.
>
> **TLS**
> SSL(Secure Socket Layer)은 넷스케이프사에서 전자상거래 등의 보안을 위해 개발하였고 이후 TLS(Transport Layer Security)라는 이름으로 표준화되었다. SSL은 특히 네트워크 레이어의 암호화 방식이기 때문에 HTTP 뿐만 아니라 NNTP, FTP등에도 사용할 수 있는 장점이 있다. 기본적으로 Authentication(인증), Encryption(암호화), Integrity(무결성)을 보장한다.



49. **Q) SSL에 대해 설명해보아라.**

A) ==SSL(Secure Socket Layer)은 스니핑과 같은 악의적인 행위를 방지하기위해 만들어졌다. SSL은 네트워크 내에서 메시지 전송 안전을 관리하기 위해 만들어진 프로그램 계층이다. (정확히는 6(표현)계층) SSL은 디지털 증명의 사용에도 포함되는 RSA의 공개/개인키 암호화 시스템을 사용한다.==
(HTTPS와 SSL를 같은 의미로 이해하고 있는 경우가 많다. 이것은 맞기도 틀리기도 하다. 그것은 마치 인터넷과 웹을 같은 의미로 이해하는 것과 같다. 결론적으로 말하면 웹이 인터넷 위에서 돌아가는 서비스 중의 하나인 것처럼 HTTPS도 SSL 프로토콜 위에서 돌아가는 프로토콜이다.)

**SSL 디지털 인증서**
==SSL 인증서는 클라이언트와 서버간의 통신을 제3자가 보증해주는 전자화된 문서다. 클라이언트가 서버에 접속한 직후에 서버는 클라이언트에게 이 인증서 정보를 전달한다.== 클라이언트는 이 인증서 정보가 신뢰할 수 있는 것인지를 검증 한 후에 다음 절차를 수행하게 된다.
SSL 인증서에는 1) 서비스의 정보 (인증서를 발급한 기관), 2) 서버 측 공개키 가 포함되어 있다.



50. **대칭키**

==암호를 만드는 행위인 **암호화**를 할 때 사용하는 일종의 비밀번호를 키(key)라고 한다. 이 키에 따라서 암호화된 결과가 달라지기 때문에 키를 모르면 암호를 푸는 행위인 **복호화**를 할 수 없다. <u>대칭키는 동일한 키로 암호화와 복호화를 같이 할 수 있는 방식의 암호화 기법</u>을 의미한다.==
대칭키 방식은 단점이 있다. 암호를 주고 받는 사람들 사이에 대칭키를 전달하는 것이 어렵다는 점이다. 대칭키가 유출되면 키를 획득한 공격자는 암호의 내용을 복호화 할 수 있기 때문에 암호가 무용지물이 되기 때문이다. 이런 배경에서 나온 암호화 방식이 공개키방식이다.

**공개키**
==공개키 방식은 두개의 키를 갖게 되는데 A키로 암호화를 하면 B키로 복호화 할 수 있고, B키로 암호화하면 A키로 복호화 할 수 있는 방식이다. 이 방식에 착안해서 두개의 키 중 하나를 비공개키(private key, 개인키, 비밀키라고도 부른다)로하고, 나머지를 공개키(public key)로 지정한다. 비공개키는 자신만이 가지고 있고, 공개키를 타인에게 제공한다.== 공개키를 제공 받은 타인은 공개키를 이용해서 정보를 암호화한다. 암호화한 정보를 비공개키를 가지고 있는 사람에게 전송한다. 비공개키의 소유자는 이 키를 이용해서 암호화된 정보를 복호화 한다. 이 과정에서 공개키가 유출된다고해도 비공개키를 모르면 정보를 복호화 할 수 없기 때문에 안전하다. 공개키로는 암호화는 할 수 있지만 복호화는 할 수 없기 때문이다.

SSL은 공개키와 대칭키의 장점을 혼합한 방법을 사용한다. (클라이언트에서 생성한 대칭키를 서버의 공개키를 이용해 암호화해 보낸다. 그 후 데이터를 주고받는(세션) 과정에서는 대칭키를 사용한다.)

**SSL의 동작 방법**

> SSL 역시 TCP 프로토콜 기반이라서 Handshake 과정을 거친다.
>
> 1단계
> Client는 Server에게 hello 메시지를 보냅니다.
> Server는 Client에게 Hello 메시지로 응답을 보냅니다.
> 서로간의 통신을 준비하는 단계로 보면 됩니다.
>
> 2단계
> Server는 Client에게 인증서, 사용할 서버키를 교환하며, 인증요청을 보냅니다.
>
> 3단계
> Client는 Server에게 인증서, 사용할 클라이언트키를 교환하며, 인증서 확인요청을 합니다.
>
> 4단계
> Server, Client 모두 Change Cipher Spec Protocol을 교환하며 위 단계에서 교환한 
> 서버/클라이언트 키, 인증서 등을 토대로 이후의 통신을 지속하겠다는 메시지를 교환하며
> 서로의 인증을 마칩니다.

**SSL의 사용 예**
기본적인 통신외에 무언가 덧붙여진다는 것은 정보를 보호하는데 도움이 될지언정 속도에는 도움이 되지 않는것이 사실이다. 보안을 강화하면 편의성이 떨어진다는 것은 어쩔 수 없는 것이다. 암호화를 하기 위해 크고작은 사전절차를 거쳐야하고, 데이터를 암호화, 복호화 하는 것도 컴퓨터에게는 모두 '일'이기 때문이다.
따라서 ==모든 웹페이지를 암호화해서 HTTPS로 만들면 좋겠지만 그렇게 되면 간단한 페이지를 열어보는 것도 시간이 많이 걸릴 수 있다. 이러한 속도 문제로 인해 단순한 웹 서핑때에는 HTTPS를 사용하지 않고, 로그인이나 결제와 같은 페이지에서 주로 사용한다.== 참고로 일반적인 웹 페이지 HTTP는 TCP 80 포트를 사용하고, SSL이 적용된 HTTPS 페이지는 TCP 443 포트를 사용한다.

> 참고
>
> 1) http://jimmyfactory.blogspot.kr/2015/12/ssl.html
> 2) https://opentutorials.org/course/228/4894

