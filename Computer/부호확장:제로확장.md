# 부호확장 / 제로확장



예제

```c++
#include <stdio.h>

int main()
{
  unsigned int iNum=-1;
  unsigned char cNum=-1;
  char cNum2=-1;

  printf("%d\n", iNum);
  printf("%u\n\n", iNum);
  printf("%d\n", cNum);
  printf("%u\n\n", cNum);
  printf("%d\n", cNum2);
  printf("%u\n\n", cNum2);

  return 0;
}
```



실행 결과는?

-1
4294967295

255
255

-1
4294967295



### 소스 설명

![](https://ws3.sinaimg.cn/large/006tKfTcgy1fmoc7v4htoj30bc05rglp.jpg)



32비트라고 가정할 경우, cpu의 레지스터와 버스가 각각 32bit입니다.

`unsigned int iNum = -1;`

위의 구문에서 iNum이라는 이름으로 -1을 메모리에 32비트 공간에 저장하여 초기화하는 것.  
unsigned이므로 부호는 신경쓰지 않는다. 메모리 상에 다음과 같이 저장 될 것이다.  
16진수로 표시했음을 유의하면.
![](https://ws2.sinaimg.cn/large/006tKfTcgy1fmocazu21hj30dk03cdfy.jpg)

이와 같은 경우는 32비트의 공간을 똑같이 사용하므로 아무런 이상이 없다. 저장된 것을 printf()을 통해 출력했을 때 결과를 살펴보면?

%d의 형식지정자는 signed int를 의미한다. 이는 부호 비트를 생각한다는 말이다. 즉, iNum은 unsigned int이지만 signed int로 출력을 한다. 따라서 메모리 상에 자체적으로 FF FF FF FF 로 저장되어 있지만 signed int 형태인 -1로 출력된다. 

%u라는 형식지정자는 unsigned int를 의미한다. 부호 비트에 대해 신경쓰지 않는다. iNum은 unsigned int로 출력하여 int형의 최대값을 출력한다.  왜냐면 오버플로우가 발생해서 -1의 가장 큰 값!!



`unsigned char cNum=-1;`

unsigned로 하면 부호가 없는 것이다. 그러면

 /    /    /    /FF 에서 **제로 확장**이 일어난다. unsigned char에서 %d로 출력할 경우 signed char 이지만, 부호가 없기 때문에 -> 0000/0000/0000/FF

다시, %u로 할경우에도 부호가 없었기 때문에 위와 동일하게 출력된다.



`char cNum2=-1;` 의 경우를 살펴보자.

Char cNum2 의 이진법을 보면 FF/FF/FF/11111111 로 최상위 부호를 따라가면서 **부호확장**이 일어난다.  
여기서 

%d을 출력할 경우, signed Int를 나타내므로 2의 보수로 표현해야 한다. 일단 마이너스 부호를 따라가고 Value값은 1 그래서 답은 -1

%u의 경우에는 FF/FF/FF/11111111의 값을 그래도 출력, 그러므로 2^32 최상위 값이 출력된다.



정리 ) unsigned가 있을 경우 부호가 없어서 제로확장, 있으면 최상위 부호를 따라가 부호확장이 일어난다.
그러나 첫번째 예처럼 unsigned int iNum = -1 의 경우 4바이트안에 이미 FF/FF/FF/FF가 성립되어 있어. 만약 %d을 할 경우 2의 보수로 표현해서 -1 출력, %u를 할 경우, 부호비트를 신경쓰지는 않기 때문에 그래도 출력