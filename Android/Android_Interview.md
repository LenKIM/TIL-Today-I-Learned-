
XX 인턴 면접기.

일단 후기부터...
굉장히 큰 자극제가 되었고, 개발자라는 직업에 대한 공부가 얼마나 대단한지 다시한번 깨달았다.
그동안 안드로이드 개발과 Node.js에 대해서만 공부했는데 데이터통신과, 자료구조에 대한 기본적 소양에 대해  
다시한번 알았고, 항상 이러한 공부를 가까이하기라는 목표가 생겼다.

질문은 사실 안드로이드 질문을 많이 할 줄 알고 준비를 그쪽으로했는데,

실제 질문은 그게 아니였다는... 그래서 폭망,
그래도그래도! 얻는 것은 확실히 있었다.

1. 쓰레드와 프로세스의 차이점.
이런... 이거 부터 멘붕이였다. 개발자에게는 가장 기본적인 질문이였다
2. UDP / TCP 차이점
3. 안드로이드에서 AscnyTask의 단점

 별 엄청 어려운 질문이 아니였다. 만약 내가 면접 질문을 조금이라도 봤었다면....
 화가 난다 !
사실 될거 같다는 기분은 안들지만, 큰 자극제가 된 거같다.


## 안드로이드 인터뷰를 대비하여 작성되었음.

1. `Activity`란?

액티비티는 안드로이드 응용 프로그램을 구성하는 4가지 컴포넌트의 하나로서 가장 빈번히 사용되며 사용자를 대면한다는 면에서 실질적으로 제일 중요한 요소이다.

액티비티는 다른 플랫폼의 윈도우와 유사한 개념이지만 정확하게 같지는 않으며 "화면 하나"라고 이해하는 것이 가장 직관적이다.

액티비티는 사용자와의 인터페이스를 구성하기는 하지만 그 자체는 출력기능이 없으므로 직접적으로 보이지 않는다. 사용자 눈에 실제로 보이는 것은 뷰이며 그래서 액티비티는 반드시 내부에 뷰나 뷰 그룹을 가져야 한다.

액티비티 하나는 독립된 기능을 수행하며 액티비티끼리는 서로 중첩되지 않는다.

2. Context란?
어플리케이션 환경에 관한 글로벌 정보를 접근하기 위한 인터페이스.
Abstract 클래스이며 이는 안드로이드 시스템에 의해 제공됩니다. 또한 어플리케이션이 시작되는 순간 같이 태어나며, Context 를 통해, 어플리케이션에 특화된 리소스나 클래스에 접근할 수 있게 합니다.
아니면,,, Context를 통해서 시스템이 관리하고 있는 정보에 접근도 할수 있으며, 안드로이드 시스템 서비스에서 제공하는 API를 호출 할 수 있는 기능을 가지고 있습니다.

3. 액티비티의 생명주기(Life Cycle) /프래그먼트의 생명주기
![Activity_LifeCycle](http://i.imgur.com/khigpAT.jpg)

onCrate()
 - 액티비티를 초기화함. 중지했다 재시작하는 경우라면 액티비티의 이전 상태 정보인 Bundle이 전달된다. 이 정보대로 재초기화한다.

onStart()
 - 액티비티가 사용자에게 보이기 직전에 호출된다.

onResume()
 - 사용자와 상호작용을 하기 직전에 호출된다. 이 단계에서 스택의 제일 위로 올라온다.

onPause()
 - 다른 액티비티가 실행될 때 호출된다. 이 단계에서 미저장한 데이터가 있으면 저장하고 애니메이션은 중지해야 한다. 이 메서드가 리턴되어야 새 액티비티가 활성화 되므로 시간을 너무 많이 끌어서는 안된다.

onStop()
 - 액티비티가 사용자에게 보이지 않게 될 때 호출된다.

onDestroy()
 - 액티비티가 파괴될 때 호출된다. 시스템에 의해 강제로 종료되는 것인지 아니면 finish 메서드 호출에 의해 스스로 종료하는 것인지는 isFinishing 메서드로 조사할 수 있다.

![프래그먼트-생명주기](http://i.imgur.com/JTHgBdC.png)

4. Intent란?
 Intent란 하나의 빈 봉투라고 생각 할 수 있습니다. 이 빈 봉투에 전달하고자 내용물을 담아 다른 액티비티에 보낼 수도 있고, 또는 안드로이드의 4대요소 중 ContentProvider와 BroadCastReciver등의 컴포넌트등을 이용 할 수 있게 만드는 요소입니다.

5. 쓰레드간 통신 방법에 대한 설명
 안드로이드에서는 일반적인 스레드 통신은 UI스레드와 작업자 스레드 사이에 있습니다.

 UI스레드는 메인스레드라도 하며, 긴 태스크와 같은 처리는 백그라운드 스레드로 전송할 수 있습니다. 또한 백그라운 스레드에서 처리가 완료된 데이터를 다시 UI스레드로 전송하여야 한다. 안드로이드는 이런 스레드 메시지 전달 메커니즘을 사용합니다.

 이 메시지 전달매커니즘은 생산자 스레드와 소비자 스레드 모두 메시지가 전달되는 동안에 차단되지 않는 비차단적 소비자-생산자 패턴입니다.

6. 메세지 핸들링에 대한 설명

일단 루퍼 메시지큐 메시지의 개념을 알아야합니다.
일단 루퍼란? UI스레드에 존재하면서, 소비자 스레드와 연관된 메시지 발송자입니다.
다음 메시지큐에서 소비자스레드에서 처리할 메시지들을 담습니다.

 메세지 큐에 메시지를 삽입하는 생산자 스레드를 위한 인터페이스와 소비자 스레드 메시지 처리, 하나의 Looper객체는 많은 핸들러를 갖지만 모두 같은 큐에 삽입됩니다.

7. Looper
 UI스레드에 하나가 존재하며 소비자 스레드와 연관된 메시지 발송자입니다.

8. 백그라운드에서 UI업데이트 하는 방법
AsyncTask 또는 Handler를 활용하여 백그라운드에서 UI를 업데이트합니다.

AsyncTask에서는 Post 부분에서 업데이트
Handler에서는 runOnUiThread(), Handler.post()등을 활용합니다.

9. http통신이나 리소스 관리 등 시간소요시 구현 방법

간단한 리소스에 대한 시간소요에 대해서 알고싶다면
System.currentTimeMillis()를 활용하여 구현합니다.

그러나 Http통신에 Date등의 함수를 처리할때는
나라마다의 시간차를 적용해야 합니다.

10. ANR이란 ?
ANR (Application Not Responding) 은 어플리케이션이 응답하지 않는다는 에러

 - 응용 프로그램이 5초 이상 사용자의 입력에 반응하지 않을 때
 - 브로드캐스트 리시버(BR)가 10초 내로 리턴하지 않을 때

11. AsyncTask란?
메인스레드에서 백그라운드스레드를 활용하여 서비스과 UI업데이트를 활용할 수 있는 클레스입니다.

onPreExecute( ), doInBackground(), onProgressUpadate( ), onPostExecute() 가 주요 핵심 메소드 이면서,

onPreExecute()는 AsyncTask가 실행되기전에 메모리에 올렸다가 doInBackground()에서 백그라운드 작업을 실행합니다. 그리고 중간중간마다 진행상황을 UI에 업데이트하기 위해서 publishProgrss()를 호출하고 이 함수가 호출될때, onProgressUpadate()가 자동으로 호출됩니다.

마지막으로 onPostExecute()로 작업결과가 리턴되고 스레드작업이 끝났을 때의 동작을 구현합니다.

12. Parcel - Serializable

The objects must be either implements Serializable or Parcelable interface to do this. Serializable is a standard Java interface. You can just implement Serializable interface and add override methods.The problem with this approach is that reflection is used and it is a slow process.Jul 23, 2010

퍼실러블과 시리얼리블 둘다 어떤 객체를 전송하기위해서 필요한 인터페이스입니다. 시리얼리블은 자바 표준 인터페이스로써, 따로 어떤 메서드를 만들 필요가 없습니다. 그러므로 발생하는 문제가 임시객체들이 많이 발생하여 GC가 동생될수도 있고 그래서 성능이 저하되는 문제가 발생합니다.

그러나 퍼실러블의 경우, 속도가 굉장히 빠른편이나, 개발자가 직접 구현해야 할 부분들이 많아서 사용하기 불편할 수 있습니다.


13. 명시적 인텐트와 암시적 인텐트 사용 예

호출하고자 하는 대상이 명확히 있는가 없는가에 따라 분류되는데,
명시적 인텐트의 경우 Intent를 통하여 화면전환을 하는 경우 또는 호출하고자하는 대상이 명확히 명시되어있을때 사용되어집니다.

그러나 암시적인텐트의 경우에는 호출하고자 하는 대상이 없을 떄 사용되며,
Intent-filter를 통한 방식을 대표적인 예로 들수 있습니다.
브로드캐스트리시버나 또는 어떤 SMS같이 액션을 동작시킬때 사용됩니다.

14. Intent Flag -

FLAG_ACTIVITY_CLEAR_TOP, FLAG_ACTIVITY_SINGLE_TOP

만약에 엑티비티스택에 호출하려는 엑티비티의 인스턴스가 이미 존재하고 있을 경우에 새로운 인스턴스를 생성하는 것 대신에 존재하고 있는 엑티비티를 포그라운드로 가져옵니다. 그리고 엑티비티스택의 최상단 엑티비티부터 포그라운드로 가져올 엑티비티까지의 모든 엑티비티를 삭제합니다.

만약 ABCDE라는 테스크가 있을 떄 그러면 맨위에 E가 보여지고 있는 상황에서 만약 내가 C 로 이동한다면, DE는 삭제가 되고, 오직 ABC의 테스크만 남게 됩니다.

FLAG_ACTIVITY_SINGLE_TOP
의 경우 내가 ABCDE라는 테스크가 있을 때, 다시 E를 호출한다면,
맨 위에 E가 존재하기 때문에 새로운 인스턴스 E는 호출하지않습니다.
오직 ABCDE만 존재하게 되는 겁니다.

노 히스토리의 경우 어떠한 흔적을 남기지 않는것을 말합니다.
주로스플레쉬화면에서 인트로로 넘길때 사용됩니다.

15. 데이터 저장방식 5가지
file, db, sharedPreference, network

16. DataBinding?
버터나이트의 업그레이드판이라고 해도 과언이 아닐정도?
하지만 버터나이프의 경우 구글에서 개발했다고 말하기는 뭐하나,
버터나이프와 비슷한 기능을 가진 라이브러리입니다.

17. AIDL에 대한 설명

AIDL은 Android Interface description language의 약자입니다. 말그대로 인터페이스를 정의하는 언어입니다. AIDL파일을 열어보면 Java에서와 비슷하게 Method를 정의하는 코드를 볼 수 있습니다. Corba의 IDL과 같은 것을 Android에서 사용한다고 생각하면 됩니다. AIDL Tool은 AIDL파일에 적합한 Java Code를 자동으로 생성시켜주는 툴입니다. (Corba는 Java의 RMI와 비슷한 역할을 하는 표준이라고 생각하시면 됩니다.)

AIDL은 Android에서 사용되는 IPC (Inter process communication), 안드로이드 구조를 이야기할때 Binder라고 일컬어지는 부분을 사용하기 위해서 정의합니다. Remote Service 라는 것은 같은 프로세스가 아니라 다른 프로세스에서 오는 함수 호출을 처리하는 Service이고 그것을 연결해주는데 Binder가 사용되고 있습니다. 그 Binder를 사용하는 코드를 자동으로 생성시켜주는 것이 AIDL이지요.

18.
컨텐트 프로바이더와 컨텐트 리졸버 차이

컨텐트 프로바이더를 사용하여 안드로이드 시스템의 각종 설정값이나 SD카드 내의 미디어 등에 접근하는 것이 가능합니다. 컨텐트 프로바이더에 접근하기 위해서는 해당 컨텐트 프로바이더의 주소가 필요합니다.

컨텐트 프로바이더에 접근할 때는 컨텐트 프로바이더의 주소와 컨텐트 리졸버(Content Resolver)가 필요합니다. 컨텐트 리졸버는 컨텐트 프로바이더의 주소를 통해 해당 컨텐트 프로바이더에 접근하여 컨텐트 프로바이더의 데이터에 접근할 수 있도록 해주는 역할을 합니다.

컨텐트 리졸버는 액티비티 클래스 내의 getContentResolver()메소드를 통해 인스턴스를 받아올 수 있습니다. 일단 컨텐트 리졸버의 인스턴스를 받아온 후에는 query, insert 등의 메소드을 통해 데이터를 받거나 입력, 수정하고 싶은 컨텐트 프로바이더의 URI(Uniform Resource Identifier)를 넘겨주면 해당 컨텐트 프로바이더에 접근하여 요청한 작업을 수행할 수 있습니다.

19. compileSdkVersion / minSdkVersion / targetSdkVersion

minSdkVersion
안드로이드 앱이 실행될 수 있는 최소한의 API 레벨을 의미

targetSdkVersion
안드로이드 앱의 타겟 API 레벨을 의미합니다. 만약 선언이 되어 있지 않다면 minSdkVersion과 동일한 값으로 간주됩니다. ‘타겟 API’의 개념은 해당 앱이 개발시에 테스트 되어진 API 레벨을 의미합니다. 당연히 targetSdkVersion은 minSdkVersion 보다 같거나 높을 수 밖에 없습니다. 하지만 targetSdkVersion이 높다고 하더라도 앱은 minSdkVersion에서도 인스톨 및 실행할 수 있습니다.

compileSdkVersion
Gradle에 어떤 안드로이드 SDK 버전으로 앱을 컴파일할지 알려줍니다. 즉, 지원할 수 있는 가장 높은 API 버전을 의미합니다.
컴파일 시에만 적용되므로 runtime 동안에는 영향을 미치지 않습니다.
항상 최신 버전의 SDK로 지정하는 것이 좋습니다.

----
자바 관련 면접 질문
1. 객체와 클래스의 차이

 - 객체는 실존하는 것 클래스는 이 실존하는 것을 만들기 위한 하나의 설계도

 2. 사용하는 패턴에 대해 아는 대로 이야기.

 #싱글톤
 #어댑터
 #퍼시드

 3. Composite 패턴에 대한 설명
 클라이언트는 Component 인터페이스/추상클래스를 이용해서 개별/복합객체를 사용할 수 있다.

  객체(Leaf)와 복합객체(Composite)는 Component를 상속받으며 해당 메소드 중 연관된 메소드만 재정의한다.

 객체는 실제 사용되는 말단 객체이며 복합객체는 하단에 또다른 객체의 집합을 구성하는 상위객체이다.

 그러나 객체나 복합객체나 이를 관리하는 부분에서는 동일하게 취급한다.

 4. 자바 기본형 정수와 wrapper 클래스에 대한 차이
 오토박싱과 언박싱으로 인해서 개발자 관점에서 .parseInt 를 통해 문자형에서 기본형으로 / .valueof("")와 같은 문자형에서 wrapper클래스의 차이가 없어졌다.

 5. 자바의 메모리 구조

 Java Program은 JVM위에서 동작하여 모든 OS위에서 동작하게 됩니다.

 ![스크린샷 2017-05-08 오후 10.41.49](http://i.imgur.com/V3rZU45.png)

 * Class loader란? Class파일을 메모리(Runtime Data Area)에 적재하는 기능

 * Runtime Data Area란? 프로그램을 수행하기 위해서 OS로부터 할당 받은 메모리 공간


 1. 클래스(=메소드 공간)

클래스 안에는

- 클래스 정보
- Static 변수
- 변수 정보
- 상수 pool
- 메소드 정보

크게, Method Area, Code Area, Static Area로 나누어진다.
 2. 스택

 LIFO
 - 메서드 호출 시마다 각각의 스택프래임(그 메서드만을 위한 공간)이 생성
 - 메서드 안에서 사용되어지는 값들 저장, 호출된 메서드의 매개변수, 지역변수, 리턴 값 및 연산 시 일어나는 값들을 임시저장
 - 메서드 수행이 끝나면 프레임별로 삭제

 3. 힙

- new 연산자로 생성된 객체와 배열을 저장하는 공간
- 클래스 영력에 로드된 클래스만 생성가능
- Garbage Collector를 통해 메모리 반환

 4. Native 메소드

 - 자바 외의 다른 언어에서 제공되는 메서드들이 저장되는 공간

 5. PC 레지스터

 - Thread가 생성 될 때마다 생성되는 공간
 - Thread가 어떤 부분을 어떤 명령으로 실행할 지에 대한 기록
 - 현재 실행되는 부분의 명령과 주소를 저장


CHAPTER 20 안드로이드
__기본 내용

__구성 요소

__인텐트

__액티비티

__브로드캐스트 리시버

__서비스

__사용자 인터페이스

__퍼시스턴스

__안드로이드 하드웨어

__요약
