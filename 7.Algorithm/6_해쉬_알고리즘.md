
해쉬 알고리즘을 알기 위해서는 일단
**Direct-address Tables** 에 대한 이해가 필요하다.

##### 1.Direct-address Tables이란?

```
If the number of possible keys is small and they are unique, then the table can be a BIG array.
Let the universe of m possible keys be U = {0, 1, .., m-1}.
Direct-Address Table T[0,..,m-1] is an array. Each slot (array element) corresponds to a unique key.
```

이렇게 표현하는데, 이는 가능한 키가 작고 유니크하다면 그 테이블은 큰 배열이 될수 있고, universe안에 있는 모든 가능한 키가 담겨있다라는 말이다.

그러니까 정리하면 가능한키를 다 모아모아 테이블로 만든다는 말씀.

그러므로, 수행시간은 당연히 $O(1)$
즉석에서 즉석으로 바로 찾으니까!!
 - 그러나 공간의 복잡도는 universe라서 $O(|U|)$
 - 실제 공간 사용을 전체 공간으로 나눈 |K|/|U|를 적재율이라고 한다.
 - 만약 적재율이 낮다면, 실제로 대부분의 공간은 낭비된다.

##### 2.Hash Tables이란?
 시작 전에 해쉬라는 것을 알아야 한다.
 - Key k를 저장할 때 slot k에 저장하는 것이 아니라 slot 어떤 함수 h(k)를 이용하여 저장하는 것을 말합니다.
 - 이것을 key k가 slot h(k)로 해쉬되었다고 하며 h(k)를 key k의 해쉽값이라고 부른다.

 - 이 때 h()를 해쉬 함수라고 부릅니다.

 - 앞서본 다이렉트어드래스 테이블과 같이 $O(1)$를 가진다.

 - 하지만 충돌 문제(Collison)있는데, 이 문제를 해결하는 방법으로 Collison resolution by chaining 이있다.

 ![스크린샷 2017-04-13 오후 8.43.04](https://ooo.0o0.ooo/2017/04/13/58ef64583721d.png)

 그러나 이러한 방법의 경우는 수행시간에 한 특정 부분에 길이가 긴 링크드리스트가 생기면 결국 $O(1)$이 아닌 $O(n)$로 된다.
 왜냐하면 앞에서부터 하나하나 다 검색해서 찾아야되기 때문이빈다.

**그래서 최악은 $O(n) 이다.**

평균적인 수행시가은 $$O(1+a)$$

**해쉬 함수(Hash functions)**
 - 좋은 해쉬 함수는 무엇인가?
 `좋은 해쉬함수는 Simple uniform hashing`을 만족하는 해쉬 함수이다.
    - 각각의 key는 중복없이 m개의 slot으로 동일한 확률로 해쉬되며 (simple)
    - 각각의 key는 다른 key값의 해쉬값과 관게없이 해쉬 된다.(Uniformly)

`즉, 좋은 해쉬 함수는 모든 값이 골고루 나오는 것이다.`
  - m개의 slot이 있으면 중복없이 확률적으로 m개의 slot에 골고루 나누어지는 것이 좋으면 이것을 simple uniform hashing이라고 부른다.

**대표적인 해쉬함수는 모듈러 함수** 라고 하는데, 나눗셈을 활용한 해쉬함수가 대표적이다.

$h(k) = k mod m$

![스크린샷 2017-04-13 오후 8.50.17](https://ooo.0o0.ooo/2017/04/13/58ef660829260.png)

이유는, 컴퓨터에서 표현되는 숫자는 2의 지수승이기 때문에 좋지 않다. 비슷한 이유로 $m=2^p-1$을 피하고, $2^p$에 너무 가깝지 않은 소수를 선택하는 것이 좋다.


-----
해쉬함수에서 Collison을 피하기 위한 방법으로 key를 Hash table에 직접 저장하는 것을 **오픈 어드레싱** 이라고 한다.

 오픈 어드레싱의 장점으로
 - 포인터를 사용하지 않아도 되므로 구현이 간편
 - 포인터를 사용하지 않으므로 추가 메모리 공간 사용이 가능하다.

 Open-Addressing의 종류로는

 1. 선형 프로빙(Linear probing)
 2. 이차식 프로빙(Quadratic probing)
 3. 이중 해싱(Double hashing)
 - 삽입 연산은 빈 slot이 나올 때까지 해쉬 테이블을 탐색한다.
 - key가 삽입되는 형태에 따라서 빈 slot의 위치가 결정
 - 삭제의 경우 값을 지우는 부분을 "DELECTED"라고 표시한다.

 1. 선형 프로빙이란
 ![스크린샷 2017-04-13 오후 8.55.52](https://ooo.0o0.ooo/2017/04/13/58ef6759dce21.png)

 ![스크린샷 2017-04-13 오후 8.57.47](https://ooo.0o0.ooo/2017/04/13/58ef67c9eb473.png)

 - 구현이 매우 쉬우나 primary Clustering문제가 생긴다. 이말은 마치 병목현상같은 것이다. 

 2. 이차식 프로빙(Quadratic probing)
![스크린샷 2017-04-13 오후 8.58.51](https://ooo.0o0.ooo/2017/04/13/58ef680c5103f.png)
![스크린샷 2017-04-13 오후 8.59.10](https://ooo.0o0.ooo/2017/04/13/58ef681a97b28.png)
![Uploading 스크린샷 2017-04-13 오후 8.59.31.png… (ip6o6d8lx)]()

3. 이중 해싱(Double hashing)
![스크린샷 2017-04-13 오후 8.59.56](https://ooo.0o0.ooo/2017/04/13/58ef68480c729.png)

![스크린샷 2017-04-13 오후 9.00.12](https://ooo.0o0.ooo/2017/04/13/58ef685e43cbe.png)
