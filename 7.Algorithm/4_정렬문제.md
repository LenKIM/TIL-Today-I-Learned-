학습목표
1. 정렬문제를 정의
2. 자바로 구현

----
**정렬문제(Sorting problem)**
>입력
- n개의 숫자들의 배열 <a1,a2,...an>
>출력
- 입력된 숫자의 배열의 a1,a2,a3조건을 만족하는 다른 결과를 나옴

----

### 1. 선택정렬(Selection sort)
   1. 알고리즘 설명
  - 선택하여 정렬하는 알고리즘
      - 최소값 선택 정렬(Min-Selection sort)
        1. 정렬되지 않은 숫자 중에 가장 작은 숫자를 선택
        2. 선택한 숫자를 정렬되지 않은 숫자들 중 첫 번째 숫자와 자리를 바꾸면 선택된 숫자는 정렬된 것이다.
        3. 모든 숫자 - 1개가 옮겨질 때 까지 동작한다.
            - 최대값 선택 정렬(Max-Selection sort)
   2. 정확성 증명
  - 수학적 귀납법을 이용
  - i번째 선택한 숫자가 i번째로 작은(혹은 큰)숫자인지를 증명
   3. 성능 분석
  -  최고차 항을 O로 표현
      - 최선/최악의 경우 수행시간: O(n^2)
      - 최선/최악의 경우 공간:O(n)

```java
public static void main(String[] args) {

  int [] input = {5,4,3,2,1};
  int i, j, min;
  int temp = 0;

for (i = 0; i < input.length; i++){
    min = input[i];
    for (j = i; j < input.length-1; j++){
        if (min > input[j+1]){
            min = input[j+1];
            temp = j+1;
        }
    }
    if (input[i] != min) {
      //min과 비교대상이 같은지 확인한다!
        input[temp] = input[i];
        input[i] = min;
    }
  }
}
```
### 2. 삽입 정렬
1. 알고리즘 설명
  - 삽입을 이용한 정렬 알고리즘
  : key값과 정렬된 리스트가 주어졌을 때, key값을 정렬된 리스트의 알맞은 위치에 삽입
  - 삽입정렬은 key값을 하나씩 추가하면서 정렬한다.
2. 삽입정렬 수행시간 분석
  - for j =2 to A.length
  최선
  : 배열 A[1..n]가 이미 정렬된 경우 t1 = 1;
  N에 대한 선형함수이므로 an + b;
  최악
  : 배열 A[1..n]가 반대순서로 정렬되어 있는 경우
  N에 대한 2차 함수 이므로 an^2+ bn+ c로 표현된다.

  **시간복잡도**
  $O(n^2)$
  **공감복잡도**
  $O(n)$
```java
public static void main(String[] args) {

      int [] input = {5,2,6,15,3,4};

      int i, j, key;

      for(i = 1; i < input.length; i++){
          key = input[i];
//            for문 에서 2번째 는 조건문이 들어갔다
          for (j = i-1; (j >= 0) && (key < input[j]); j--){
              input[j + 1] = input[j];
              }
          System.out.print(j);
          input[j+1] = key;
          }

      for (i = 0; i < input.length; i++) {
          System.out.print(input[i] + "/");
          }
      }
```
### 3. 합병정렬 알고리즘
  - 합병을 이용한 정렬알고리즘
  무엇을 합병할 것인가?
  - 두 개의 정렬된 배열이 주어졌을 때, 정렬된 하나의 배열로 합병.
  비교했을 때 가장 작은 숫자가 왼쪽에 가있다 라는 사실로 판단.

  **합병정렬(Merge Sort)**
  두 개의 정렬된 배열의 길이를 각각n1이라고 n2하면 수행시간은$O(n1+n2)$

  주요 함수 : compare 와 move
  - comparison <= movement
  movement횟수는 n1+n2
  따라서 comparison의 횟수는 n1+n2보다 작거나 같다.
  결국, comparison횟수 + movement횟수 <= 2(n1+n2)
  최종적으로O(n1+n2).

  - A divide-and-conquer approach
  크기가 커서 풀기 어려운 하나의 문제를 크기가 작아서 풀기 쉬운 여러 개의 문제로 바꾸어서 푸는 방법
      - Divide
        - n Keys를 두로 n/2 keys로 나눈다.
      - Conquer
        - 합병정렬을 사용하여 두 개의 배열을 정렬한다.
      - Combine
        - 두 개의 정렬된 배열을 하나로 합치는 과정

$ T(n)  =  O(1)  if(n = 1)/ 2T(n/2)+O(n)if(n>1)$

  - 재귀 트리
  $c nLogn +cn$


### 4. 힙정렬(Heap Sorting) 알고리즘
  - 힙 구조의 특성을 이용한 정렬
  - 수행시간은 합병정렬과 동일한 nLogn
  - 삽입정렬과 동일한 제자리 정렬(Sort in Place)

  **힙의 형태(The shape of a heap)**
  - 완전 이진 트리(Complete binary tree)에 가까운 형태
  - 이진 트리(binary tree)는 각 노드의 자식수가 2이하인 경우
  - 완전 이진 트리는 Root노드로부터 Leaf노드까지 빠짐없이 채워져 있는 트리

   *이진 트리란, 자식노드를 2개이하를 가진 트리를 말한다!!*

   **힙의 구조**
   - 최대힙 특성(Max-Heap Property)
      - 부모 노드의 값은 항상 자식 노드의 값보다 같거나 크다.
      - 따라서 전체 트리의 Root노드 값이 가장 크다
      - 또한 각 하위 트리 구조의 Root 노드가 가장 큰 값을 가진다.

      ![스크린샷 2017-04-12 오후 4.28.10](http://i.imgur.com/bwn0req.png)

  - 최소힙 특성(Min-Heap Property)
      - 자식 노드의 값은 항상 부모 노드의 값보다 크다.
      - 따라서 전체 트리의 Root 노드 값이 가장 작다.

  **힙의 배열 저장 방식**
    - Root노드는 배열의 첫 번쨰 A[1]에 저장
    - 각각의 노드들은 레벨별로 저장

![스크린샷 2017-04-12 오후 4.31.25](http://i.imgur.com/b6R6W6Y.png)

![스크린샷 2017-04-12 오후 4.35.22](http://i.imgur.com/uJqWCeg.png)

  **노드의 높이**
    - 노드의 높이는 현재 노드에서 leaf노드까지 내려갈 때 가장 단순하게 내려가는 가장 긴 경로에서(Simple path)거쳐야 하는 간선의 수이다.

    1+2+4+8+16 ... n개 까지 해서 더하면,

    O(Log n)
    n = 2^h이므로 양변에 로그를 곱하면.
    h = logn

**힙 특성 관리**
  - Max-Heapify
      - 노드가 입력으로 주어졌을 때
      - 노드의 좌 우 하위 트리들은 Max-Heap특성을 유지하지만 노드의 값이 하위 트리 값보다 작거나 같아서 max-heap특성을 만족하지 않을 때 max-heap특성이 유지되도록 바꾸는 연산

      - 그럼 어떻게? 주어진 노드의 값을 "흘려내리게"해서 주어진 노드와 하위 트리가 max-heap 특성을 가질 수 있도록 변경

  ![스크린샷 2017-04-12 오후 4.44.30](http://i.imgur.com/sun6pVP.png)
**Max-Heapify의 수행시간, T(n)**

  - n을 하위 트리의 노드의 개수라고 할 때
  - 노드의 값을 바꿀 때 수행시간(O(1))
  - 힙의 높이 O(h) = O(logn)
  - 따라서 전체 수행시간은 O(Logn) => 수행시간 x 힙의 높이

  - 평균 시간 복잡도는  O(n log n);

 **수행시간 분석**
 - Max-Heapify를 한번 호출 할 때마다 O(Log n)
 - Max-Heapify의 호출 횟수는 O(n)
 - 따라서 전체 수행 시간은 O(n Log n);


 4-2. 최대값 추출(Extract-Max)
 - Heap에서 가장 큰 값을 제거하고 Max-heap 구조를 복원하는 연산

 How? root와 가장 작은 leaf의 위치를 변경한뒤, root였던 값을 추출한다. 그렇게하면 Heap가 무너지지않고 유지된다.

 - 수행시간은 O(Log n)

 4-3. 힙 소트(Heap Sort)
 ![스크린샷 2017-04-12 오후 5.11.25](https://ooo.0o0.ooo/2017/04/12/58ede187e6210.png)

최대값추출을 계속해서 하면 힙소팅이 된 상태로 나온다. 오른차순으로 나온

- 힙 소팅의 수행시간
:BUILD-MAX-HEAP를 구행하는 시간O(n log n)
-  Extract-Max를 n번 반복(n-1)
- 전체 수행시간은O(n Log n)

### 5. 퀵 정렬(Quicksort)
 - divide-and-conquer paradigm을 사용
    - Partition을 이용한다는 말

![스크린샷 2017-04-13 오후 7.34.10](https://ooo.0o0.ooo/2017/04/13/58ef544757c03.png)

위에 보이는것처럼 Pivot을 먼저 잡고,

피벗은 (left + right / 2)

파티셔닝을 활용해서 정렬을 시도합니다.

![스크린샷 2017-04-13 오후 7.36.05](https://ooo.0o0.ooo/2017/04/13/58ef54a29bcaa.png)

![스크린샷 2017-04-13 오후 7.36.33](https://ooo.0o0.ooo/2017/04/13/58ef54bb64903.png)


- Quicksort의 수행시간은 총 $O(n)$
- 그러나 퀵소드의 경우 경우에 따라 파티셔닝 횟수가 달라진다.
- 양쪽에 균형이 맞은 파티셔닝의 경우 $O(n log n)$
- 비균형일 경우에는 한쪽으로 치우쳐져서 다 더해야하므로 $O(n^2)$

 그럼으로 빅오표기법에 의해 가장 최악의 경우는 $O(n^2)$이다.

![스크린샷 2017-04-12 오후 10.19.41](https://ooo.0o0.ooo/2017/04/12/58ee299715fd7.png)
