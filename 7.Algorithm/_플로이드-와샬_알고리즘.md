All pairs  shortest path 문제를 해결하는 플로이드-와샬 알고리즘은 두 매트릭스를 활용한다.
그래서 시간 복잡도는 $O(V^3)$ 

**인접 행렬 W**
- 각 간선의 값을 담으과 같이 표시합니다.

${w_ij} = w(i,j)$

매트릭스를 만들고 인접 정보를 만든다.

![스크린샷 2017-04-17 오후 2.45.00](https://ooo.0o0.ooo/2017/04/17/58f4567013166.png)

인접하지 않다하면 무한대를 쓰면됨.

이렇게 하는 이유의 최종적인 목적은 최단경로 행렬 D만드는것.
 - 각 경로의 값은 다음과 같이 표시한다.
 - $d_ij = a(i,j)$

 ![스크린샷 2017-04-17 오후 2.49.53](https://ooo.0o0.ooo/2017/04/17/58f457938f0c5.png)

 - 직전 정점 행렬 $pie$
  이 그래프가 필요한 이유는 그 경로 과정을 알기 위해서!

  ![스크린샷 2017-04-17 오후 2.54.37](https://ooo.0o0.ooo/2017/04/17/58f458c97bf50.png)
정리하면 Matrix D()와 Matrix P() 둘을 활용하여 플로이드-와샬 알로리즘을 구현합니다.

![스크린샷 2017-04-17 오후 2.57.11](https://ooo.0o0.ooo/2017/04/17/58f45940f04a1.png)

  - 플로이드-와샬 알고리즘은 Intermediate Vertex을 모두 실험한다.

  - 정점 집합이 $V = {1,2,3..,n}$라고 하면 i,j사이에 정점 집합 V에 속하는 모든 정점을 넣어보고 경로의 값이 가장 작아지는 경로를 찾는다.

  - 수행시간은  $O(V^3)$

![스크린샷 2017-04-17 오후 3.26.31](https://ooo.0o0.ooo/2017/04/17/58f46021ac6ee.png)

 - 재귀해법
    - 정점 i부터 j까지 최단경로를 d(k)부터 ij 라고 하자.
    - 이때{1,2,...k}은 중간 정점의 집합
    - 다음과 같은 재귀식을 구할 수 있다.

    ![스크린샷 2017-04-17 오후 3.27.51](https://ooo.0o0.ooo/2017/04/17/58f46074b078f.png)

![스크린샷 2017-04-17 오후 3.28.11](https://ooo.0o0.ooo/2017/04/17/58f4608726dad.png)


플로이드-와샬 알고리즘 예제

![스크린샷 2017-04-17 오후 3.29.10](https://ooo.0o0.ooo/2017/04/17/58f460e192b41.png)

오른쪽이 Waited 매트릭스

![스크린샷 2017-04-17 오후 3.29.58](https://ooo.0o0.ooo/2017/04/17/58f460f40711d.png)

D(1)와 파이(1)은 무엇인가?

![스크린샷 2017-04-17 오후 3.33.23](https://ooo.0o0.ooo/2017/04/17/58f461de753f3.png)

K값이 모든 Vertex에 대해서 반복하게 되었을 때 종료.
