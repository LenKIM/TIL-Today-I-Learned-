

## Abstract Class
:인스턴스화를 금지하는 Abstract키워드

클래스를 가지고 객체를 만드는 일을 인스턴스화(instantiation)라고 한다.
클래스의 주된 용도는 인스턴스화지만 어떤 경우에는 클래스의 인스턴스화를 막아야 할 경우도 있습니다. 이럴 때 Abstract를 활용

1. Abstract키워드를 이용한 클래스의 인스턴화 금지.
클래스앞에 Abstract를 붙이면 **추상 클래스** 라고 하는데, 추상 클래스는 객체를 만들 수 없습니다.

2. 메소드 본체가 없는 추상 메서드(Abstract method)
`abstract void sendMessage(String recipient);`

**w주의할 점은 추상 메소드를 포함하는 클래스는 클래스 자체도 추상 클래스로 선언해야 한다는 점입니다.**

### 추상 메소드를 선언하는 목적은?

###### 1. 서브 클래스에서 이 메소드를 반드시 구현하도록 만들기 위해서입니다.
###### 2. 다형성을 보장해줄수 있는 용도로 활용한다.
  -  이 말 뜻은 자바에서 추상메소드를 활용하여 다형성을 보장시킨다는 말
  - 객체의 메소드를 호출할 때 변수의 타입에 상관없이 객체가 속하는 클래스의 메소드를 호출한다. 하지만 그와는 달리 자바 컴파일러는 객체가 아니라 변수의 타입만 가지고 그 메소드가 있는지 없는지를 체크한다.
###### 3. 슈퍼클래스의 메소드를 호출하는 척하면서 컴파일러의 체크를 무사 통화하고, 프로그램이 실행될 때는 서브클래스의 메소드가 호출되도록 하는 것!

## Interface

- **자바에서는 다중 상속을 허용하지않아** 이를 해결하기 위해서 인터페이스가 존재한다.
만약 클래스들의 공통점이 있다면 추출해서 인터페이스로 만든다. 그러나 인터페이스는 클래스들의 공통 기능만 표현할 수 있고, 공통 데이터는 표현할 수 없다는 제약이 있다.

- 자바의 식별자 명명 관계에 따르면 인터페이스 이름은 대문자로 시작하는 명사나 형용사로 정하는 것이 좋고, 메소드 이름은 소문자로 시작하는 동사로 정하는 것이 좋다.

- 인터페이스에 속하는 메소드는 무조건 추상 메소드로 선언해야 한다.
- 추상 메소드를 구현할 때는 무조건 public을 사용

###### Interface를 가지고 할 수 있는 일?
- 추상메소드와 유사하게 그 인터페이스를 구현하는 클래스의 선언 방법을 제한할 수 있다.

> 인터페이스 변수의 다형성

 ```java
 obj = new SeparateVolume("86289","개미","베르나르")
 ```
이렇게 한 변수에 여러 종류의 데이터를 대입할 수 있는 성질을 변수의 다형성이라고 한다. 이러한 다형성을 인터페이스도 가질 수 있다.

> 인터페이스의 상수 필드

인스턴스필드는 안되지만, 상수 필드는 가능하다!

>익셉션을 발생하는 추상 메소드


>인터페이스의 상속

이런식으로 가능하다.
```java
interface  Transformable extends Movable{

}
```
여기서 Movable은 또다른 인터페이스임을 알자!

>인터페이스이 다중 상속



마지막!!
 프리미티브 타입 과 레퍼런스타입 변수가 있는데,
 여기서 레퍼런스타입의 변수의 경우 참조에 의한 값을 가져오기 때문에 두 변수가 한 주소값을 가르킬 수 있다.

이를 활용하여 인터페이스 변수에도 비슷한 성질이 있다.
**인터페이스 변수에는 그 인터페이스를 직접 또는 간접으로 구현하는 클래스의 객체를 대입할 수 있다.**

----------
다시 정리하는 추상클래스와 인터페이스 2016_8_28

Abstract Class / Interface

```java
클래스는 크게 일반클래스와 추상클래스로 나뉘는데 추상클래스는 본문중에 '추상메소드'가 하나 이상 포함되는 경우를 말합니다. 인터페이스는 모든 메소드가 추상메소드인 경우에 선언하는 경우가 많습니다.

추상 메소드라 함은 메소드의 선언부만 있고 본문이 없는 것을 말합니다. 여기서 본문은 중괄호({})로 묶여진 몸체(body)부분을 말하는데 중괄호 안이 비어있더라도 이것이 존재한다면 그것은 추상메소드가 아닙니다. 추상메소드의 선언은 다음과 같은 예를 갖습니다.

abstract public void test(int a);

즉, 메소드의 선언 후에 세미콜론만을 찍어 이를 선언만 하고 구현은 자식클래스에게 하게 하는 방법입니다. 일반 클래스의 경우 상속받은 자식클래스가 반드시 부모클래스의 메소드를 '오버라이딩' 할 필요가 없지만 추상클래스를 상속받은 자식클래스는 반드시 추상메소드를 오버라이딩하여야 하기에 메소드를 강제로 구현하게 할 때 많이 쓰입니다.
```

**추상 클래스는 위에서 말한것처럼 추상메소드(빈메서드)를 선언하여 상속받아 쓰이는 모든 클래스에게 기능의 구현을 강제할 때 쓰입니다.**

```
추상클래스와 인터페이스의 가장 큰차이점은 바로 '클래스'냐 아니냐의 차이입니다. 추상클래스의 엄연한 클래스로 이를 구현하는 '상속(extends)'입니다. 그러나 인터페이스는 '포함(implements)'라는 키워드를 통해 구현하게 되는 이는 자바에서 매우 중요한 차이를 가집니다.

자바는 오로지 '단일 상속'만을 지원하기 때문에 추상클래스를 상속받은 클래스는 다른 클래스를 상속받을 수 없습니다. 그러나 인터페이스를 포함하는 클래스는 다른 클래스를 상속받을 수 있습니다.

추상클래스는 일반클래스와 달리 그 자신을 new 명령어를 통해 객체를 생성할 수 있습니다. 그러나 '다형성(polymorlphism)'을 통해 자식 클래스의 객체를 생성할 수는 있습니다.

인터페이스를 쓰는 가장 큰 이유는 다중 상속을 지원하지 않는 자바에서 다중상속의 장점을 가져오기 위해서입니다. 다중상속이 가지는 단점은 배제하고 오직 장점만을 취하기 위해 인터페이스를 쓰는 것입니다.

상속이란 개념은 부모클래스의 속성과 메소드를 자식클래스가 물려받는다는 것인데 쉽게 예를 들면 '자동차'라는 클래스는 '색깔', '배기량'등의 속성과 '기름을 넣는다', '달린다'등의 메소드를 가질 수 있습니다. 이 클래스를 상속하는 '승용차'클래스는 별도로 선언하지 않아도 부모클래스의 '색깔','배기량'이라는 속성과 '기름을 넣는다','달린다'라는 메소드를 가지게 되죠.

추상클래스는 이 부모클래스가 단순히 관념적인 성격이 강할 때 많이 쓰이는데 예컨데 '새'라는 클래스는 그냥'난다'라는 메소드를 가지지만 새의 종류를 따라 나는 방법이 조금씩 틀려 자식클래스에서 어차피 구현해야 될 부분이므로 굳이 부모클래스에서 그 내용을 구현할 필요가 없기 때문입니다.
```

사내에서 추상클래스와 인터페이스를 쓰는 방식이 어떤지 살펴볼 필요가 있었다.

일단 추상클래스와 인터페이스의 사용법 자체도 틀리고 존재유무의 의미도 다르다.

추상클래스의 경우, abstract method를 활용 할 수도 있고, abstract class를 만들 수 있다. 여기서 추상메소드는 안에 바디가 없는 껍데기를 말합니다. abstract method가 하나라도 있는 클래스는 그 앞에 반드는 abstract 클래스명으로 표기되어야 한다.

추상클래스의 경우는 클래스이기 때문에 단 하나의 클래스만 상속받을 수 있다.
만약 추상클래스에서 추상클래스를 상속받을 때는 꼭 구현해 줄 필요가 없다.
추상클래스의 궁극적인 목표는 상속하기 위함이다.

인터페이스는 안이 비어있는 메소드들의 형태들만 써놓은 것이며 상속하는 클래스들에서 해당 메소드들의 내용을 구현해서 가져야하는 메소드들의 집합이라 할 수 있다. 따라서 인터페이스에 새로운 메소드를 추가한다고 하고 그 아래에 인터페이스로부터 상속되는 클래스가 있다면 새로운 메소드에 대한 내용을 반드시 구현해야 합니다. 인터페이스안의 모든 메소드들은 추상메소드이다. 인터페이스는 final을 불일 수 없고 인터페이스 변수들은 static이어야 한다. 한마디로 인터페이스는 일반 변수들을 가질 수 없다.

인터페이스는 하나 이상의 인터페이스들을 상속할 수 있는데 여러개일때는 콤마를 사용하며 이때는 클래스에서 상속받는게 아니라 인터페이스에서 상속받으니 즉 내용이 없는 메소드들을 그래도 두는것이니 구현이 아니라 인터페이스간의 상속이므로 일반 클래스끼리 상속할때처럼 extends를 쓴다.

예를 들면 "인터페이스명 ab = new 클래스명()"이런 형태가 될 것이다. 인터페이스의 접근지정자는 아예 없거나 public이거나 아님 abstract만 가능하다. 어떤 클래스가 인터페이스를 상속받을 때는 (구현할 때는) implements를 쓴다. 물론 클래스가 다른 클래스를 상속하면서 인터페이스를 구현하는 것도 가능하다.

추상클래스는 "일반변수(가능)+일반메소드(가능)+추상메소드" 형태이고 인터페이스는 "상수+추상메소드"만 가능하고 일반변수나 일반메소드를 쓰는 것은 불가능하다. 추상메소드가 뭐냐면 아직 구현이 되지않은 다시 말해서 아직 "구"체적으로 표"현"이 되지않은 메소드를 말한다. 이걸 코드상으로 설명하자면 메소드의 제목(리턴타입,메소드명,매개변수)은 있는데 { }안에 내용이 없는 형태이고 물론 { } 이런 괄호도 없는 형태를 말한다. 끝에 세미콜론 붙이는거 까먹지 않아야하고 말이다. 그럼 어떻게 코드로 작성하는지 알아보기로 하자.^^

```java
abstract class Shape
{
   abstract void draw( );   //메소드 앞에 abstract가 있으면 추상메소드다.
   void hit(int x)
   {
      x=3;
   }
}

interface Shape
{
   void draw( );   //인터페이스에서는 abstract 생략가능하다.
   abstract void move(int y);
}
```
예제처럼 도형을 그리는 프로그램을 만든다고 치자. 삼각형을 만들때도 그려야하고 사각형을 만들때도 그려야하니 예제와 같이 draw( ) 메소드가 필요하겠지만 도형종류가 다르니 그리는 방식도 다를 것이다. 그리고 상위 클래스인 도형은 그릴수가 없다. 도형이 무슨 모양인지 결정이 안되었으니까 말이다. 이런 상황이 추상화(그림아님--)의 대표적인 예가 아닐까 싶다. 도형을 그리는 프로그램이니 위처럼 draw( ) 메소드를 만든 것이나 도형 종류마다 그리는 방법이 다르니 추상메소드로 선언만 해놓고 안의 내용은 상황에 맞게 자식 클래스에서 알아서 다시 구현해 쓰라고 선언만 해놓고 구현을 기다리는 방식(오버라이드해서 재정의)이 바로 추상클래스와 인터페이스다.

추상메소드만 선언할꺼면 인터페이스를, 다른 일반 메소드나 필드도 필요하면 추상클래스를 쓰면 된다. 어렵게 생각하지 말자. 인터페이스는 한눈에 보면 다 빈껍데기 뿐이기 때문에 어떤 것을 구현해야되는지 한눈에 몽땅 들어오므로 쓰는 빈도가 높고 추상클래스는 필요에 의해서 일반 메소드와 더불어서 추상화 기능을 가미할때 쓴다는 정도로만 이해하면 될듯 싶다.

추상클래스와 인터페이스를 어떤 상황에 쓰는지 굳이 구별하자면,
추상클래스는 같은 종류나 행동들을 구현할게 많을때 쓰고 당연하지만 추상메소드를 상속받는 자식클래스에서 구현할때 쓰고 상속에 대한 계층구조를 명확히 표현할때 추상클래스를 이용하는 것만큼 효과적인 방법은 없다하겠다. 추상클래스는 일반변수들과 일반메소드들도 쓸수 있고 아직 구현하지 않아도될 메소드는 그냥 내버려둘수 있어 상황에 따라 편리하다.
인터페이스는 디자인을 구성하는 요소들이 자주 바뀔때 쓰면 유용하고 당연하지만 메소드 형태만 서로 공유해서 구현되는 상황일때 적합하고 클래스 전체가 아닌 메소드들만 쓰고 싶을때 인터페이스를 이용하면 효과적이다. 좀더 깊이 들어가자면 인터페이스의 사용빈도가 상당히 높은데 그 이유중 하나가 동시개발이 가능하므로 시간을 많이 단축시킬수 있다는 점이다. 인터페이스안의 메소드들은 내용이 없는 상태이나 메소드에 대한 결과값은 내용을 만들지 않아도 미리 알수 있으므로 인터페이스의 내용을 누군가가 구현하고 있는 동안에 다른 한사람은 그 메소드가 구현되고 나면 작동할 결과값으로 같은 시간에 다른 일을 할수 있으니 개발작업이 한층더 빨라질수 있는 것이다. 또한 여러사람이 인터페이스를 통해 그런 작업을 동시에 한다고 가정했을때 인터페이스안의 메소드 내용을 변경하더라도 그와 관련된 모든 클래스들을 변경할 필요없이 해당 메소드의 구현되는 내용만 변경하면 모든 처리가 가능해지므로 일거양득(一擧兩得)이라 할수 있겠다.^^

추상클래스와 인터페이스는 여러분이 자바를 배우는 이상 심심치않게 만나는 부분이다. 추상클래스와 인터페이스의 정의만 확실히 알아도 그리 어렵진 않을 것이다. 이제껏 함께 공부한 예제들을 추상클래스나 인터페이스로 만들어 보면서 여러분의 생각대로 프로그램이 잘 돌아가는지 연습해 보기 바란다.

[참고 사이트 http://alecture.blogspot.kr/2011/05/abstract-class-interface.html](http://alecture.blogspot.kr/2011/05/abstract-class-interface.html)


아무래도 분석하기 좋은 소스가 사내에 사용되는 MainActivity라고 생각된다.

MainActivity 는 BaseMenuActivity를 상속하고 있는데,
이 BaseMenuActivity는 당연 abstract class입니다.
왜냐하면, abstract method를 활용하고 있기 때문입니다.

BaseMenuActivity는 BaseActivity를 상속받고 있고,
BaseActivity 또한 abstract class입니다.

이는 또다른 이름의 BaseActivity를 상속받고 있는데,
이놈도 abstract class입니다, 이유는 abstract method를 활용하기 때문입니다.

아니, abstract method를 활용하지 않았지만, 자율성을 부여한다는 의미에서 abstract class로 지정했습니다. 그리고 이는 안드로이드 기본 클래스의 AppCompatActivity를 상속 받습니다.


```java
public interface Listener {
        void onCreate();

        void onStart();

        void onResume();

        void onPause();

        void onStop();

        void onDestroy();

        void onActivityResult(int requestCode, int resultCode, Intent data);

        void onConfigurationChanged(Configuration newConfig);

        void onRequestPermissionsResult(int requestCode, String[] permissions, int[] grantResults);
    }

    public static class AbstractListener implements Listener {
        @Override
        public void onCreate() {

        }

        @Override
        public void onStart() {

        }

        @Override
        public void onResume() {

        }

        @Override
        public void onPause() {

        }

        @Override
        public void onStop() {

        }

        @Override
        public void onDestroy() {

        }

        @Override
        public void onActivityResult(int requestCode, int resultCode, Intent data) {

        }

        @Override
        public void onConfigurationChanged(Configuration newConfig) {

        }

        @Override
        public void onRequestPermissionsResult(int requestCode, String[] permissions, int[] grantResults) {

        }
    }
```

이런식으로 선언한 뒤, 필요할 때 new AbstractListener 이런 식으로 호출해 필요한 라이프 사이클이나  activity life cycle, activity result를 관리할 수 있다.
```java
public void registerListener(Listener listener) {
        listenerList.add(listener);
    }
```
이런식으로 리스너를 등록해서 각 액티비티에 호출해 관리한다.
