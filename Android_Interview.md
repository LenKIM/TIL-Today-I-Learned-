

## 안드로이드 인터뷰를 대비하여 작성되었음.

1. `Activity`란?

액티비티는 안드로이드 응용 프로그램을 구성하는 4가지 컴포넌트의 하나로서 가장 빈번히 사용되며 사용자를 대면한다는 면에서 실질적으로 제일 중요한 요소이다.

액티비티는 다른 플랫폼의 윈도우와 유사한 개념이지만 정확하게 같지는 않으며 "화면 하나"라고 이해하는 것이 가장 직관적이다.

액티비티는 사용자와의 인터페이스를 구성하기는 하지만 그 자체는 출력기능이 없으므로 직접적으로 보이지 않는다. 사용자 눈에 실제로 보이는 것은 뷰이며 그래서 액티비티는 반드시 내부에 뷰나 뷰 그룹을 가져야 한다.

액티비티 하나는 독립된 기능을 수행하며 액티비티끼리는 서로 중첩되지 않는다.

2. Context란?
어플리케이션 환경에 관한 글로벌 정보를 접근하기 위한 인터페이스.
Abstract 클래스이며 이는 안드로이드 시스템에 의해 제공됩니다. 또한 어플리케이션이 시작되는 순간 같이 태어나며, Context 를 통해, 어플리케이션에 특화된 리소스나 클래스에 접근할 수 있게 합니다.
아니면,,, Context를 통해서 시스템이 관리하고 있는 정보에 접근도 할수 있으며, 안드로이드 시스템 서비스에서 제공하는 API를 호출 할 수 있는 기능을 가지고 있습니다.

3. 액티비티의 생명주기(Life Cycle) /프래그먼트의 생명주기
![Activity_LifeCycle](http://i.imgur.com/khigpAT.jpg)

onCrate()
 - 액티비티를 초기화함. 중지했다 재시작하는 경우라면 액티비티의 이전 상태 정보인 Bundle이 전달된다. 이 정보대로 재초기화한다.

onStart()
 - 액티비티가 사용자에게 보이기 직전에 호출된다.

onResume()
 - 사용자와 상호작용을 하기 직전에 호출된다. 이 단계에서 스택의 제일 위로 올라온다.

onPause()
 - 다른 액티비티가 실행될 때 호출된다. 이 단계에서 미저장한 데이터가 있으면 저장하고 애니메이션은 중지해야 한다. 이 메서드가 리턴되어야 새 액티비티가 활성화 되므로 시간을 너무 많이 끌어서는 안된다.

onStop()
 - 액티비티가 사용자에게 보이지 않게 될 때 호출된다.

onDestroy()
 - 액티비티가 파괴될 때 호출된다. 시스템에 의해 강제로 종료되는 것인지 아니면 finish 메서드 호출에 의해 스스로 종료하는 것인지는 isFinishing 메서드로 조사할 수 있다.

![enter image description here](https://www.google.co.kr/url?sa=i&rct=j&q=&esrc=s&source=images&cd=&cad=rja&uact=8&ved=0ahUKEwj0qqjagNjSAhXFXLwKHZKYD6wQjRwIBw&url=http%3A%2F%2Fblog.burt.pe.kr%2F%25EC%2595%2588%25EB%2593%259C%25EB%25A1%259C%25EC%259D%25B4%25EB%2593%259C-%25ED%2594%2584%25EB%259E%2598%25EA%25B7%25B8%25EB%25A8%25BC%25ED%258A%25B8%2F&psig=AFQjCNGT1daZqVtHFcNqnRE8kPVAg7D5uQ&ust=1489649964000464)


4. Intent란?
 Intent란 하나의 빈 봉투라고 생각 할 수 있습니다. 이 빈 봉투에 전달하고자 내용물을 담아 다른 액티비티에 보낼 수도 있고, 또는 안드로이드의 4대요소 중 ContentProvider와 BroadCastReciver등의 컴포넌트등을 이용 할 수 있게 만드는 요소입니다.

5. 쓰레드간 통신 방법에 대한 설명
 안드로이드에서는 일반적인 스레드 통신은 UI스레드와 작업자 스레드 사이에 있습니다.

 UI스레드는 메인스레드라도 하며, 긴 태스크와 같은 처리는 백그라운드 스레드로 전송할 수 있습니다. 또한 백그라운 스레드에서 처리가 완료된 데이터를 다시 UI스레드로 전송하여야 한다. 안드로이드는 이런 스레드 메시지 전달 메커니즘을 사용합니다.

 이 메시지 전달매커니즘은 생산자 스레드와 소비자 스레드 모두 메시지가 전달되는 동안에 차단되지 않는 비차단적 소비자-생산자 패턴입니다.

6. 메세지 핸들링에 대한 설명

일단 루퍼 메시지큐 메시지의 개념을 알아야합니다.
일단 루퍼란? UI스레드에 존재하면서, 소비자 스레드와 연관된 메시지 발송자입니다.
다음 메시지큐에서 소비자스레드에서 처리할 메시지들을 담습니다.

 메세지 큐에 메시지를 삽입하는 생산자 스레드를 위한 인터페이스와 소비자 스레드 메시지 처리, 하나의 Looper객체는 많은 핸들러를 갖지만 모두 같은 큐에 삽입됩니다.

7. Looper
 UI스레드에 하나가 존재하며 소비자 스레드와 연관된 메시지 발송자입니다.

8. 백그라운드에서 UI업데이트 하는 방법
AsyncTask 또는 Handler를 활용하여 백그라운드에서 UI를 업데이트합니다.

AsyncTask에서는 Post 부분에서 업데이트
Handler에서는 runOnUiThread(), Handler.post()등을 활용합니다.

9. http통신이나 리소스 관리 등 시간소요시 구현 방법

간단한 리소스에 대한 시간소요에 대해서 알고싶다면
System.currentTimeMillis()를 활용하여 구현합니다.

그러나 Http통신에 Date등의 함수를 처리할때는
나라마다의 시간차를 적용해야 합니다.

10. ANR이란 ?
ANR (Application Not Responding) 은 어플리케이션이 응답하지 않는다는 에러

 - 응용 프로그램이 5초 이상 사용자의 입력에 반응하지 않을 때
 - 브로드캐스트 리시버(BR)가 10초 내로 리턴하지 않을 때

11. AsyncTask란?
메인스레드에서 백그라운드스레드를 활용하여 서비스과 UI업데이트를 활용할 수 있는 클레스입니다.

onPreExecute( ), doInBackground(), onProgressUpadate( ), onPostExecute() 가 주요 핵심 메소드 이면서,

onPreExecute()는 AsyncTask가 실행되기전에 메모리에 올렸다가 doInBackground()에서 백그라운드 작업을 실행합니다. 그리고 중간중간마다 진행상황을 UI에 업데이트하기 위해서 publishProgrss()를 호출하고 이 함수가 호출될때, onProgressUpadate()가 자동으로 호출됩니다.

마지막으로 onPostExecute()로 작업결과가 리턴되고 스레드작업이 끝났을 때의 동작을 구현합니다.

12. Parcel - Serializable

The objects must be either implements Serializable or Parcelable interface to do this. Serializable is a standard Java interface. You can just implement Serializable interface and add override methods.The problem with this approach is that reflection is used and it is a slow process.Jul 23, 2010

퍼실러블과 시리얼리블 둘다 어떤 객체를 전송하기위해서 필요한 인터페이스입니다. 시리얼리블은 자바 표준 인터페이스로써, 따로 어떤 메서드를 만들 필요가 없습니다. 그러므로 발생하는 문제가 임시객체들이 많이 발생하여 GC가 동생될수도 있고 그래서 성능이 저하되는 문제가 발생합니다.

그러나 퍼실러블의 경우, 속도가 굉장히 빠른편이나, 개발자가 직접 구현해야 할 부분들이 많아서 사용하기 불편할 수 있습니다.


13. 명시적 인텐트와 암시적 인텐트 사용 예

호출하고자 하는 대상이 명확히 있는가 없는가에 따라 분류되는데,
명시적 인텐트의 경우 Intent를 통하여 화면전환을 하는 경우 또는 호출하고자하는 대상이 명확히 명시되어있을때 사용되어집니다.

그러나 암시적인텐트의 경우에는 호출하고자 하는 대상이 없을 떄 사용되며,
Intent-filter를 통한 방식을 대표적인 예로 들수 있습니다.
브로드캐스트리시버나 또는 어떤 SMS같이 액션을 동작시킬때 사용됩니다.

14. Intent Flag -

FLAG_ACTIVITY_CLEAR_TOP, FLAG_ACTIVITY_SINGLE_TOP

만약에 엑티비티스택에 호출하려는 엑티비티의 인스턴스가 이미 존재하고 있을 경우에 새로운 인스턴스를 생성하는 것 대신에 존재하고 있는 엑티비티를 포그라운드로 가져옵니다. 그리고 엑티비티스택의 최상단 엑티비티부터 포그라운드로 가져올 엑티비티까지의 모든 엑티비티를 삭제합니다.

만약 ABCDE라는 테스크가 있을 떄 그러면 맨위에 E가 보여지고 있는 상황에서 만약 내가 C 로 이동한다면, DE는 삭제가 되고, 오직 ABC의 테스크만 남게 됩니다.

FLAG_ACTIVITY_SINGLE_TOP
의 경우 내가 ABCDE라는 테스크가 있을 때, 다시 E를 호출한다면,
맨 위에 E가 존재하기 때문에 새로운 인스턴스 E는 호출하지않습니다.
오직 ABCDE만 존재하게 되는 겁니다.

노 히스토리의 경우 어떠한 흔적을 남기지 않는것을 말합니다.
주로스플레쉬화면에서 인트로로 넘길때 사용됩니다.

15. 데이터 저장방식 5가지
file, db, sharedPreference, network

16. DataBinding?
버터나이트의 업그레이드판이라고 해도 과언이 아닐정도?
하지만 버터나이프의 경우 구글에서 개발했다고 말하기는 뭐하나,
버터나이프와 비슷한 기능을 가진 라이브러리입니다.

17. AIDL에 대한 설명

AIDL은 Android Interface description language의 약자입니다. 말그대로 인터페이스를 정의하는 언어입니다. AIDL파일을 열어보면 Java에서와 비슷하게 Method를 정의하는 코드를 볼 수 있습니다. Corba의 IDL과 같은 것을 Android에서 사용한다고 생각하면 됩니다. AIDL Tool은 AIDL파일에 적합한 Java Code를 자동으로 생성시켜주는 툴입니다. (Corba는 Java의 RMI와 비슷한 역할을 하는 표준이라고 생각하시면 됩니다.)

AIDL은 Android에서 사용되는 IPC (Inter process communication), 안드로이드 구조를 이야기할때 Binder라고 일컬어지는 부분을 사용하기 위해서 정의합니다. Remote Service 라는 것은 같은 프로세스가 아니라 다른 프로세스에서 오는 함수 호출을 처리하는 Service이고 그것을 연결해주는데 Binder가 사용되고 있습니다. 그 Binder를 사용하는 코드를 자동으로 생성시켜주는 것이 AIDL이지요.

18. 
컨텐트 프로바이더와 컨텐트 리졸버 차이

컨텐트 프로바이더를 사용하여 안드로이드 시스템의 각종 설정값이나 SD카드 내의 미디어 등에 접근하는 것이 가능합니다. 컨텐트 프로바이더에 접근하기 위해서는 해당 컨텐트 프로바이더의 주소가 필요합니다.

컨텐트 프로바이더에 접근할 때는 컨텐트 프로바이더의 주소와 컨텐트 리졸버(Content Resolver)가 필요합니다. 컨텐트 리졸버는 컨텐트 프로바이더의 주소를 통해 해당 컨텐트 프로바이더에 접근하여 컨텐트 프로바이더의 데이터에 접근할 수 있도록 해주는 역할을 합니다.

컨텐트 리졸버는 액티비티 클래스 내의 getContentResolver()메소드를 통해 인스턴스를 받아올 수 있습니다. 일단 컨텐트 리졸버의 인스턴스를 받아온 후에는 query, insert 등의 메소드을 통해 데이터를 받거나 입력, 수정하고 싶은 컨텐트 프로바이더의 URI(Uniform Resource Identifier)를 넘겨주면 해당 컨텐트 프로바이더에 접근하여 요청한 작업을 수행할 수 있습니다.

19.
