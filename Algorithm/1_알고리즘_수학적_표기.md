
## 빅오 표기법

$$\sum_{n=1}^{100} = O(204) = O(1)$$

위와같이 1부터 100까지 더하는 경우가 있다면
...

$$\sum_{n=1}^{N} C = C + ... + C(N times) = O(C * N) = O(N)$$

이와 같이 빅오 표기법은 처리해야 할 데이터양에 대한 실행 시간을 수학적으로 계산해 알고리즘의 성능을 평가한다.

### 빅오 표기법의 종류
 7가지의 정도로 나눌 수 있음

**$$O(1)$$**
  처리해야 할 데이터양과 상관없이 항상 일정한 실행 시간을 갖는 알고리즘을 의미한다. 앞에서 다룬 1~100까지 더하는 알고리즘이 이에 해당한다.

**$$O(logN)$$**
  처리해야 할 데이터양이 증가할수록 실행 시간도 약간씩 증가하는 알고리즘을 의미한다. 단, 실행 시간의 증가 폭이 logN 그래프를 갖기 때문에 급격하게 증가하지는 않는다. 일반적으로 효율이 높은 검색 알고리즘의 성능이 이에 해당한다.

**$$O(N)$$**
  처리해야 할 데이터양과 비례해 실행 시간도 증가하는 경우다. 1~N까지 더하는 알고리즘이 이에 해당한다.

**$$O(NlogN)$$**
  처리해야 할 데이터양보다 실행 시간이 좀 더 빠르게 증가한다. 일반적으로 효율이 높은 정렬알고리즘의 성능이 이에 해당한다.

**$$O(N^2)$$**
보통 반복문이 2번 중첨된 경우의 알고리즘이다.
```java
for (int i; i <100; i++) {
  for (int j; j < 99; j++) {
    // 처리
  }
}
```
이와 같은 알고리즘이 처리해야 할 데이터양이 증가할수록 데이터양의 제곱만큼의 실행 시간이 소요되므로 그리 좋은 알고리즘이 아니다.

**$$O(N^3)$$**
반복문이 3번 중첩된 경우의 알고리즘이다.따라서 처리해야 할 데이터양의 증가하면 실행 시간은 그의 세제곱만큼 증가하므로 좋은 알고리즘이라 할 수 없다.

**$$O(2^n)$$**
데이터양의 증가에 따라 2^만큼 실행 시간이 증가하는 알고리즘이다. 역시 그다지 추천하지 않는 알고리즘.
-----
#### 반복문의 시그마 연산 표현
반복문의 알고리즘 성능은 반복문을 시그마($\sum$)연산으로 표현한 후 계산 결과를 어떤 빅오 표기법으로 나타낼 수 있는지 이해하면된다. 여기에서는 먼저 몃 가지 반복문 형태를 표현하는 시그마 연산을 소개한다.

**반복문을 표현하는 가장 간단한 시그마 연산**
i 를 1부터 N까지 증가시키면서 1을 계속해서 더하면 당연히 N이 된다.

$$\sum_{i=1}^{N} = (N - 1 + 1) = N$$
이를 나타내는 간단한 코드는 다음과 같다.
```java
for(int i = 0; i < N; i++){
  Sum += 1;
}
```
이 연산을 좀 더 응용하면 다음과 같은 공식을 유추할 수 있다.
$$\sum_{k=i}^{j}1 = (j-i+1)$$

즉, k가 i부터 시작해서 j까지의 횟수만큼 1씩 증가시킨 결과는 (최댓값 - 최솟값 + 1)이 되므로 (j-i+1)이 된다. 이는 다음과 같은 반복문으로 응용해 사용할 수 있다.

```java
for(int k = i; k <= j; k++){
  Sum += 1;
}
```


### 잊지말자, 빅오 표기법은 "적어도 이 성능 이상은 보장한다"라는 뜻이다!
