
소수를 구하는 방법은 간단하면서도 최적을 위한 방법이 너무 다양하다.

소수에 대해서 깊이 생각해보는 시간을 가져보자.

1. Prime Number
2,3,5,7,11,13,17
약수가 1과 자기 자신뿐인 숫자..

2. 어떻게 소수를 구할 수 있을까?

**약수가 1과 자신뿐인 것을 확인해야한다.**

즉, **자기 자신보다 작은 수들을 나누어봐서, 하나라도 나누어지면 소수가 아닌 것** 이다..

여기가 내가 아는 내용 코딩하면
3.
```java
int i = 2; //나눌 대상.
boolean isPrime = true;

while( i <= num){
  isPrime = true;

    for (int n = 2;n < i;n++) {
      if(i % n == 0){
        isPrime = false;
      }
      continue;
    }

    if(isPrime == true)
      System.out.printIn(i);
  i++;
  }
}
```

num을 i로 나누어봐서 떨어지는 경우가 있다면 소수가 아니다.
이렇게 하면 num만큼 두번 도니까 시간이 많이 걸릴 것.

이를 더 돌릴 수 있는 방법은 무엇이 있을까????

안쪽 for문을 보면 **0으로 나누어 떨어져서 소수가 아닌 것을 알았을 경우에도 끝까지 돌면서 굳이 나눠 보고있다.**

그래서 break를 넣어 반복을 줄인다. (사실 당연히 이렇게 해야되는거 아닌가??)

```java
for (int n = 2;n < i ;n++ ) {
  if(i % n) {
    isPrime = false;
    break;
  }
  continue;
}
```
 위의 알고리즘은
 입력 받은 수보다 작은 수들을 나누어보며 떨어지는지 아닌지 판별을 하고 있었다.
 조금 더 개선시킨 코드는, 나누어 떨어졌다면 그만 나누어보는 것이었다.

9는 3의 배수 즉 3은 소수
10은 2의배수, 5의배수 즉 2, 5는 소수
14는 2 7의 배수 2,7은 소수

즉 어떤 규칙이 보이는가??

모든 수를 다 나누어 볼 필요없이, *입력받은 수보다 작은 수의 소수들만 나누어보면 되는 것* 이다.
(ArrayList에 소수를 넣어놓고 나누어보는 방식으로 진행해보자)

```java
public class PrimeNumber{
  public static void getPrime(int num, ArrayList<Integer> prime){
    prime.add(2);

    for (int i = 2; i <= num; i++) {
      for (int j = 0; prime.size() > j;j++ ) {
        if(i % prime.get(j) == 0) break; //소수가 아닌 경우

        if(j + 1 == prime.size()) // 소수 일 때
          prime.add(i)
      }
    }

    for (Integer result: prime ) {
      System.out.printIn(result);
    }
  }
}
```

확실히 입력받은 수보다 작은 수의 소수들만 나누어보는 방법이 더 빠르다.
그러나 더 빠른 방법이 있었으니...

 바로 **에라토스테네스의 체** 알고리즘
 ![에라토스테네스](http://cfile28.uf.tistory.com/image/2324F43E5246ED5A2D9357)

 120까지의 모든 소수를 구한다고 해보자.
 2부터 120까지 배열에 모두 넣은 후
 **소수가 아닌 것들을 모두 체크**

 2을 제외한 모든 2의 배수를 체크한다.
 3을 제외한 모든 3의 배수를 체크한다.
 4는 아까 체크당했으므로 소수 아님
 5를 제외한 모든 5의 배수를 체크한다.
 ...
#### ***체크가 안된 수들이 소수***

```java
 public void getEratosTenes(int num){

   int[] arr = new int[num];

   //입력받은 수 만큼 배열에 모두 초기화.
   for (int i = 2; i <= num; i++ ) {
     arr[i] = i;
   }

   for (int i = 2; i <= num ;i++ ) { // 나누는 값:i
     for (int j = 2; j <= num;j++) {
       if(arr[j] != i && arr[j] % i == 0){
         //자신과 같지않고 0으로 떨어지면 소수가 아님.
         arr[j] = 0;
       }
     }
     for (int i = 2;i <= num; i++ ) {
       if(arr[i] != 0){
         arr[i]
       }
     }   
   }
 }
```
걸린시간 18초..
하지만 에라토스테네스의 체를 잘 이용하면 최상의 소수 구하기 프로그램을 만들 수 있다고 한다.

바로,

체크할 때, 모든 수를 다 돌면서 체크할 필요 없이
**체크 할 배수만큼만 반복문을 돌게하는 것** 이다.

그리고 이미 **0으로 체크되어버린 수의 배수는 확인하지 않는다.**
왜냐하면, ***체크된 수의 배수들도 이미 다 체크가 되어있기 때문***

```java
public void getEratosTenes(int num){

  int[] arr = new int[num];
  int i = 2;
  //입력받은 수 만큼 배열에 모두 초기화.
  for (i = 2; i <= num; i++ ) {
    arr[i] = i;
  }

  for (i = 2; i <= num ; i++ ) {
    if(arr[i] == 0) // 이미 체크된 수의 배수는 확인되지 않는다.
    continue;
    for (int j = i+i; j <= num; j += i) {
      // i를 제외한 i의 배수들은 0으로 체크
      arr[j] = 0;
    }
  }
  for (i = 2;i <= num; i++ ) {
    if(arr[i] != 0)
    System.out.printIn(arr[i]);
  }  
}
```

(+Tip)
더 좋게 해보기 위해 수학의 공식 활용
```
소수는 n의 배수가 아니어야한다.
입력받은 수를 입력받은 수보다 작은 수들로 나누어서 떨어지면 소수가 안디ㅏ.
그러나 모두 나누어볼 필요없이, 루트 n까지만 나누어서 떨어지면 소수가 아니다.
```

이 이론을 위의 예제와 접목해보면 다음과 같음
나눌 수를 루트 num까지만 돌리는것!

```java
for (i = 2; i <= Math.sqrt(num) ;i++ ) {
  if(arr[i] == 0) // 이미 체크된 수의 배수는 확인되지 않는다.
  continue;
  for (int j = i+i; j <= num; j += i) {
    // i를 제외한 i의 배수들은 0으로 체크
    arr[j] = 0;
  }
}
```
