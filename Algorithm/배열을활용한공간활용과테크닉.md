

배열
배열은 하나의 이름과 번호로 여러 저장 공간을 접근할 수 있는 구조..

배열과 수정은 1번만 접근 가능

이후에 배울 자료구조들은 이런 단점을 개선하기 위해 등장
 - 인덱스는 항상 0부터 연속적으로 부여
 - 기본적으로 고정적인 길이를 가지고 선언
  - ArrayList등으로 어르정도 개선
 - 배열 중간에 원소를 추가, 삭제, 크기변경은 O(N)
 - 선언과 초기화도 길이에 비례한 시간이 걸린
 - 길이만큼 메모리를 차지.

## 공간과 시간
 배열이나 변수와 같은 공간에 필요한 값들을 저장해두거나 미리 계산해두면 다양한 방법으로 연산량을 줄이는 것이 가능

하지만 배열은 공간을 많이 차지하므로 사용할 수 있는 크기를 제한적이다.

## 테크닉
1. 전처리(Preprocessing)
 필요한 값들을 미리 모두 구해 두거나, 데이터를 미리 전부 가공해두는 기법
 문제에서 사용될 방식에 따라 값들을 게산, 정렬, 가공.
2. 메모이제이션(Memoization)
 중복 계산이 많이 많이 일어날 것 같은 값들을 한 번 계산한 이후에 배열과 같은 공간에 저장해두고, 추가적인 게산이 필요할 때에는 다시 계산하지 않고 저장된 값을 재활용하는 기법
3. 인덱싱(Indexing)
 불규칙적인 데이터에 어떤 기준으로 번호를 매기는 작업 이렇게 붙여진 번호로 배열의 각 공간을 활용할 수 있다.

## 공간에 의미 부여하기
배열의 각 칸을 단순히 '몃번째 칸'이 아니라 해당 칸의 인덱스를 기준으로 다양한 의미를 붙여서 활용할 수 있어야 한다.

# 정렬
정렬은 대표적인 전-처리 기법중하나다이다.
데이터가 많을 수록 연산량이 많아지지만,
정렬 된 배열은 다양한 특징을 활용해 연산량을 최적화 할 수 있다.

전처리를 하기 전..
1. 최대 => O(N)
2. 최소 => O(N)
3. 개수 => O(N)
4. n번째 큰 값(?)

전처리를 한 후...
1. 최대 => O(1)
2. 최소 => O(1)
3. 개수 => O(1)
4. n번째 큰 값(?)

그러나 주의할 점으로 정렬을 하면 O(NlogN) 걸린다.
이를 고려했을 때, 전처리 전보다 느려진다..

##### 그러므로 사용할 때 와 안할 때 파악해야함.

## 가변길이 배열
 - 인덱스는 항상 0부터 연속적으로 부여
 - 원소를 뒤에서 추가하는 것은 거의 O(1)에 가까운 연산량
 - 데이터를 추가하면 가장 뒤에 추가된다.
 - **단, 중간의 데이터를 삭제하는 것은 O(N)의 시간이 걸린다.**
 - **데이터의 수를 예측할 수 없을 때 효율적이다.**
