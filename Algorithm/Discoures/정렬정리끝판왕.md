# 기본적인 정렬 알고리즘

- Bubble Sort
- Insertion Sort
- Selection Sort

- Quick Sort
- Merge Sort
- Heal Sort

- Radix Sort

### 01 Selection Sort

1. 각 루프마다 최대원소를 찾는다.
2. 최대 원소와 맨 오른쪽 원소를 교환한다.
3. 맨 오른쪽 원소를 제외한다.
4. 하나의 원소만 남을 떄까지 위의 루프를 반복한다.

: Max값을 찾은뒤 맨 오른쪽 원소와 교환
```java
selectionSort(int A[], n){ => 배열[1....n] 정렬
	int [] input = {5,6,4,3,1,2};
	int max;
    int temp;
    int size = input.length;
    for (int i = size-1; i >= 0 ; i--) {
		max = i;
		for (int j = i-1; j >= 0 ; j--) {
			if(input[max] < input[j]) {
					max = j;
                }
            }
            temp = input[max];
            input[max] = input[i];
            input[i] = temp;
        }
        System.out.println(Arrays.toString(input));
    }
```

### Bubble Sort

1. 각 인접한 두개의 값을 비교한다.
2. 비교했을 때 큰 값을 오른쪽으로 둔다.
3. 1~2를 n번 반복한다.

```java
bubbleSort(A[], n){
  for (int i = 0; i < A.length()-1; i++ ) {
    for (int j = 0; j < A.length()-1-i; j++) {
      if( index[j] > index[j + 1]){
        temp = index[j];
        index[j] = index[j+1];
        index[j+1] = temp;
      }
    }
  }
}
```

### Insertion Sort
1. 배열의 2번째부터 검사를 시작한다.
2. 그 다음으로 넘어갈 때마다 그 앞에 배열들을 검사한다.
3. 만약 키보다 크면 키를 앞으로 보낸다.
  (j >= 0) && (key < A[j]) <= 여기서 판별한다.



알고리즘의 특성상 기준의 **왼쪽 값들은 모두 정렬** 되어야 한다.

```java
Insertion Sort(A[], n)
{
  int[] input = {5, 6, 4, 3, 1, 2};
  int max;
  for (int i = 1; i < input.length; i++) {
  	max = i;
    for (int j = 0; j < i; j++) {
    	if (input[max] < input[j]) {
        	int temp = input[max];
            input[max] = input[j];
            input[j] = temp;
            }
		}
	}
        System.out.println(Arrays.toString(input));
}
```

## 분할 정복법
 - 분할 : 해결하고자 하는 문제를 작은 크기의 동일한 문제들로 분할
 - 정복 : 각각의 작은 문제를 순환적으로 해결
 - 합병 : 작은 문제의 해를 합하여(merger) 원래 문제에 대한 해를 구함

### Merge Sort
    1. 데이터가 저장된 배열을 절반으로 나눔
    ![enter image description here](http://cfile4.uf.tistory.com/image/034B9E4F51C027A401CC71)
    2. 각각의 순환적으로 정렬
    3. 정렬된 두 개의 배열을 합쳐 전체를 정렬
      ![enter image description here](http://cfile24.uf.tistory.com/image/254A394E51C027E3307670)

 병합시의 Sorting과정을 살펴보면 우선 병합하려고 하는 크기의 메모리를 할당한 다음, 두 개의 원소에 대해 각각의 비교하여 할당된 메모리에 넣는다.
![enter image description here](http://cfile4.uf.tistory.com/image/240C955051C02899167865)

시간 복잡도 => nLog(2)N
*T(n/2) + T(n/2) + n*



```java
mergerSort(A[], p,r) => A[p..r]을 정렬한다.
{
  if(p < r) then{
    q <- (p+r)/2; => 중간 계산
    mergerSort(A,p,q); => 전반부 정렬
    mergerSort(A, q+1, r); => 후반부 정렬
    merge(A, p, q, r); => 합병
  }
}

merge(A[], p, q, r){
  // 정렬되어 있는 두 배열 A[p..q]와 A[q+1 ... r]을 합하여
  // 정렬된 하나의 배열 A[p..r]을 만든다.
}
```

```java
void merge(int data[], int p, int q, int r){
  int i = p, j=q+1, k = p;

  int tmp[data.length()];

  while (i <= q && j <= r) {
    //베이스 케이스 는 맨 앞 인덱스가 중간 인덱스를 넘지 않을 때까지, 중간 인덱스가 마지막 인덱스를 넘지 않을 때까지.
    //첫번째 while문은
    //데이터 i와 데이터 j를 비교해서 작은 값이 k로 내려오고
    if(data[i] < data[j])
        tmp[k++] = data[i++];
    else
        tmp[k++] = data[j++];
  }
  while(i <= q)
      tmp[k++] = data[i++];
  while (j <= r)
      tmp[k++] = data[j++];
  for (int i = p; i <= r; i++) {
    data[i] = tmp[i];
  }
}
```
시작 인덱스 p, 중간이 q 마지막이 r일 때
merge는 p~q, q+1~r 까지 정렬되어있다는 가정을 하고 합친다.

추가 배열이 필요하기 때문에 tmp라는 배열을 만들어 준다.
또한 i,j,k도 설정해주는데 위쪽 그림 예시에서 봤던 위치에 생성된다.

첫번째 while문은 데이터 i와 데이터 j를 비교해서 작은 값이 k로 내려오고
i나 j, 그리고 k를 증가시키는 연산이다.
이 연산은 한쪽의 배열 데이터가 없어질 때까지 반복된다.
즉, i가 q보다 작거나 같고, j가 k보다 작거나 같아질때까지 반복된다는 것.

그리고 첫번째 while문을 나온 후
앞쪽의 배열에 데이터가 남아있는 경우와
뒤쪽의 배열에 데이터가 남아있는 경우를 각각 처리해준다.

마지막으로 추가 배열에 임시로 저장되어있는 값을
data 배열안에 넣어주면서 함수는 끝이난다.

nLog(2)N

### QuickSort

 병합정렬과는 좀 다른 방식의 정렬이다.
 왜냐하면 QuickSort는 하나의 기준값(Pivot)이라 불리는 걸 활용하여 정렬을 실행하기 때문이다.

 퀵정렬은 기준값의 위치여부에 따라 크게 속도가 변화된다.

    1. 분할 : 배열을 다음과 같은 조건이 만족되도록 두 부분으로 나눈다.
   - 정렬할 배열이 주어지고, 마지막 수를 기준으로 삼습니다.
    기준보다 작은 수는 기준의 왼쪽에 나머지는 기준의 오른쪽에 오도록 재배치(분할)합니다.

    2. 정복 : 각 부분을 순환적으로 정렬한다.
    3. 합병 : 아무것도 안한다.

![enter image description here](http://cfile9.uf.tistory.com/image/267ADA4D591BA55F1004EE)

```java
quickSort(A[], p, r) // A[p...r]을 정렬한다.
{
  if(p<r) then{
    q = partition(A, p, r); // 분할
    quickSort(A, p, q-1); //왼쪽 부분배열 정렬
    quickSort(A, q+1, r); //오른쪽 부분배열 정렬
  }
}

partition(A[], p, r) {
  // 배열 A[p...r] 의 원소들을 A[r]을 기준으로 양쪽으로 재배치하고
  // A[r]이 자리한 위치를 return
}
```

 퀵소트는 파티션을 어떻게 나눌 것인가가(r) 가장 큰 중요점!!!

배열 A는 인덱스 p부터 r 까지 있는 데이터를 정렬합니다.
여기서 조건문 또한 p<r 경우에만 알고리즘이 실행 for문은 없지만 재귀함수이기 때문에 for문과 같은 역할을 합니다.
다음으로 partition이라는 함수가 피봇값을 기준으로 전체 데이터를 나눠주고 피봇 인덱스(r)를 반환하는 역할을 한다.
따라서, q는 피봇이 된다.

![enter image description here](http://cfile23.uf.tistory.com/image/210A3D4D591BA560190272)

정렬은 재귀로 동작하기 때문에 실제로 자세히 봐야하는것은 partition 부분!

여기에서는 인덱스의 마지막 값을 기준값으로 설정하도록 한다. 기준값을 중앙으로 옮기면 불필요한 연산이 발생하므로,
기준값 앞에서 작은 값과 큰 값을 정렬한 후 마지막에 기준값을 원래 위치로 이동시킨다.

때문에 위의 그림에서 j를 기준으로 설명하면, 현재 인덱스 j의 값이 기준값보다 크다면 j를 증가시켜 다음 값을 보러간다.
그러나 인덱스 j의 값이 기준값보다 크다면 앞쪽으로 보내야 하는데, 이때 i값을 1증가 시킨 후 그 값과 교환을 해준다.

![enter image description here](http://cfile24.uf.tistory.com/image/235F884D591BA5611703D3)

 이 그림에서 기준값은 15 그러니까 마지막 인덱스이다.
 i와 j를 증가시키며 첫번째 인덱스부터 기준값과 비교하면서 정렬을 수행한다.
 모든 정렬이 완료되면 인덱스 i+1의 값과 기준값의 위치를 바꿔준다.

```java
Partition(A, p, r){
  x <- A[r];
  i <- p-1;
  for j <- p to r-1
  if A[j] <= x then
    i <- i+1;
    exchange A[i] and A[j];
  excnage A[i+1] and A[r];
  return i+1;

  }
}
```

![enter image description here](http://cfile24.uf.tistory.com/image/255CD24B591BA610251D27)

파티션을 하는데 걸린시간이 얼마인지 생각해보면 모든 데이터를 한번씩 비교하면 되므로 n이 된다.
정확하게 말하자면 데이터의 개수가 n개일 때 n-1번의 비교가 이루어지게 된다.

합병정렬보다 시간복잡도가 더 복잡한데, 합병 정렬이 2개로 나뉘는 것과 달리 퀵 정렬은 데이터가 일정하게 나눠지지않는다.

최선의 경우 => 항상 절반으로 분할되는 경우
T(n) = 2T(n/2) + O(n)
    = O(nlogn)

최악의 경우에는 모든 배열이 정렬되어 있을 때, 기준값이 최대, 최소 값일때 최악의 시간 복잡도가 발생한다.
이때 O(n^2)가 된다.

![enter image description here](http://cfile7.uf.tistory.com/image/21470C4D591BA562131228)

다른 알고리즘보다 대체로 빠르기때문에 퀵 정렬이라는 이름이 붙었다.
그렇지만 최악의 경우에는 n^2의 느린 속도를 보여줬는데
왜 퀵 정렬이 다른 알고리즘 보다 빠른걸까

최선의 경우와 최악의 경우는 극단적인 케이스라서
실제적으로 일어나기 어려운 상황이다.

현실적으로 가정 했을 때,
n개의 데이터가 항상 9:1로 분할 된다고 하자.
한 페이즈 당 분할되는 시간을 구하면 항상 n이므로
전체 비교 연산은 트리의 깊이*n 이다.
트리는 대칭적이지 않으므로 가장 깊은 오른쪽 경로(최악의 경우)를 예로 들면
(9/10)^k * n = 1 이된다.
따라서 시간복잡도는 k = log9/10(n) 이 된다.

이 예가 의미하는것은 퀵 정렬의 성능은
파티션이 얼마나 밸런스있게 나뉘냐에 결정된다는 것이다.
극단적인 경우만 아니라면 퀵 정렬의 시간복잡도는 nlogn 이 되므로
실제로 상당히 빠른 정렬 방법이 된다.

평균 시간 복잡도는 생략한다.

![enter image description here](http://cfile2.uf.tistory.com/image/2142AE4D591BA56319311C)

마지막으로 기준값을 선택하는 방법에 대해 알아보자
우리는 마지막 값을 기준값으로 설정했지만 이는 그리 권장되지 않는다.
이미 오름 차순이나 내림 차순으로 정렬된 데이터일 경우
속도가 느려질수 있기 때문이고,
넘어온 데이터가 정렬 되어있을 경우는 상당히 높기 때문이다.

Median of Three는
첫번째/중간/마지막 인덱스의 값들을 각각 비교하여
이중에서 2번째 값을 피봇으로 설정하는 것이다.
이 방법을 이용하면 최대나 최소의 경우는 피할수 있지만
최악의 경우 시간 복잡도는 달라 지지 않는다.

마지막으로 기준값을 랜덤하게 선택하는 방법이다.
그렇게 되면 명시적인 최악의 경우가 사라지지만
주사위를 운이 나쁘게 굴린다면 계속해서 최소값만 걸릴수있다.
이 경우를 최악의 경우라고 할수있다.

### 힙정렬(Heap Sort)
 Heap은
 complete binary tree(full binary tree와는 다른)이면서 heap property를 만족해야 한다.

![enter image description here](http://cfile5.uf.tistory.com/image/27136B3D591BA6642F7C00)

 max heap property : 부모는 자식보다 크거나 같다.
 or
 min heap property : 부모는 자식보다 작거나 같다.

 ![enter image description here](http://cfile27.uf.tistory.com/image/2460943D591BA66526EDA0)

힙정렬의 특징
1) 최악의 경우에도 시간 복잡도가 nlogn이 되는 빠른 정렬
2) 힙정렬은 알고리즘을 구현하는데 추가 배열이 필요하지 않다.
3) 힙이라는 자료구조를 이용해서 정렬을 한다.

![enter image description here](http://cfile21.uf.tistory.com/image/2758F93D591BA66624FFA2)

a,b,c 3개가 다 heap이다.
자세히 보면 동일한 데이터를 가진 서로다른 힙이다.
다시말해, **여러가지 모양의 heap이 존재할 수 있다는 것이다.**

![enter image description here](http://cfile6.uf.tistory.com/image/22229D3D591BA6672996CD)

개념적으로는 binary tree이지만 **실제적으로는 heap을 1차원 배열로 표현 할 수 있다.**
같은 레벨에서 왼쪽부터 배열로 저장하면 1차원 배열

1차원 배열에 저장한다면 누가 누구의 부모이고 자식인지 어떻게 알 수 있을까?
일반적인 트리에서는 불가하지만, complete binary tree에서는 인덱스만으로도 가능하다.

1번의 왼쪽은 2번, 오른쪽은 3번이다.
2번의 왼쪽은 4번, 오른쪽은 5번이다.

 - 루트 노드 A[i]
 - A[i]의 부모 = A[i/2]
 - A[i]의 왼쪽 자식 = A[2i]
 - A[i]의 오른쪽 자식 = A[2i+1]

 ![enter image description here](http://cfile6.uf.tistory.com/image/22229D3D591BA6672996CD)

**전체를 힙으로 만들어라!**

![enter image description here](http://cfile30.uf.tistory.com/image/23298E3D591BA66829D656)
우리가 heal이라는 자료구조를 다루기 위해 필요한 연산이 있는데, 그것은 바로 max-heappify.

연산을 수행할 전제 조건은 다음과 같다.
1. 트리 전체모양은 complete binary tree
2. 왼쪽 서브트리(subtree)는 그 자체로 heap
3. 오른쪽 서브트리(subtree)는 그 자체로 heap

 여기서 유일하게 루트만이 heap property를 만족했을 때 이를 만족시키케 변화시키는 것을 max-heapify 연산이라고 정의한다.
![enter image description here](http://cfile24.uf.tistory.com/image/224D423D591BA66932D8B1)

루트 노드가 정렬되기 위해서는
누군가가 루트의 자리를 대체하고 루트는 그 자리로 가야한다.

연산은 간단하다.
루트 노트에서 자신의 노드중에 더 큰값을 선택한다.
그리고 그 값과 자리를 바꾼다.
이 과정을 마지막 레벨까지 반복한다.

```java
MAX-HEAPIFY(A, i){
    if there is no child of A[i]
        return;
    k <- index of the biggest child of i;                                                              
    if A[i]>=A[k]
        return;
    exchange A[i] and A[k];
    MAX-HEAPIFY(A, k);
}
```
위의 과정을 자세히 봤을때 동일한 과정을 반복하고있으니
heapify는 recursion으로 구현이 가능하다.

첫번째 조건은 base case이다.
자식 노드가 없다는 것은 가장 아래의 레벨까지 내려왔다는 뜻이므로
현재 노드는 리프(leaf)이다.
따라서 return 해주게 된다.

만약에 자식이 있다면 더 큰쪽을 k라고 한다.
자식이 1명만 있는 노드일 경우 1개의 노드를 k 로 지정한다.
자식 노드 보다 크다면 정렬된 것 이므로 리턴한다.
그렇지 않으면 큰 쪽의 자식 노드와 자리를 변경하며 max-heapify를 재귀 호출 한다.

```java
MAX-HEAPIFY(A, i){
    while A[i] has a child do
        k<- index of the biggest child of i;                                                                
        if A[i]>= A[k];
            return;
        exchange A[i] and A[k];
        i=k;
    end
}
```

같은 함수를 iterate하게 구현한 코드이다
주요 함수의 동작 원리는 같다.

max-heapify의 시간복잡도를 구해보도록 하자.
max-heapify는 루트부터 마지막 레벨까지 비교, 교환 연산을 하므로
 트리의 높이보다 많은 시간이 필요하지않다.
따라서 시간 복잡도는 높이에 의해서 결정되며, O(h)이다

일반적인 이진트리가 아니라 complete binary tree이므로
노드의 개수를 n이라고 했을 때 하나가 2, 4, 8개로 갈라 지므로
시간 복잡도는 Θ(logn)이 된다.


이번 시간에는 heap과 heapify연산을 이용해서
어떻게 heap 정렬을 할것인지 알아 볼것이다.

그 전에 정렬을 하기 위해서는 heap을 만들어야한다.
정렬할 1차원 배열을 complete binary tree로 해석한다
tree로 만든다는 것이 아니라 개념적으로 받아들인다는 뜻이다.

complete binary tree는 heap property를 만족하지 않기때문에
heap은 아니다.
그러므로 부모가 자식보다 크다 라는 조건이 자동으로 성립되지 않는다.

따라서, 정렬의 첫번째 조건은 complete binary tree을 heap으로 만드는 것이다.
leaf가 아닌 그 다음 레벨의 노드에서부터
heapify 연산을 통해서 heap으로 만들어준다.



```java
BUILD-MAX-HEAP
    heap-size[A]<-length[A]
    for i <- |length[A]/2| downto 1                                                                         
        do MAX-HEAPIFY(A,i)
```

힙을 만드는데의 시간 복잡도는 다음과 같다.
HEAPIFY연산의 시간 복잡도는 log(n) 이다.
그런데 for 문이 n/2 돌기 때문에 n/2*log(n)이며 빅 오로 표기하면
O(n*log(n))이 된다.
이는 루트 노드만 고려하여 상당히 러프하게 계산한 것이기 때문에,
정확하게 계산한다면 시간복잡도는 O(n)이 된다.

일단 힙을 만드는데는 n의 시간이 걸리지만
정렬을 하는데 시간이 nlogn이기 때문에
결과적으로 nlogn의 시간복잡도가 나온다.

![enter image description here](http://cfile25.uf.tistory.com/image/26293A42591BA7222C8B12)

![enter image description here](http://cfile29.uf.tistory.com/image/2330BF42591BA7222B02B6)

![enter image description here](http://cfile9.uf.tistory.com/image/254ED242591BA7232F4A2A)
1. 주어진 데이터로 힙을 만든다.
2. 힙에서 최대값을 가장 마지막 값과 바꾼다.
3. 힙의 크기가 1줄어든 것으로 간주한다. 즉, 가장 마지막 값은 힙의 일부가 아닌 것으로 간주한다.
4. 루트노드에 대해서 HEAPIFY(1)한다.
5. 2~4 번을 반복

데이터를 힙으로 만들면 인덱스 0의 값이 가장 최대값 이므로 마지막 값과 바꾼다.  
그리고 마지막값은 정렬된 값으로 간주하고 더 이상 신경쓰지 않는다.  
그렇게 줄여나간다면 결국 정렬된 상태의 배열이 완성된다.  

```java
HEAPSORT(A)
    BUILD-MAX-HEAP(A)             // O(n)
    for i <-heap-size downto 2 do // n-1 times                                                              
        exchange A[1] <-> A[i]    // O(1)
        heap_size <- heap_size -1 // O(1)
        MAX-HEAPIFY(A,1)          // O(log(n))
```

### Heap의 응용, 우선순위큐(Prority queue)
 큐는 여러개의 데이터를 넣을 수 있는 컨테이너이다.
 데이터가 들어오고 나갈때는 FIFO구조를 가진다.

 우선 순위 큐는 이러한 큐의 한 종류로써 최대 우선 순위쿠와 최소 우선 순위 큐로 나뉜다.  
 최대 우선순위큐는 다음의 두가지 연산을 지원하는 자료구조이다.
1. INSERT(x) : 새로운 원소 x 를 삽입
2. EXTRACT_MAX : 최대값을 삭제하고 반환

![enter image description here](http://cfile1.uf.tistory.com/image/27555543591BA75A2CE954)


먼저 INSERT에 대해서 알아보도록 하자
위의 그림은 MAX HEAP의 형태로 저장되있는 우선순위 큐이다.

현재 heap의 상황은
1) Complate binary tree
2) Max heap property
를 만족하므로 이를 유지하면서 INSERT 연산을 하기위해서는 고려할 사항들이 있다.

INSERT는 새로운 노드를 추가해야하는데 complate binary tree 만족하려면
가장 마지막 레벨의 leaf에 추가 될수 밖에 없다.

그러나 이 추가 연산이 끝나면 max heap property를 만족하지 못한다.
따라서 heap sort를 이용해서 전체 heap을 정렬시키고
 max heap property를 만족시키도록 해야한다.

 ```java
 MAX-HEAP-INSERT(A, key){
    heap_size = heap_size+1;
    A[heap_size] = key;
    i = heap_size;
    while(i>1 and A[PARENT(i)] < A[i]){                                                                      
        exchange A[i] and A[PARENT(i)];
        i= PARENT(i);
    }
}
 ```

슈도 코드로 MAX-HEAP-INSERT를 나타내었다.
위의 코드에서 A가 HEAP이다.

heap의 사이즈를 1 증가 시켜 주고 그 자리에 새로운 key값을 넣어준다.
i는 문제 노드(새로 추가된)의 인덱스이다.

그 후 while문에서 i>1이라는것은 root 노드가 아니라는 뜻이며
A[PARENT(i)]<A[i] 부모 노드에 저장된 값보다 크다는 것이다.
위의 조건에 해당된다면 부모 노드와 값을 교환해준다.

다시말해 root노드가 될때까지 또는, 자신의 부모 노드보다 작을 때까지
교환연산을 진행하게 되는 것이다.
이때 시간 복잡도는 트리에 높이에 비례하게 되나
heap은 complete binary tree이므로 O(nlogn이다.)

![enter image description here](http://cfile30.uf.tistory.com/image/2552FC43591BA75B31DCBB)

다음은 EXTRACT_MAX를 표현한 그림이다.
heap은 complete binary tree이므로 아무 노드나 삭제할 수 없다.
여전히 complete binary tree를 만족하기 위해서는
마지막 노드(6)를 삭제할 수 밖에 없다

따라서 root노드 값을 삭제하고 마지막 노드를 삭제 후
마지막 노드에 있던 값을 root노드로 옮겨주게 된다.

이 후 heap property 복원을 위해서 sort를 진행하게 된다.

```java
HEAP-EXTRACT-MAX(A){
    if heap-size[A]<1
        then error "heap underflow"                                                                          
    max <- A[1]
    A[1] <- A[heap-size[A]]
    heap-size[A] <- heap-size[A]-1
    MAX-HEAPIFY(A,1)
    return max
}
```

EXTRACT-MAX의 슈도코드이다.
size가 1보다 작을경우 dequeue연산을 진행할 수 없으므로 에러메세지를 출력한다.

그렇지 않으면 A[1]의 값(root)을 리턴하기 위해 max에 넣어준다.
이 후 마지막 값을 루트로 이동 시켜준 후 마지막 노드를 삭제한다.
마지막으로 sort 함수를 호출하면 EXTRACT-MAX연산이 완료된다.
