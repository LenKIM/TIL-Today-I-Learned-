
## 최소비용신장트리(Minimum Spanning Tree)

![enter image description here](http://cfile29.uf.tistory.com/image/22149D3B5925301E0768EA)

최소비용신장트리(Minimum Spanning Tree)

최소 신장트리는 다양한 분야에서 응용되는 가장 기본적인 그래프문제이다.

보통 네트워크(통신, 도로, 가스배관 등)디자인과 같이 뭉뚱그려서 말하는데 연결되어 있으면서 비용이 최소화 된다는 것은 모든 종류의 네트워크에서 요구되어지는 것이기 때문이다. 또한 이미지 프로세싱과 같은 분야에서도 이와 같은 알고리즘을 많이 사용된다.

구체적인 예를 들자면, N개의 도시가 있고 도시와 도시를 연결하는 도로의 비용 W가 있다.
위의 그래프에서 **정점들이 도시** 들이고 엣지의 **Weight가 비용** 이라고 가정한다.

엣지가 없는 경우에는 어떠한 이유로 두 도시를 직접 연결하는 도로를 만드는 것이 불가능하거나 그 비용이 무한대라고 가정한다.

예산이 충분하다면 모든 도시간의 도로를 만들 수 있지만, 이는 불가능하므로,
**최소의 비용** 을 가지고 **모든 도시들이 연결** 되도록 하는 방법을 구할 때 **최소 비용 신장 트리** 문제라고한다.

![enter image description here](http://cfile28.uf.tistory.com/image/2259A0385925311309DBC3)

최소 비용 신장 트리에서 한가지 중요한 사실은 최소 비용 신장 트리의 해는 유일하지 않다.
예를 들어(b,c)대신 (a,h)를 사용해도 된다.

이 때, 그래프의 조건은 다음과 같다.
1. 무방향 가중치 그래프
2. 각 노드(u,v)에 대해 가중치 w(u,v)가 있으며

그리고 문제를 해결하기 위해서
1. 모든 노드들이 서로 연결된다.
2. 가중치의 합이 최소가 된다.
위의 조건을 만족해야 한다.

![enter image description here](http://cfile8.uf.tistory.com/image/2720F435592531F3242674)

한 가지 의문점이 드는 것이, 이것을 왜 '트리'라고 부른 것일까?

보통 트리라고 하면 계층적인 구조를 말하는데, 사실 트리라는 말은 맥락에 따라 다른 정의를 가지기도 한다. 일반적으로, 공학분야에서는 계층적 구조를 트리라고 부르지만 수학 분야에서는 트리가 **사이클 없는 무방향 그래프** 를 뜻한다.

위의 그림을 보면 모든 노드들이 연결되어 있다. 또한 다시 자기 자신으로 돌아올 수 있는 사이클이 없다. 따라서 위의 그림은 트리이다.
그러므로 최소 신장 트리에서는 사이클(중복연결)이 만들어 질 수 없다.

```java
Generic-MST(G, w){
    A<-ø
    while A does not form a spanning tree
        do find edge (u,v) that is safe for A                                                             
            A<-A U {(u,v)}
    return A
}
```

**크루스칼 과 프림의 알고리즘**이 가장 유명한 MST의 알고리즘이다.
이 알고리즘이 가지고 있는 **공통적인 부분이 있는 데 이를 Generic MST** 알고리즘이라고 하자.

Generic MST는 다음과 같다.
어떤 A에 대해서 A U {(u,v)}도 역시 어떤 MST의 부분 집합이 될 경우 **에지(u,v)는 A에 대해서 안전(safe)** 하다고 한다.

1. 처음에는 A = ø 이다.
2. 집합 A에 대해서 안전한 엣지를 하나 찾은 후 이것을 A에 더한다.
3. 엣지의 개수가 n-1개 될 때까지 2번을 반복한다.

![enter image description here](http://cfile2.uf.tistory.com/image/235FAF46592537794A9612)

그렇다면 문제는 어떻게 안전한 엣지를 찾을 것이냐 이다.
이를 위해서 먼저 몃가지 생소한 용어의 정의를 해보자.

1. 그래프의 정점들을 두개의 집합 S와 V-S로 분할한 것을 **컷(Cut) (S,V-S)** 라고 부른다.
2. 엣지(u,v)에 대해서 u-> S 이고 v-> V-S 일 때 엣지(u,v)는 컷 (S, V-S)를 **cross한다** 고 말한다.
3. 엣지들의 부문 집합 A에 속한 어떤 엣지가 컷(S,V-S)를 cross하지 않을 때 컷 (S,V-S)는 A를 **존중** 한다고 한다.

![enter image description here](http://cfile24.uf.tistory.com/image/242C5F3A5925381F1E0FCE)

위의 용어를 정리해보면, A에 대해서 안전하다는 것은 다음과 같다.
위의 그림에서 빨간 엣지를 A라고 할 때, A가 어떤 MST의 부분집합이고 (S, V-S)를 A를 존중하는 컷이라고 하자.이 컷을 cross하지 않는 에지들 중 **가장 가중치가 적은 에지(u,v)는 A에 대해서 안전** 하다고 할 수 있다. (여기서 어떤 MST라고 칭하는 이유는 MST가 유일하지 않기 때문)

즉, lightest edge라고 표기된 엣지를 MST의 성분으로 골라도 된다.

### 크루스칼의 알고리즘

![enter image description here](http://cfile25.uf.tistory.com/image/2168573359265E120332BD)

크루스칼 알고리즘의 순서는 다음과 같다.
1. 엣지들을 가중치의 순서대로 정렬한다.
2. 엣지들을 그 순서대로 하나씩 선택해간다.
단, 이미 선택한 엣지들과 사이클(Cycle)을 형성하면 선택하지 않는다.
3. n-1개의 엣지가 선택되면 종료한다.

앞서 말한 순서대로 MST를 구성한다고 했을 때,  
위의 그림을 예로 들면, a에서 가중치가 가장 작은 것을 선택하고, b에서는 그 다음 작은 것을 선택한다. 같은 값이 있는 경우 아무거나 선택한다. c, d, e도 마찬가지로 가중치가 작은 순서대로 선택하게 된다.

f에서 다음 순서는 6이 되지만 이 엣지를 선택하면 사이클이 형성되므로 이 엣지를 포기하고 다음으로 넘어간다. 따라서 g에서 가중치가 7인 엣지를 선택한다.

![enter image description here](http://cfile24.uf.tistory.com/image/2769354359265F490E2861)

 위와 같은 연산이 계속 반복되며, n-1개의 엣지가 선택되면 MST가 되며 알고리즘을 종료하게 된다. 그림으로 볼때 논리적으로 간단한 알고리즘이지만, 코드로 구현하기는 쉽지 않다.

 ![enter image description here](http://cfile26.uf.tistory.com/image/2619154659265FB4109DA7)

왜 이렇게 선택한 엣지들이 MST가 되는 것일까?
A를 현재까지 알고리즘이 선택한 엣지들이라고 하고, A를 포함하는 MST가 존재한다고 가정하자. A가 공집합에서 시작했으므로 임의의 스탭에서 A를 포함하는 MST가 존재할 떄, 크루스칼 알고리즘이 선택한 엣지가 이 A에 대해서 안전하다라는 것을 보이게 되면 증명이 되는 것이다. 그렇게 만들어지는 엣지를 추가한 A도 MST의 일부이고 일관성이 유지되기 때문이다.

위의 그림은 (u,v)가 사이클을 만들지 않는 가장 가중치가 작은 엣지라고 할 때, u와 v는 빨간 엣지들에 의해서 연결되지 않은 상태이다.  
그렇기 때문에 v에 인접한 노드들을 한쪽집합 S라고 하고 나머지 정점들은 V-S라고 할 때 이 두 컷을 Cross하는 어떤 엣지도 사이클을 만들지 않는다.  
이러한 엣지들 중에서 가중치가 최소인 엣지이므로 정리된 증명과 일치한다.

![enter image description here](http://cfile4.uf.tistory.com/image/221C8F4F592661F72E1196)

그렇다면 사이클 검사는 어떤식으로 검증되는 것일까? 일반적으로 크루스칼 알고리즘에서 사이클이 만들어지는지 검사하기위해서 모든 노드들을 집합으로 표현한다. 다시 말하자면, 이미 연결되어있는 노드들을 하나의 집합으로 표현한다. 위의 그림은 어떠한 노드도 연결되어 있지 않으므로 각각의 노드가 개별적인 집합으로써 존재한다.

![enter image description here](http://cfile5.uf.tistory.com/image/2312F149592662E33DDE75)

첫번째로 선택하는 것은 h와 g인데, 서로 다른 집합에 존재하므로 사이클을 만들지 않는다고 판단.
이 후에 엣지를 선택하고 합집합을 만든다.
엣지를 선택할 때마다 같은 집합에 있는지 확인하고 합집합을 만드는 연산을 수행

![enter image description here](http://cfile8.uf.tistory.com/image/213EB24C5926631B048309)

이와같이 알고리즘을 진행하다가 동일한 집합에 속해 있는 요소들을 찾는 경우
해당 엣지를 버리게 된다.

![enter image description here](http://cfile7.uf.tistory.com/image/210D6C505926636C08C2C9)

마지막으로 n-1개의 엣지가 선택되면 크루스칼 알고리즘을 존재한다.
알고리즘을 종료 했을때 모든 노드들이 한 집합 안에 들어가 있는 것을 확인할 수 있다.

![enter image description here](http://cfile25.uf.tistory.com/image/2158A64E592663EC035D8D)

슈도 코드로 다음과 같이 표현한다.

![enter image description here](http://cfile6.uf.tistory.com/image/25097735593110CF1C7810)

크루스칼의 알고리즘을 위해서는 원소 u가 속해있는 집합이 무엇인지 찾을 수 있어야 하고(Find) 2개의 집합을 하나로 합치는 연산(Union)을 지원해야 한다. 이를 Union Find Problem이라고 한다. 결론을 이야기하면 Union Find Problem을 해결하기 위해, 각각의 집합을 하나의 트리로 표현해야 한다. 이 때 이러한 트리에 규칙이 없다. 이진 트리도 아니고 자식이나 부모에 대한 규제도 없다. 대신 해당 집합의 모든 원소들이 트리의 노드로 들어가야한다는 것이다.

또한 일반 트리가 밑으로 내려가는 것과 달리, 여기서는 루트 노드까지 올라가는 연산, 즉 상향식 트리이다.  
이것의 의미는 트리의 각 노드가 자기 자식 노드의 주소를 가질 필요가 없고, 자신의 부모가 누구인지에 대한 정보만 가지면 된다.  
이것은 꽤 중요한 정보인데, 유일한 부모 노드의 정보만 가지기 때문에 복잡성을 낮출수 있게된다.  

정리하면, **서로소인 집합을 표현하기 위해서 상향식 트리로 표현**한다는 것이다.
또한 모든 노드는 부모를 가지고 있어야하므로 어떤 노드의 부모가 자기 자신일 때 루트 노드이다.  
이를 통해서 알고리즘을 좀더 간단하게 만들 수 있다.
![enter image description here](http://cfile3.uf.tistory.com/image/2338BF405931135D3B1F76)

예를 들어서 위의 그림은 크루스칼의 알고리즘이 진행되는 시점인데,
현재까지 선택된 엣지들이 파란색 선이라면 4개의 집합이 존재한다.  
실제 프로그램 안에서는 4개의 집합을 각각 1개씩의 트리로 표현하므로 총 4개의 트리로 존재하게 된다.  
![enter image description here](http://cfile24.uf.tistory.com/image/2456473E593113FF32D390)

이렇게 **상향식 트리로 만들어진 경우 모든 트리를 하나의 배열로 표현할 수 있다.**
이것이 크루스칼의 알고리즘을 상향식 트리로 만드는 가장 큰 이유이다. 여기서 배열의 인덱스는 노드를 의미하며, 인덱스 내부의 변수값은 부모를 나타낸다. 실제 프로그램안에서는 a,b,c보다 숫자로 표현되게 될 것이다.

```java
Find-Set(x){
    if(x!=p[x]){
        then p[x]<-Find-Set(p[x])                                                                         
    }
    return p[x]
}
```
본격적으로 크루스칼 알고리즘에서 사용되는 코드들을 알아보자. 앞서 설명한 슈도 코드에서 사용되는 것은 Find와 Union이다.  
이 중 Find는 어떤 두 노드가 같은 집합에 포함되는지를 알아보는 연산이었다.
이를 위해 **두 노드의 루트 노드가 동일하면 같은 집합에 있다고 판단**한다.
따라서 find의 결과는 루트 노드의 이름을 리턴해주게 된다.
위의 코드는 Find-Set를 재귀로 구현한 코드이다.

이 find-set의 시간 복잡도를 생각해보면, 트리의 아래에서 루트노드까지 찾아올라가므로 O(h)의 시간복잡도를 가지며 여기서는 h는 트리의 높이다.

만약 트리를 잘못 만들면 모든 노드들이 1열로 줄서 있으므로 최악의 경우 시간 복잡도는 O(n)이 된다.

![enter image description here](http://cfile6.uf.tistory.com/image/2511CC405931161814BB29)

두번째는 Union인데 두개의 집합을 합집합으로 만드는 연산이다.  
예를 들어 위 그림에서 c가 루트인 트리와 f가 루트인 2개의 트리를 하나로 합치는 것이다.  
이를 위해 가장 간단한 방법은, 어느 한쪽 트리가 다른쪽 트리의 자식 트리가 되는 것이다.  
따라서 Union을 하는데 걸리는 시간은 루트를 찾아야하므로 find연산과 동일하고,
루트 노드를 찾은 이후에는 둘중의 한명을 다른쪽의 자식으로 넣어주면 되므로 O(1)이다.  

![enter image description here](http://cfile4.uf.tistory.com/image/212A1948593117411DA03C)

위의 Union의 알고리즘은 아무생각없이 간단하게 짠 알고리즘이다.  
그러나 트리의 높이에 비례해서 복잡도가 증가하므로 가능한한 트리의 높이를 낮춰야한다.  
따라서 weighted union으로 합집합을 만드면 복잡도를 낮게 할수 있다.  

weighted union의 원리는 간단하다.  
트리의 높이를 가능한 낮게 유지한다는 원리에서 작은 트리를 큰 트리의 자식으로 놓는 것이다.  
이렇게 되면 전체 트리의 높이가 증가하지 않게 된다.  

### 프림의 알고리즘

![enter image description here](http://cfile25.uf.tistory.com/image/2505E73359311A3E054099)

이번에는 두번째 MST인 프림의 알고리즘에 대해 알아보자.  
프림의 알고리즘도 마찬가지로 안전한 엣지를 하나씩 추가함으로 완성되는데
안전한 엣지를 찾는 방법이 크루스칼의 알고리즘과 다르다.  

프림의 알고리즘에서는 먼저 출발점인 노드를 선택해야한다.  
그리고 그 출발점인 노드에서부터 점점 몸집을 키우기 시작한다.  
즉, 출발 노드에서 인접한 노드를 선택하고, 여기서 나가는 엣지를 하나 선택하고, 이를 반복한다.  
**크루스칼에서는 떨어진 노드들을 선택했는데 프림의 알고리즘은 인접한 노드를 선택** 하는것이 차이점이다.  

이 때, 어떤 엣지를 선택하느냐에 대한 방법을 알아봐야하는데,
매 단계에서 트리에 포함되어진 노드와 포함되지 않은 노드 사이에 **가중치가 가장 작은 엣지를 선택** 한다.

![enter image description here](http://cfile29.uf.tistory.com/image/27141B3C59311B4606B377)

![enter image description here](http://cfile26.uf.tistory.com/image/2608BE4B59311C230E8565)

**모든 검은점의 최소 값을 따라가야 한다.**
먼저 출발 노드를 선택하는데 아무 노드나 선택하면 된다.  
위의 그림에서는 노드 a를 선택했다.  
a와 인접한 노드는 b 와 h가 있는데, 둘 중에 b와 연결된 엣지의 가중치가 낮으므로 b와 연결해준다.  
같은 원리로 c와 h중에 c와 연결된 엣지의 가중치가 낮으므로 c와 연결해준다.  
동일한 방법으로 노드 i와도 연결된다.  
이를 반복해서 결국 엣지가 n-1일때까지 반복을 하면 MST가 완성된다.  

![enter image description here](http://cfile10.uf.tistory.com/image/2426304E59311D1A03E296)

위의 코드는 프림의 알고리즘에 대한 슈도 코드이다.  
우선 출발점을 0으로 설정해주고 while문으로 엣지가 n-1일때까지 반복한다.  
그리고 while문안에서 최소값을 찾아 Va에 포함시키고 u에 인접하면서 Va에 속하지 않은 각각의 값에 대해 key값을 갱신한다.  

이 때 while 문은 n-1번 반복되며, for 문에 의해 키값이 갱신되므로
시간복잡도는 O(n^2)으로 표현된다.  

그러나 이진 힙(Binary heap)을 사용하여 우선순위 큐를 구현한 경우
 - While loop:
    - n번의 Extract-Min 연산 : O(nlogN)
    - m번의 Decrease-Min 연산 : O(MlogN)
 - 따라서 시간복잡도 : O(nLongN + mLongM) = O(mLongN)
 - 우선순위 큐를 사용하지 않고 단순하게 구현할 경우 : O(N^2)
 - Fibonacci 힙을 사용하여 O(m + nLongN)에 구현 가능.

 
