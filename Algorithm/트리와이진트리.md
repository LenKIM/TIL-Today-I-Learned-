## Tree - 트리와 이진 트리

![enter image description here](http://cfile2.uf.tistory.com/image/2317DE47591BA8D402309F)

트리라는 것은 쉽게 말해 계층적인 구조를 표현하기 위해 사용하는 것.
일반적으로 조직도나 가계도, 파일 시스템에서 많이 사용

tree에서 각각의 노드(node)라고 하며,
노드에서 뻗어나는 가지를 링크
루트
리프

또한 상위계층의 노드를 부모 노드 라고 하며
하위계층을 자식 노드 라고 하는데 이 명칭은 상대적이다.
예를 들어, 어떤 노드의 자식노드가 상대적으로 부모 노드가 될수있다는 것이다.
따라서 부모가 없는 노드를 루트 노드 라고 하거나,
자식이 없는 노드를 리프 노드 라고 할수도 있다.
2단계 상위 노드를 조상(ancestor), 하위 노드를 자손(descendant) 노드 라고 한다.

![enter image description here](http://cfile5.uf.tistory.com/image/210E6B47591BA8D43186C6)

계층에 따른 높이를 레벨로 표시하는데
root 부터 level 1이며 밑으로 갈수록 레벨이 높아진다.
root가 level 0이 되는 경우도 있는데, 취향에 따라 지정하면 된다.

위의 그림을 잘 관찰해보면 특징이 보이는데
바로, 노드의 개수가 n개이면 링크의 개수는 n-1개가 된다는 것이다.

또한, 루트에서 어떤 노드로 가는 경로는 유일하다.
그리고 임의의 두 노드간의 경로도 유일하다.
(같은 노드를 두번 방문하지 않는다는 조건하에)

![enter image description here](http://cfile7.uf.tistory.com/image/220FE247591BA8D531641D)

이진 트리라는 것은 각각의 노드가 최대 2명을 자식을 가지는 트리이다.
즉, 노드의 개수는 없거나 1개 이거나 2개일 수있다.

이진 트리의 노드가 왼쪽에 있는지, 오른쪽에 있는지에 따라
서로 다른 이진 트리로써 구별이 되어진다.
이것이 이진 트리의 일반적인 정의 이다.

![enter image description here](http://cfile28.uf.tistory.com/image/220CB247591BA8D50A4BB6)
이진 트리는 많은곳에 사용할 수있는데
대표적인 예가 Expression Tree이다.

Expression Tree는 수식을 실제로 계산할 때
어떤 순서로 계산해야 하는 지를 표현하고 있는 트리이다.

연산자들이 2진 연산자라면 이러한 이진 트리의 형태로 표현이 가능하다.

![enter image description here](http://cfile29.uf.tistory.com/image/216CAE47591BA8D6055138)
두번째로 Hoffman Code이다.
Hoffman Code는 어떤 데이터를 압축하거나 인코딩하는 기본적인 알고리즘이다.

어떤 텍스트 파일이 있을때, 그 파일에 있는 각각의 알파벳을 적절하게 인코딩해야한다.
이 때, 인코딩 된 파일의 길이가 최소가 되도록 하는 알고리즘이다.

밑의 텍스트 상자에 나왔듯이
c는 00000, d는 10110, e는 010으로 압축된다.

![enter image description here](http://cfile26.uf.tistory.com/image/220F0647591BA8D7323170)


모든 레벨에서 노드들이 꽉 차있는 트리를 full binary tree 라고 하며,
마지막 레벨에서 오른쪽에서 부터 노드들이 차있는 트리를
complete binary tree라고한다.

이와 같은 이진 트리의 특징으로는
1) 높이가 h인 full binary tree는 (2^n)-1개의 노드를 가진다.
2) 노드가 n개인 full 혹은  complete 이진 트리의 높이는 O(logN)이다.

![enter image description here](http://cfile3.uf.tistory.com/image/252FC14D591BA8D8159625)

그렇다면 이진 트리는 어떤 자료구조로 표현 될수 있을까
heap의 경우는 규칙성이 있었으므로 1차원 배열에 저장이 가능했지만
**일반적인 이진 트리는 규칙이 없으므로 연결 구조(linked list)에 저장해야한다.**

트리에서 각각의 노드가 왼쪽 자식의 주소와 오른쪽 자식의 주소를 가지고 있어야 한다
그리고 가장 중요한 데이터를 보유해야하며
필요하다면 부모 노드의 주소도 저장할 수 있다.


![enter image description here](http://cfile22.uf.tistory.com/image/236D1347591BA8D32D6069)


트리에 대해서 첫번째 알고리즘은 순회(traversal)이다.
순회의 종류는 다음과 같은 다양한 방법이 있다.
1. 중순위(in-order) 순회
2. 선순위(pre-order) 순회
3. 후순위(post-order) 순회
4. 레벨오더(level-order) 순회

위의 그림과 마찬가지로 root와 왼쪽, 오른쪽 서브트리로 나눌 때
root, 왼쪽, 오른쪽으로 순회하는 것이 선순위(pre-order),
 왼쪽, 오른쪽, root로 순회하는 것이 후순위(post-order),
왼쪽, root, 오른쪽으로 순회하는것이 중순위(in-order)이다.

```java
INORDER-TREE-WALK(x){
  if x != null    
        then INORDER-TREE-WALK(left[x]);
             print key[x]
             INORDER-TREE-WALK(right[x]);
}
PREORDER-TREE-WALK(x){
    if x != null    
        then print key[x]
             PREORDER-TREE-WALK(left[x]);
             PREORDER-TREE-WALK(right[x]);                                                                 
}

POSTORDER-TREE-WALK(x){
    if x != null    
        then POSTORDER-TREE-WALK(left[x]);
             POSTORDER-TREE-WALK(right[x]);
             print key[x]
}
```

각각의 순회 방식을 슈도 코드로 표현하면 다음과 같다.
순회를 하는 순서만 다를뿐 알고리즘은 동일하다.
기본적으로 서브 트리를 모드 탐색해야 하므로 재귀적 속성을 가지고 있다.

![enter image description here](http://cfile24.uf.tistory.com/image/25536C4D591BA8D920373C)

위에서 보았던 expression tree이다.
각 노드들의 값을 중순위(in-order) 순회하면 다음과 같은 값이 나온다.
**x+y*a+b/c**

각 서브트리를 순회할 때 시작과 종료시에 괄호를 추가하면
다음과 같은 올바른 식이 나온다.
**(x+y) * ((a+b)/c)**

마지막으로 각 노드들의 값을 후순위(post-order) 순회 하면
다음과 같이 후위 표기법으로 표기한 값과 동일한 값이 나오게 된다.
**x y + a b + c  / * /**

![enter image description here](http://cfile23.uf.tistory.com/image/24514C4D591BA8DA1AFD1B)

마지막으로 레벨오더(level-order)순회이다.
이를 표현하는데 가장 적합한 자료구조는 큐.

하나의 큐를 이용해 레벨오더순회를 표현할 수 있다.

큐를 root노트에 넣고, 꺼내면서 꺼낸 해당 노드들의 자식 노드들 순서대로 방문한다. 방문후에 그 자식 노드를 큐의 뒤쪽으로 넣어준다.
이것이 반복되면 레벨 별로 순회

```java
LEVEL-ORDER-TREE-TRAVELSAL(){
    visit the root;
    Q <- root;
    while Q is not empty do
        v <- dequeue(Q);
        visit children of (v);
        enqueue children of v into Q;
}
```

아래 그림과 같이 9개의 노드를 가진 이진트리를 만든 후, inorder, preorder, postorder, 그리고 level-order로 순회하면서 각 노드에 저장된 데이터를 출력하는 프로그램을 작성하라.

```java
class TreeNode {
  Object data;
  TreeNode left;
  TreeNode right;

  public TreeNode(Object data){
    this.data = data;
    this.left = null;
    this.right = null;
  }

  public Object getData(){
    return data;
  }
}

class tree{
  private TreeNode root;

  public TreeNode makeBT(TreeNode bt1, Object data, TreeNode bt2) {
    TreeNode root = new TreeNode(data);
    root.left = bt1;
    root.right = bt2;
    return root;
  }

  public void preorder(TreeNode root){
    if(root != null){
      System.out.println(root.data + " ");
      preorder(root.left);
      preorder(root.right);
    }
  }

  public void inorder(TreeNode root){
    if(root != null){
        inorder(root.left);
        System.out.println(root.data + " ");
        inorder(root.right);
    }
  }

  public void postorder(TreeNode root){
    if(root != null){
        inorder(root.left);
        inorder(root.right);
        System.out.println(root.data + " ");
    }
  }

  public void levelorder(TreeNode root){
      Queue<TreeNode> queue = new linkedList<>();
      queue.add(root);
      while (!queue.isEmpty()) {
        TreeNode tempNode = queue.poll();
        System.out.println(temp.data + " ");
        if(tempNode.left != null)
          queue.add(temp.left);
        if(tempNode.right != null)
          queue.add(temp.right);
      }
  }
}

public static void main(String[] args) {
        TreeNode rootNode = createBinartTree();
        // Test
        preorder(rootNode);
    }

    public static TreeNode createBinartTree(){

        TreeNode rootNode = new TreeNode(40);
        TreeNode node20 = new TreeNode(20);
        TreeNode node10 = new TreeNode(10);
        TreeNode node30 = new TreeNode(30);
        TreeNode node60 = new TreeNode(60);
        TreeNode node50 = new TreeNode(50);
        TreeNode node70 = new TreeNode(70);

        rootNode.left = node20;
        rootNode.right = node60;

        node20.left = node10;
        node20.right = node30;

        node60.left = node50;
        node60.right = node70;

        return rootNode;
    }

```

![enter image description here](https://4.bp.blogspot.com/-_RZO8_3m5zw/U8QQjhhg7VI/AAAAAAAADOY/xLfCY2MWcdY/s640/tree.jpg)

![enter image description here](https://1.bp.blogspot.com/-tOkwMIlorrE/U8pDrJzMJbI/AAAAAAAADQc/J72iIHxE77g/s1600/LevelOrderTraversalWorking.jpg)


## 이진검색트리(Binary Search Tree)

검색 트리라는 것은 트리라는 자료구조를 이용하여 순회하며 데이터를 검색하는 것이다.
트리는 계층적인 구조를 가지고 있으나, 검색트리는 일종의 컨테이너나 집합이라고 볼수있다. 따라서 이를 **다이나믹셋(Dynamic Set)** 이나 딕셔너리(Dictionary),검색구조(Search structure)라고도 부른다.

데이터들이 고정되지 않고 새로운 데이터의 추가/삭제가 가능한 것이 특징이다.

다이나믹 셋의 조건은 다음과 같다.  
여러개의 키를 저장하고 있으면서 insert/search/delete가 가능하다.

![enter image description here](http://cfile2.uf.tistory.com/image/211F593358F6333C0977BF)

연결리스트와 배열을 정렬되어지거나 정렬되어지지 않거나 대한 비교는 위의 표와 같다.

연결리스트나 배열을 썼을 때, 위의 표에서 알수 있는 점은 search, insert, delete 중에 적어도 하나의 O(n)의 시간을 피할 수 없다.

그래서 효과적인 알고리즘을 내기 위해 연구했는데,

그 중에 하나가 탐색트리(Search Tree)이며 두번째가 해슁(Hashing)이 된다.

탐색트리는 일반적으로 Search, Insert, Delete의 기능을 효과적으로 수행하기 위해서 사용되며 보통 Search, Insert, Delete는 해당 트리의 높이에 비례하는 시간 복잡도를 가진다.

레드블랙트리나 AVL트리, B-트리 등은 이진 트리의 아이디어를 조금더 확장하거나 발전시킨 알고리즘이다.
때문에, 탐색 트리중에 가장 기본적인 이진트리를 알아보도록 하자.

![enter image description here](http://cfile1.uf.tistory.com/image/230AAB47591BA982050EFF)
이진 검색 트리는 BST(Binary Search Tree)라고 부른다.  
이름 그대로 이진 트리이며 각 노드에 하나의 키를 저장한다.  
또한 다음의 조건도 만족해야하는데, 각 노드 v에 대해서 그 노드의 왼쪽 서브트리에 있는 키들은 key[v]보다 작거나 같고 오른쪽 서브트리에 있는 값은 크거나 같다.

위의 왼쪽 그림을 보면 임의의 노드에 대해서 왼쪽 서브트리에 있는 키들은 임의 노드의 값보다 작거나 같고 오른쪽 서브트리에 있는 값은 크거나 같다.

![enter image description here](http://cfile24.uf.tistory.com/image/2210CA47591BA9820CA2E1)
```java
TREE-SEARCH(x,k){
    if x= null or k=key[x]
        then return x
    if k < key[x]
        then return TREE-SEARCH(left[x],k)
        then return TREE-SEARCH(right[x],k)
}
```

이를 슈도 코드로 표현하면 다음과 같다.

먼저 트리에 값이 없을 경우와 찾았을 경우 리턴해준다.
그렇지 않을 경우 재귀적으로 값이 나올 때까지 왼쪽/오른쪽 트리를 검색해 나간다.

여기서 시간복잡도는 O(h)이며 시간 복잡도는 높이에 비례한다.
-----

이진 검색 트리의 간단한 기본적인 예로
**최소값 찾기**
```java
TREE-MINIMUM(x){
    while left(x) != null                                                                                    
        do x <- right[x]
    return x
}
```

간단하게 생각했을때 이진 검색트리의 최소 값은 루트에서 출발하여 왼쪽을 따라 쭉 내려갔을 때 가장 마지막 노드(leaf)가 된다. 이를 슈도코드로 나타내면 위와 같다.

![enter image description here](http://cfile1.uf.tistory.com/image/2259A950591BA9C31219CA)

다음 예제는 **successor**
일반적인 배열에서 successor는 바로 다음값, predeccesor는 바로 전값이다.

이진 트리에서는 바로 다음 크기값이 successor, 바로 전 크기 값이 preccesor가 된다.

모든 키들이 서로 다르다고 가정해야지 successor용어가 명확하게 정의된다.

successor에는 3가지 규칙이 존재하는데
1. 노드 x의 오른쪽 서브트리가 존재하는 경우, 오른쪽 서브트리의 최소값
2. 오른쪽 서브트리가 존재하지 않을때, 어떤 노드 y의 왼쪽 서브트리의 최대값이 x가 되는 노드 y가 x의 successor
3. 위의 예 2번의 노드 y가 존재가 하지 않을 경우 successor가 존재 하지 않는다

```java
TREE-SUCCESOR(x){
    if right[x] != null
        then return TREE-MINIMUM(right[x])                                                                 
    y <- p[x]
    while y != null and x = right[y]
        do x <- y
           y <- p[y]
    return y
}
```

시간 복잡도는 TREE-MINIMUN과 동일한 O(h)이다.

이진 검색에서 중요한 연산은 insert, search, delete라고 했으니,

그 중 insert에 대해 알아보자.
![enter image description here](http://cfile6.uf.tistory.com/image/2546A950591BA9C3194E94)
insert는 새로운 노드를 이진 검색트리에 추가하는 연산.
새로운 노드를 추가할 때 기존의 노드들은 전혀 건들지 않는다.

따라서 14를 추가 할때 root값과 비교하여 왼쪽/오른쪽 방향을 정한다.
15보다 작으므로 왼쪽으로 내려가고 다시 6과 비교,
6보다 크므로 오른쪽으로 내려가고 7과 비교,
7보다 크고 그 하위의 13보다는 크기때문에 14는 13의 오른쪽 노드에 삽입된다.

![enter image description here](http://cfile30.uf.tistory.com/image/2349FB50591BA9C4135200)

30 -> 20 -> 25 -> 40 -> 10 -> 35 의 순으로 삽입.

삽입 연산의 특징은 기존의 노드들을 건드리지 않는 것인데 그림에서도 먼저 들어간 데이터가 변화하지 않는 것을 알 수 있다.

```java
TREE-INSERT(T,z){
    y <- null
    x <- root[T]
    while x != null
        do y <- x
            if key[z] < key[x]
                then x <- left[x]
                else x <- right[x]                                                                         
    p[z] <- y
    if y = null
        then root[T] <- z
        else if key[z] < key[y]
            then left[y] <- z
            else right[y] <- z
}
```
따라서 삽입 연산을 슈도 코드로 작성하면 위와 같다.  
비교를 통해 노드가 삽입될 자리를 찾아가며 해당 자리에 노드를 삽입해 주게 된다.  
시간 복잡도는 역시 O(h)가 된다.  



 **delete** 를 하는 연산이다.
 delete가 3개의 연산중에 가장 복잡한데, 경우에 따라 연산이 다르기 때문이다.

![enter image description here](http://cfile5.uf.tistory.com/image/241ED14C591BAA1B2513EA)

 1. 첫번째는 자식이 없을 때
 자식이 없을 때는 노드를 그냥 삭제한다.

![enter image description here](http://cfile28.uf.tistory.com/image/2749934C591BAA1C240B89)

 2. 하나의 자식이 있는 경우
 이 경우는 링크드 리스트에서 가운데 값을 하나 삭제하는 것과 비슷하므로 간단하게 처리할 수 있다.
 7을 삭제하고 노드 6의 포인터를 13을 가리키도록 해주면 된다.

 ![enter image description here](http://cfile28.uf.tistory.com/image/267A0F4C591BAA1D29F981)

 3. 마지막으로 자식이 둘인 노드를 삭제하는 경우이다.
 이것이 delete 연산의 가장 복잡한 경우이다.

 노드 13을 삭제하는 경우, 13을 그냥 없애 버리면 자식 노드의 부모가 없어지므로 노드 13의 저장된 데이터 (13)만 삭제한다.

 ![enter image description here](http://cfile3.uf.tistory.com/image/2205434C591BAA1D1C2343)

이후에 없어진 데이터의 successor를 삭제된 부분으로 옮겨온다.
이렇게 하면 트리 전체의 크기 관계가 훼손되지 않는다. 그 다음 successor는 자식 노드가 없거나 하나 있으므로 에시 1번이나 2번의 방법으로 처리해주면된다.

삭제 연산의 슈도 코드
```java
TREE-DELETE(T,z){
    if left[z] =  null or right[z] = null                                                                   
        then y <- z
        else y <- TREE-SUCCESOR(z)
    if left[y] != null
        then x <- left[y]
        else x <- right[y]
    if x != null
        then p[x] <- p[y]
    if p[y] = null
        then root[T] <- x
        else if y = left[p[y]]
            then left[p[y]] <- x
            else right[p[y]] <- x
    if y != z
        then key[z] <- key[y]
            copy y`s satelite data into z
    return y
}
```
삭제 연산의 슈도 코드는 다음과같다.  
이때의 시간 복잡도 역시 다른 연산과 마찬가지로 O(h)가 되며, 높이에 비례한다.  
그 뜻은 최악의 경우일 때 시간 복잡도가 O(n)이 된다는 것이다.  

이를 해결해주기 위해서 균형(balanced)잡힌 트리를 사용하며 균현 잡힌 트리는 키의 삽입이나 삭제시 추가로 트리의 균형을 잡아줌으로써 높이를 O(log_2(n))으로 유지한다.  
물론 추가, 삭제 등의 연산이 기본 이진 트리보다 다소 복잡해진다.  

균형잡힌 트리의 예로는 레드 블랙트리가 있다. 따라서 다음은 레드 블랙트리에 대해서 알아보자

```java
/**
 * Oper­a­tions:
 * <p>
 * Insert(int n) : Add a node the tree with value n. Its O(lgn)
 * Find(int n) : Find a node the tree with value n. Its O(lgn)
 * Delete (int n) : Delete a node the tree with value n. Its O(lgn)
 * Dis­play(): Prints the entire tree in increas­ing order. O(n).
 * Detail Expla­na­tions for the Operations:
 * Find(int n):
 * Its very sim­ple oper­a­tion to perform.
 * start from the root and com­pare root.data with n
 * if root.data is greater than n that means we need to go to the left of the root.
 * if root.data is smaller than n that means we need to go to the right of the root.
 * if any point of time root.data is equal to the n then we have found the node, return true.
 * if we reach to the leaves (end of the tree) return false, we didn’t find the element
 */
public class BinarySearchTree {
    public static Node root;

    public BinarySearchTree() {
        this.root = null;
    }

    public boolean find(int id) {
        Node current = root;
        while (current != null) {
            if (current.data == id) {
                return true;
            } else if (current.data > id) {
                current = current.left;

            } else {
                current = current.right;
            }
        }
        return false;
    }

    public boolean delete(int id) {
        Node parent = root;
        Node current = root;
        boolean isLeftChild = false;

        while (current.data != id) {
            parent = current;
            if (current.data > id) {
                isLeftChild = true;
                current = current.left;
            } else {
                isLeftChild = false;
                current = current.right;
            }

            if (current == null) return false;
        }
        //Case 1 : if Node to be deleted has no children
        // 좌 우 자식이 없을 경우
        if (current.left == null && current.right == null) {
            if (current == root) root = null;
            if (isLeftChild == true) parent.left = null;
            else parent.right = null;
        }

        //Case 2 : if node to be deleted has only one child
        else if (current.right == null) {
            if (current == root) {
                root = current.left;
            } else if (isLeftChild) {
                parent.left = current.left;
            } else {
                parent.right = current.left;
            }
        } else if (current.left == null) {
            if (current == root) {
                root = current.right;
            } else if (isLeftChild) {
                parent.left = current.right;
            } else {
                parent.right = current.right;
            }
            // Case 3 : 두 자식 둘다 없을 경우
        } else if (current.left != null && current.right != null) {
            //now we have found the minimum element in the right sub tree
            Node successor = getSuccessor(current);
            if (current == root) {
                root = successor;
            } else if (isLeftChild) {
                parent.left = successor;
            } else {
                parent.right = successor;
            }
            successor.left = current.left;
        }
        return true;
    }

    private Node getSuccessor(Node deleteNode) {
        Node successor = null;
        Node successorParent = null;
        Node current = deleteNode.right;
        while (current != null){
            successorParent = successor;
            successor = current;
            current = current.left;
        }
        //Check if successor has the right child, it cannot have left child for sure
        //if it does have the right child, add it to the left of successorParent.
        if(successor != deleteNode.right){
            successorParent.left = successor.right;
            successor.right = deleteNode.right;
        }
        return successor;
    }

    public void insert(int id){
        Node newNode = new Node(id);
        if(root == null){
            root = newNode;
            return;
        }
        Node current = root;
        Node parent = null;
        while (true){
            parent = current;
            if(id < current.data){
                current = current.left;
                if(current == null){
                    parent.left = newNode;
                    return;
                }
            } else {
                current = current.right;
                if(current == null){
                    parent.right = newNode;
                    return;
                }
            }
        }
    }
    public void display(Node root){
        if(root!=null){
            display(root.left);
            System.out.print(" " + root.data);
            display(root.right);
        }
    }

    public static void main(String arg[]){
        BinarySearchTree b = new BinarySearchTree();
        b.insert(3);b.insert(8);
        b.insert(1);b.insert(4);b.insert(6);b.insert(2);b.insert(10);b.insert(9);
        b.insert(20);b.insert(25);b.insert(15);b.insert(16);
        System.out.println("Original Tree : ");
        b.display(b.root);
        System.out.println("");
        System.out.println("Check whether Node with value 4 exists : " + b.find(4));
        System.out.println("Delete Node with no children (2) : " + b.delete(2));
        b.display(root);
        System.out.println("\n Delete Node with one child (4) : " + b.delete(4));
        b.display(root);
        System.out.println("\n Delete Node with Two children (10) : " + b.delete(10));
        b.display(root);
    }
}

class Node {
    int data;
    Node left;
    Node right;

    public Node(int data) {
        this.data = data;
        left = null;
        right = null;
    }
}

```

## Tree - 레드 블랙 트리(Red Black Tree)

앞서 본 이진 탐색 트리의 기본연산 3가지가 트리의 높이에 비례하는 시간 복잡도를 가지고 있었다. (:= O(h))
 이때, 극단적으로 비대칭적이며 높이가 높은 트리에서는 그 효율이 높지 않다.

 따라서 이진 탐색 트리의 구조를 유지하며 안정성도 살리는 트리가 필요해졌다.
 이들 중 하나가 레드블랙 트리이다.

 레드 블랙 트리는 이진 탐색 트리의 일종이다.
 이진탐색트리에서 Insert와 Delete 알고리즘을 적절하게 수정하여 이진 탐색 트리임에도 불구하고 트리의 높이에 상관없이 O(LogN)의 시간 복잡도를 유지해준다.

 ![enter image description here](http://cfile24.uf.tistory.com/image/2415D54D591BAA752918CC)

 레드 블랙 트리의 형태는 다음과 같다.
 1. 각 노드는 하나의 키(key), 왼쪽 자식 노드, 오른쪽 자식 노드 그리고 부모 노드의 주소를 저장
 2. 자식노드가 존재하지 않을 경우 NIL 노드라고 부르는 특수한 노드가 있다는 가정
 3. 따라서 모든 리프노드는 NIL노드
 4. 루트의 부모도 NIL노드라고 가정
 5. 노드들은 내부노드와 NIL노드로 분류

 ![enter image description here](http://cfile27.uf.tistory.com/image/221BA14D591BAA762E93C8)

 실제로 NIL노드는 구현 단계에서 존재하지 않기 때문에 (b)그림처럼 하나로 생각한다. 실재로 존재하는 데이터들은 (c)의 그림과 같다.

 또한 레드 블랙 트리는 다음의 5개 조건을 만족하는 이진 탐색 트리이다.
 1. 각 노드는 red혹은 black이다.
 2. 루트 노드는 black이다.
 3. 모든 leaf 노드(즉, NIL 노드)는 black이다.
 4. 레드 노드등의 자식들은 모두 black이어야 한다.(레드가 연속해서는 안됨)
 5. 모든 노드에 대해서, 그 노드로부터 자손인 리프 노드에 이르기까지 모든 경로에는 동일한 개수의 블랙 노드가 존재해야 한다.  

 ![enter image description here](http://cfile30.uf.tistory.com/image/2269774D591BAA77183498)

위의 조건을 만족하는 레드 블랙트리이다.  
1번부터 5번까지 모든 조건을 만족함을 확인할 수 있다.  

**레드블랙트리의높이(h(x))** 는 자신으로부터 리프노드까지 가장 긴 경로에 포함되는 엣지의 개수이다.  

또한 레드블랙트리는 **블랙높이(Bh(x))**라는 것이 있는데, 이는 x로 부터 리프노드까지의 경로상의 블랙 노드의 개수이다.(노드 x 자신은 불포함)  

위 그림에서 h가 높이이며, bh가 블랙 높이이다.  
블랙 높이는 어디로 내려가더라도 5번 조건으로 동일한 값이 된다.

여기서 알수 있는 것은
1) 높이가 h인 노드의 블랙 높이는 bh>=h/2이다.(조건 4에 의해 레드는 연속될 수 없으므로)
2) 노드 x를 루트로 하는 임의의 부트리는 적어도 2^(bh(x))-1개의 내부 노드를 포함한다.
3) n개의 내부 노드를 가지는 레드 블랙 트리의 높이는 ![asd](%5Ccombi%20_%7B%202%20%7D%7B%20log%20%7D(n%2B1)%20)이하이다.

![enter image description here](http://cfile4.uf.tistory.com/image/247ADA4D591BAA782472E6)

레드 블랙 트리는 기본적으로 이진 탐색 트리이기 때문에 Search 알고리즘은 동일하다. 남은 Insert, Delete를 하기 전에 Left/Right Rotation 연산을 알아야한다.

이것은 한 노드를 중심으로 노드의 모양을 변형하는 연산이다.
이 연산을 수행하더라도 이진 탐색 트리의 특성을 유지한다.

Left Rotation을 수행하면 x와 y의 자리가 바뀌며 x는 y의 왼쪽 자식 노드가 된다. 또한 자식 노드의 위치도 왼쪽으로 조금 바뀐다. Right는 이와 반대다.

```java
LEFT-ROTATE(T,x){
    y <- right[x]
    right[x] <- left[y]
    p[left[y]] <- x
    p[y] <- p[x]
    if p[x] = nil[T]
        then root[T] <- y
        else if x = left[p[x]]
            then left[p[x]] <- y
            else right[p[x]] <- y                                                                           
    left[y] <- x
    p[x] <- y
}
```

![enter image description here](http://cfile8.uf.tistory.com/image/216B604D591BAA792AA25E

이어서 레드 블랙 트리의 insert연산에 대해 알아보자.
순서는 다음과 같다.
1. BST에서 처럼 노드를 insert한다.
2. 새로운 노드 z를 red 노드로 한다.
3. RB-Insert-fixup을 호출한다.

```java
RB-INSERT(T,z){
    y<-nil[T]
    x<-root[T]
    while x!= nil[T]
        do y <- x
            if(key[z]<key[x])
                then x <- left[x]
                else x <- right[x]                                                                       
    p[z] <-  y
    if y = nil[T]
        then root[T] <- z
        else if key[z] <- z
            then left[y] <- z
    left[z] <- nil[T]
    right[z] <- nil[T]
    // 여기서 부터 BST와 다름
    color[z] <- RED
    RB-INSERT-FIXUP(T,z)
}
```

우리가 삽입된 노드를 Red로 설정했기 때문에 Red가 2개 중복되기 때문에 조건에 위반될 가능성이 존재한다. 따라서 RB-INSERT-FIXUP 함수를 호출해서 이를 해결한다.

레드 블랙 트리의 조건을 다시 한번 살펴보자
1. 각 노드는 red혹은 black이다.
2. 루트 노드는 black이다.
3. 모든 leaf노드(즉, NIL 노드)는 black이다.
4. 레드 노드 등의 자식들은 모두 black이어야 한다.(레드가 연속해서는 안됨)
5. 모든 노드에 대해서, 그 노드로부터 자손인 리프노드에까지 이르는 모든 경로에는 동일한 개수의 블랙 노드가 존재해야 한다.

위와 같은 조건에 insert연산을 진행한다면 예외적인 상황은 다음과 같이 발생할 수 있다.
1. OK
2. 만약 z 가 루트 노드이면 위반, 아니라면 OK
3. OK
4. z의 부모 p[z] 가 red라면 위반
5. OK


따라서 루트를 도는 동안 유지되는 조건(Loop-Invariant)은
z는 red 노드이며 위의 위반조건(2번, 4번) 중 오직 하나만 존재해야한다는 것이다.

조건 2: z가 루트 노드 이면서 red이거나

조건 4: z와 그 부모 노드 p[z]가 둘다 red일 때

종료 조건은 부모노드 p[z]가 black이 되면 종료한다.

조건 2가 위반일 경우 z를 블랙으로 바꾸어 주고 종료한다.

http://new93helloworld.tistory.com/118
