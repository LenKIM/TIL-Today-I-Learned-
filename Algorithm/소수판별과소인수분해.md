# 소수
1과 자기 자신으로 밖에 나우어 지지않는 수. 즉 약수가 두개 뿐

소인수 분해의 결과가 그냥 자기 자신이다.

1.  for문 => 느린 방법
2. 루트N으로

아래와 같이 자연수 N을 두 자연수 a,b의 곱으로 나타낼 수 있는데, a와 b는 약수이다.

N = a x b;

자연수는 항상 루트 N 이하의 자연수 하나와 루트 N 이상의 자연수 하나의 곱으로 표현.
## 소수의 판별
즉, a <= 루트 N이라는 의미이며 약수가 존재하는 숫자라면 항상 루트 N이하의 약수가 발견된다..

## 소인수 분해
자연수 N을 소수들의 곱만으로 표현하는 것, 숫자를 소인수분해 하면
 1. 약수의 경우의 수를 쉽게 판별
 2. 숫자들의 최대 공약수 등을 계산하기 쉬워진다.

### 소인수 분해 알고리즘
소수 약수를 차례로 구해가며 나누어지지 않을 때까지 계속 나누어 간다.
1. 소인수 분해 할 자연수를 N, 소인수들의 집합을 L이라고 하자.
2. 약수 후보를 M이라고 하자. 초기값은 2이다.
3. M이 루트 N이하 일 동안 아래과정을 반복
    1. M이 N의 약수인 동안 아래 과정 반복
        1. L 에 M을 추가
        2. N 에 M을 추가
      2. M을 증가시킨다.
4. L에 N 을 추가한다.
5. L이 소인수들의 리스트가 된다.

예를 들어 12면 2,3 L = {2,2,3} m = 3;

이 알고리즘의 시간 복잡도는 루트 N이다.

 N | M | L |
 980 | 2 | 2 |
 480 | 2 | 2, 2 |
 245 | 5 | 2, 2, |
 245 | 6 | 2, 2, 5|
 49  | 7 | 2, 2, 5, 7 |
 7   | 7 | 2, 2, 5, 7, 7

### 에라토스테네스의 체 알고리즘
한 자연수 N에 대하여 1~N 범위 모든 숫자의 소수 여부를 구하는 전처리 알고리즘
1. O(NlogN)의 시간 복잡도로 모든 숫자의 소수 여부를 계산
 - 전처리 이후에는 O(1)만에 소수 여부 검사
2. O(N)의 공간 복잡도를 가진다. 그러므로 너무 큰 숫자에는 적용할 수 없다.
3. 1 ~ N범위 각각 모든 숫자들에 대해 가장 작은 소인수를 구해 둘 수 있다.
  - 전처리 이후 O(1)만에 해당 소인수를 가져올 수 있다
  - 이를 활용해 어떤 자연수M을 O(logM)만에 소인수분해 할 수 있다.

#### 에라토스테네스의 체 알고리즘 과정
1~N범위의 모든 숫자의 소수 여부를 구하기 위해 아래와 같은 과정 수행
1. 배열을 만들어 2~N을 모두 소수라고 체크 해둔다.
2. M을 2~N까지 차례로 대입하여 각각 아래 과정을 수행
    1. M이 소수가 아니라고 체크되어 있다면 건너 뛰고 종료한다.
    2. M^2 ~ N범위(자기 배수들)에 있는 M의 배수들을 모두 소수가 아니라고 체크한다.
        - 이때 체크되는 숫자들의 입장에서는 M이 가장 작은 소인수가 된다.
3. 이후 배열에 체크 된 소수 여부를 사용하면 된다.


N * N
에서 P를 한 행을 고정하고
열을 이동하며 탐색하고 있다.
새롭게 갱신하면서 탐색하고 있다.
한 열을 제외하고는 비슷
팬미팅 / 승부조작 비슷하다.

k개가 빠지고 k개가 들어온다.
기존에는 K^2개의 원소를 갱신하는 방법이였다면
이제는 +k -> -k로 탐색

숫자들의 합만 이용하기에 가능하다.
