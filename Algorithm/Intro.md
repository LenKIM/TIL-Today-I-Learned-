참고 : http://gooddaytocode.blogspot.kr/2016/04/blog-post_27.html

# 알고리즘
1. **완전 탐색(Exhaustive Search)**
  - 가능한 경우를 모두 구해서 문제의 해결 방법을 찾는 것
  - 실행시간이 너무 길어 제한 시간 내에 문제를 해결할 수 없는 경우가 많다.
  - Brute-force Search
    - N 중 반복문을 이용하는 방법
    - 큐를 이용하는 방법
    - 순열을 이용하는 방법(재귀 호출로 가능)
    - 재귀 호출을 이용하는 방법
      - 완전 탐색을 구현하기 용이
      - 다른 여러 알고리즘에서 사용
      - 코드가 간결하고 구현이 직관적임
        - 특징 : 쉬운 문제를 어렵게 풀어야 한다.
        - 특징 : 어려운 문제를 쉽게 풀 수 있다.
        - 설계
          1. 문제해결을 위해 수행해야 하는 작업을
          2. 유사한 형태의 여러 조각으로 쪼갠다.
          3. 그 중 한 조각을 수행
          4. 나머지는 자기 자신을 호출해서 해결
          5. 기저사례(base case)를 재귀 함수에 추가
        - 기저 사례(base case)
          1. 더 이상 쪼갤 수 없는 마지막 조각에 도달한 경우
          2. 재귀 호출을 종료하는 조건
          예를 들어 1부터 N까지의 합 f(n) = f(n-1) + n;
          ```java
          int sum(int n){
            if(n == 1)
              return 1;
            return sum(n-1) + n;
          }
          ```
  - 탐색 공간의 배제
      - 전체 탐색 알고리즘을 구현하는 데 있어서 더 이상 탐색하지 않더라도 해를 구하는데 문제가 없는 부분을 판단하여 이 부분에 대해서 탐색을 하지 않도록 하여 탐색의 효율을 높이고자 하는 방법
        - 수학적 배제
          - 이분탐색 알고리즘
          - 수학적으로 공간을 배제해 가는 이 방법은 일종의 탐욕법(Greedy)
        - 경험적 배제
          - 처음 시작은 전체탐색과 마찬가지로 해가 될 수 있는 모든 공간을 탐색해 간다. 차이점은 특정 조건을 두고, 이 조건을 기준으로 다음 상태를 계속 탐색할지의 여부를 결정
          - 특정 조건이란 더 이상 탐색하더라도 해를 구할 수 없음을 판단할 수 있는 조건을 말한다.
          - 알고리즘이 시작될 때는 이 조건을 설정할 수 없고, 탐색을 진행하는 중에 조건을 설정하고, 상황에 따라서 조건이 갱신된다. 탐색한 정보, 즉 경험한 정보를 이용해서 배제할 조건을 정하기 때문에 경험적 배제라고 한다.
          - 일반적으로 가지치기(branch & bound)하고 한다.
          - 어떤 조건에 의해서 더 탐색할 공간이 있음에도 불구하고 돌아오는 흐름을 바운딩(Bounding)혹은 커팅(Cutting)이라고 한다.
        - 구조적 배제
    - 해결 전략에 따른 구현법
      1. 백트래킹(BackTracking)
        - 주어진 답이 나올 때까지 검색하다가 중간에 확실히 이 방향이 아니면 다시 이전 상태로 돌아가서 경로를 찾아보는 방법
        - 검색에 제한을 걸 수 있는 조건이 문제에 주어져야 함
        - 특정 알고리즘이 아닌 문제를 해결하는 하나의 방법
        - 가지치기(Pruning)이라는 방법으로 경우의 수를 줄인다.
        - 재귀(DFS),큐(BFS)
      2. 분할정복(Divide and Conquer)
        - 주어진 문제를 더 작은 문제로 나누어 푸는 방법
        - 문제를 더 이상 나누지 않고 풀 수 있을 떄가지 나눈다.
        - 부분문제의 답을 이용하여 원래 문제의 답을 구한다.
          * DP와의 차이점은 중복호출을 하지 않는다.
            (cf. DP는 중복호출이 일어나 Memoization을 필요로 하는 경우를 말한다.)
        - 요소 : 분할(Divide) / 병합(merge) / 기저 케이스 (base case)
        - 루프, 재귀
        - 병합 정렬(Merge Sort)
          1. 구현하기 쉬운 대표적인 정렬
          2. 최악의 경우 NlongN 복잡도
          3. N만큼의 버퍼공간이 추가로 필요
            - 병합용도
          4. 분할 정복으로 구현
        - 분할 정복 문제는 어떻게 함수를 만들어야 할지 결정해야 한다.
          - 함수 -> 문제를 푸는 함수
            - 작은 문제를 어떻게 호출해야 할지 결정
          - 부분 문제의 정답을 합쳐야 하는 경우에는 합치는 것을 어떻게 해야 할지 결정
      3. 이진탐색
        - 정렬된 구조에서 목적값의 위치를 찾는 방법
        - 탐색 범위를 반으로 줄여가면서 찾는다.
        - 분할 정복의 한 갈래
        ![aa](https://1.bp.blogspot.com/-g9Mh5ZhsV4s/Vx4owwZPt5I/AAAAAAAANY8/Mw_-XcrDhmcDrwEbO1d1m-4Y1ZFGZJOYgCKgB/s1600/binarysearch2.PNG)
      4. DFS(2차원 좌표계에서 DFS 하기)
        - 2차원 좌표로 주어졌을 때 DFS를 하는 경우
          - 지도, 미로, 체스판, 장기 등
        - 임의의 좌표에서 (x,y)에서 상하좌우로 이동가능하다면
          - 배열에서 dx,dy처리하기 방식으로 총 4번의 재귀호출
        - 특정 좌표까지 경우의 수라든지 도달 여부등을 확인할 때 사용 가능
        - 최단거리 문제에서는 부적절함 (시간 초과 발생)
        ![DFS](https://3.bp.blogspot.com/-NGr4uf6bGTU/VyDQNg5X8XI/AAAAAAAANZ0/O2iMjmQtH281m7bskjauC3yG3D7_XYWXgCLcB/s1600/dfs.PNG)
2. **최적화 문제(Optimization Problem)**
  - 문제의 답이 하나가 아니라 여러 개이고, 그 중에서 어떤 기준에 따라 가장 '좋은'답을 찾아 내는 문제들
  - 해결하기 위한 여러 방법들 중에서 가장 기초적인 것이 완전 탐색
    - 시간 안에 답을 구할 수 있는지 확인하는 것이 먼저
    - 문제의 특성을 이용해 단순화할 필요가 있다.
  - 가장 유명한 문제
    - 여행하는 외판원 문제(Traveling Sales-man Problem, TSP)
3. **이분 탐색**
  - 일반적으로 최솟값의 최대화, 최댓값의 최소화 등의 문제에 이용할 수 있는 경우가 많다.
  - 일반적으로 최적화 문제를 결정 문제로 바꿔서 생각
  - 결정 문제의 참/거짓의 결과를 이용하여 이분탐색으로 가장 최적의 해를 탐색하는 방법으로 해를 구한다.
  - **Binary Search**
    - 정렬되어 있는 리스트에서 어떤 값을 빠르게 찾는 알골지ㅡㅁ
    - 리스트의 크기를 N이라고 할 때 logN의 시간이 필요(절반으로 나누기 때문)
      ![이중 탐색](https://2.bp.blogspot.com/-k_upRq1STEY/WFaU6LDVyOI/AAAAAAAAURo/kL9gbk5wZIEdOCD5fPuPfv7oFaWzIoziACEw/s1600/binary%2Bsearch.PNG)

    - **Merge Sort**
      - N 개를 정렬하는 경우
        - N개를 N/2, N/2개로 나누고,
        - 왼쪽과 오른쪽을 정렬하고
        - 두 정렬한 결과를 하나로 합친다.
        ![Merge Sort](https://4.bp.blogspot.com/-tpFk582JdBw/WFaeBFDTYBI/AAAAAAAAUR4/wewpDr3R4Ns--lCD9o_Ec7CQ82XUFsqvgCLcB/s1600/mergesort.PNG)
4. **다이나믹 프로그래밍(Dynamic Programming)**
  - DP, 동적 계획법
  - 두 번 이상 반복 계산되는 부분 문제들의 답을 미리 저장함으로써 속도의 향상을 꾀하는 알고리즘 설계 기법
  - 기본 전략은 문제를 작은 부분 문제로 나누는 것에서 부터 시작한다.
  - 작은 부분 문제를 해결한 결과로 큰 문제를 해결할 수 있다.
  - 특징은 중복되는 부분 문제들이 있다는 것
  - 적용 방법
    1. 문제를 더 작은 부분 문제로 나눈다.
    2. 중복되는 작은 부분 문제는 한 번만 계산해서 그 결과를 저장
    3. 중복되는 작은 부분 문제들은 여러 번 계산하지 않고 저장한 값을 이용
      - 메모이제이션(Memoization)
      (cf. 재귀 함수 + 메모이제이션)  
       - 같은 입력에 대해 결과가 항상 같아야 한다.
       - 같은 입력의 재귀 함수가 (매우 많이) 중복해서 호출된다.
       - 예, 피보나치 수열
     4. 구현 방법
      - *재귀 호출* 을 이용하는 방법
        - Top Down
        - 문제를 작은 문제로 쪼개고, 그 중 한 조각을 해결한 다음 나머지 작은 문제를 같은 방법으로 해결한다.
        - 장단점
          - 구현이 직관적이고 이해하기 쉽다.
          - 전체 부분 문제 중 일부의 답만 필요한 경우 더 빠르게 동작한다.
          - Sliding window를 사용할 수 없다.
          - 스택 오버 플로우를 조심해야 한다.
        - Code Pattern()
        ![asdasd](https://4.bp.blogspot.com/-TBokqAxfWOI/WGJw05jNrLI/AAAAAAAAUcY/w4SuIiz4SoMCubdvPFv2IDRUmly_uVIuQCLcB/s1600/dp%2Btopdown%2Btemplate.PNG)
      - *반복문* 을 이용하는 방법
        - Bottom up
        - 문제 해결에 필요한 가장 작은 문제를 해결하고, 문제를 조금씩 크게 만들어 가면서 해결
        - 장단점
          - 구현이 대게 더 짧다.
          - 재귀 호출보다 조금 더 빠르다.
          - Sliding window 를 사용할 수 있다
          - 구현이 비직관적이고, 이해하기 어렵다
          - 부분 함수들을 해결하는 순서에 신경을 써야 한다.
  - 가장 유명한 DP 문제는 이항 계수(Binomial coefficient)의 계산
    - 이항 계수 C( n, r) 는 n개의 서로 다른 원소 중에 r개의 원소를 순서없이 골라내는 방법의 수를 나타내는 것
      - 점화식: C(n,k) = C(n-1, k-1) + C(n-1, k)
      ![점화식](https://3.bp.blogspot.com/-ySDmUruidBw/V0Ruu_uropI/AAAAAAAANhM/UC9I0DPMq08HxpzwvLAI9f_rsoxkXMfFACLcB/s1600/bino.PNG)
    - 함수의 반환 값이 그 입력값만으로 결정되는 참조적 투명 함수(referential transparent function)의 경우에만 메모이제이션이 적용가능하다.
5. **그래프**
  - 대상(Object)사이의 관계(Relation)를 나타내는 자료구조
  - 대상 -> 정점(Vertex)
  - 관계 -> 간선(Edge)
  - 인접 (Adjacent)
    - 간선으로 연결되어 있는 두 정점을 일컫는 말(이웃 관계)
    - 정점의 차수(degree) -> 정점에 연결되어 있는 간선의 개수 / 인접하는 정점의 수
  - 경로 (Path)
    - 경로 길이 -> 경로를 구성하는 간선의 수
  - 싸이클(Cycle)
    - 두 정점간의 경로에서 동일한 정점을 두 번 이상 거치는 경로
  - 연결성(Connectivity)
    - 무방향성 그래프 내에서 두 정점 사이에 경로가 존재
  - 그래프는 정점의 모음과 이 정점을 잇는 간선의 모음간의 결합
    - 정점의 집합을 V, 간섭의 집합을 E, 그래프를 G라고 했을 때
    - G = (V, E)이다.
  - 간섭의 종류에 따라
    - 무방향 그래프(undirected graph): 양방향 (A,B) = (B,A)
    - 방향 그래프(directed graph) 방향성이 존재
    - 가중치 그래프(weighted graph), 네트워크(network) : 비용이나 가중치
  - 그래프의 표현 방식에 따라 알고리즘의 시간 복잡도가 바뀔 수 있기 때문에 신중하게 선택
    - 간선이 적은 희소 그래프(sparse graph): 인접 리스트
    - 간선이 많은 밀집 그래프(dense graph): 인접 행렬
  - 인접 리스트로 그래프를 표현
    - 그래프 내의 각 정점의 인접 관계를 표현하는 리스트
    - 리스트 보다는 vector 와 같이 길이를 변경할 수 있는 배열로 구현
    ![그래프](https://3.bp.blogspot.com/-2jwrmnBO-cY/WCaOiAJixKI/AAAAAAAATTw/_uH8nBurKIIJjzZl0K8pZcbj9o7JSWpHgCLcB/s1600/adjacentlist.PNG)
  - 인접 행렬로 그래프를 표현
    - 정점의 개수가 N개이면 N*N 행렬을 이용
    - i번째 정점과 j번째 정점의 관계를 G[i][j]에 저장
    - 문제에서 주어지는 번호대로 저장
      - 배열이라고 0부터 하지 말자!!
