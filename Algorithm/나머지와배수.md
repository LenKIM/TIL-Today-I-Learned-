
# 나눗셈과 나머지
프로그래밍 언어에서 정수의 나누기는 몫과 나머지 계산으로 수행

int div = A / B; //몫
int mod = A & B; //나머지

B가 0이면 런타임 에러가 발생함으로 조심..

1.
2. A와 B가 음수가 아닐 때 나머지는 항상 0 ~ (B-1)범위의 정수이다.(총 B)
3. 나머지가 0이고 A와 B가 양수면 A는 B의 배수이고 B는 A의 약수이다.


## 몫과 나머지의 규칙성.

규칙적으로 변하는 수열을 같은 수를 나누면 대부분 규칙성을 가진다.
(이를 바탕으로 문제가 쉽게 해결되는 경우가 많다.)

수열의 시작을 0부터 하면 더 예쁜 규칙이 보이기도 한다.

## 나머지의 닫힘 성질.
나머지를 적용한 값들 끼리 계산을 해도 원래 숫자들로 계산한 후 나눈 나머지와 같은 경우

1. 더하기 (a mod p) + (b mod p) mod p = (a + b) mod p
수가 엄청 클 경우 해당한다
2. 곱하기 (a mod p) X (b mod p) = (a x b) mod p
3. 빼기 ((a mod p) - (b mod p) + p) mod p = (a + b + p) mod p

## 공약수와 공배수
여러 숫자들에게 공통적으로 약수가 되는 숫자를 공약수
여러 숫자들에게 공통적으로 배수가 되는 숫자를 공배수

1. (A % D == 0) 이고 (B % D == 0)이면 D는 A와 B의 공약수
  - A,B가 양수이면 1은 항상 공약수이다.
  - 공약수는 유한 개 존재
2. (M % A == 0) 이고 (M % B == 0)이면 M은 A와 B의 공배수
  - A,B가 양수이면 AB는 항상 공배수이다.
  - 공배수는 무한 개 존재한다.

### 공약수와 공배수의 수학적 특징
 두 숫자를 소인수분해 한 결과들을...
 - 교집합한 결과는 공약수가 된다.
 - 합집합한 결과는 공배수가 된다.

### 공약수 탐색의 구현
공약수는 반복문으로도 찾을 수 있다.
하지만 숫자 크기에 비례하는 시간이 걸린다.
```java
int last = Math.min(a,b);
for(int i = 1; i <= last; i++){
  if(a % i == 0 && b % i == 0){
    // i들은 a와 b의 공약수이다.
  }
}
```

### 유클리드 호제법 알고리즘
 두 정수의 최대 공약수를 빠르게 계산할 수 있다.
 1. A와 B에 두 정수를 담는다.
 2. 아래의 과정을 반복한다.
  - C 에 A % B를 저장
  - C가 0이면 B가 최대공약수 반복종료
  - 그렇지 않으면 A에 B의 값 덮어쓰고,B에 C의 값 덮어쓴다.
 3. 위의 과정이 종료된 후 B에 저장된 값이 최대 공약수이다.

유클리드 호제법 활용하기..
A | B | A%B
24 | 8 | 6
18 | 6 | 0

시간 복잡도는??? (Logx) 꽤 좋은 편임...

 최대 공약수만 알고 있으면 최소 공배수도 쉽게 계산할 수 있다.
 최소 공배수는 두 수를 곱하고 최대 공약수로 나누어 주면 된다.
 L = G x a x b (L은 최소 공배수 G는 최대 공약수)
